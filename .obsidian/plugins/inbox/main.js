/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports, module2) {
    var __extends2;
    var __assign2;
    var __rest2;
    var __decorate2;
    var __param2;
    var __metadata2;
    var __awaiter2;
    var __generator2;
    var __exportStar2;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays2;
    var __spreadArray2;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __classPrivateFieldIn2;
    var __createBinding2;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      __extends2 = function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      __rest2 = function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      __decorate2 = function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param2 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata2 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar2 = function(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding2(o, m, p);
      };
      __createBinding2 = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __values2 = function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read2 = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread2 = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read2(arguments[i]));
        return ar;
      };
      __spreadArrays2 = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      };
      __spreadArray2 = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await2 = function(v) {
        return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator2 = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await2(o[n](v)), done: n === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues2 = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject2 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar2 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault2 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      __classPrivateFieldIn2 = function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate2);
      exporter("__param", __param2);
      exporter("__metadata", __metadata2);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar2);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray2);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn2);
    });
  }
});

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module2) {
    !function(t, e) {
      typeof exports == "object" && typeof module2 != "undefined" ? module2.exports = e() : typeof define == "function" && define.amd ? define(e) : (t = typeof globalThis != "undefined" ? globalThis : t || self).dayjs = e();
    }(exports, function() {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", f = "month", h = "quarter", c = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
        var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
        return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
      } }, m = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, v = { s: m, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date())
          return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, f), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), f);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: f, y: c, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: h }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return t2 === void 0;
      } }, g = "en", D = {};
      D[g] = M;
      var p = function(t2) {
        return t2 instanceof _;
      }, S = function t2(e2, n2, r2) {
        var i2;
        if (!e2)
          return g;
        if (typeof e2 == "string") {
          var s2 = e2.toLowerCase();
          D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1)
            return t2(u2[0]);
        } else {
          var a2 = e2.name;
          D[a2] = e2, i2 = a2;
        }
        return !r2 && i2 && (g = i2), i2 || !r2 && g;
      }, w = function(t2, e2) {
        if (p(t2))
          return t2.clone();
        var n2 = typeof e2 == "object" ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, O = v;
      O.l = S, O.i = p, O.w = function(t2, e2) {
        return w(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _ = function() {
        function M2(t2) {
          this.$L = S(t2.locale, null, true), this.parse(t2);
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (e2 === null)
              return new Date(NaN);
            if (O.u(e2))
              return new Date();
            if (e2 instanceof Date)
              return new Date(e2);
            if (typeof e2 == "string" && !/Z$/i.test(e2)) {
              var r2 = e2.match($);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t2), this.$x = t2.x || {}, this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return O;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l);
        }, m2.isSame = function(t2, e2) {
          var n2 = w(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return w(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < w(t2);
        }, m2.$g = function(t2, e2, n2) {
          return O.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!O.u(e2) || e2, h2 = O.p(t2), l2 = function(t3, e3) {
            var i2 = O.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, $2 = function(t3, e3) {
            return O.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (h2) {
            case c:
              return r2 ? l2(1, 0) : l2(31, 11);
            case f:
              return r2 ? l2(1, M3) : l2(0, M3 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = O.p(t2), h2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = h2 + "Date", n2[d] = h2 + "Date", n2[f] = h2 + "Month", n2[c] = h2 + "FullYear", n2[u] = h2 + "Hours", n2[s] = h2 + "Minutes", n2[i] = h2 + "Seconds", n2[r] = h2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === f || o2 === c) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else
            l2 && this.$d[l2]($2);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[O.p(t2)]();
        }, m2.add = function(r2, h2) {
          var d2, l2 = this;
          r2 = Number(r2);
          var $2 = O.p(h2), y2 = function(t2) {
            var e2 = w(l2);
            return O.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
          };
          if ($2 === f)
            return this.set(f, this.$M + r2);
          if ($2 === c)
            return this.set(c, this.$y + r2);
          if ($2 === a)
            return y2(1);
          if ($2 === o)
            return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return O.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid())
            return n2.invalidDate || l;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, f2 = n2.months, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
          }, c2 = function(t3) {
            return O.s(s2 % 12 || 12, t3, "0");
          }, d2 = n2.meridiem || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          }, $2 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a2 + 1, MM: O.s(a2 + 1, 2, "0"), MMM: h2(n2.monthsShort, a2, f2, 3), MMMM: h2(f2, a2), D: this.$D, DD: O.s(this.$D, 2, "0"), d: String(this.$W), dd: h2(n2.weekdaysMin, this.$W, o2, 2), ddd: h2(n2.weekdaysShort, this.$W, o2, 3), dddd: o2[this.$W], H: String(s2), HH: O.s(s2, 2, "0"), h: c2(1), hh: c2(2), a: d2(s2, u2, true), A: d2(s2, u2, false), m: String(u2), mm: O.s(u2, 2, "0"), s: String(this.$s), ss: O.s(this.$s, 2, "0"), SSS: O.s(this.$ms, 3, "0"), Z: i2 };
          return r2.replace(y, function(t3, e3) {
            return e3 || $2[t3] || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, l2) {
          var $2, y2 = O.p(d2), M3 = w(r2), m3 = (M3.utcOffset() - this.utcOffset()) * e, v2 = this - M3, g2 = O.m(this, M3);
          return g2 = ($2 = {}, $2[c] = g2 / 12, $2[f] = g2, $2[h] = g2 / 3, $2[o] = (v2 - m3) / 6048e5, $2[a] = (v2 - m3) / 864e5, $2[u] = v2 / n, $2[s] = v2 / e, $2[i] = v2 / t, $2)[y2] || v2, l2 ? g2 : O.a(g2);
        }, m2.daysInMonth = function() {
          return this.endOf(f).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2)
            return this.$L;
          var n2 = this.clone(), r2 = S(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return O.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), T = _.prototype;
      return w.prototype = T, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", f], ["$y", c], ["$D", d]].forEach(function(t2) {
        T[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), w.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _, w), t2.$i = true), w;
      }, w.locale = S, w.isDayjs = p, w.unix = function(t2) {
        return w(1e3 * t2);
      }, w.en = D[g], w.Ls = D, w.p = {}, w;
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => InboxPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian9 = require("obsidian");

// node_modules/svelte/internal/index.mjs
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return tar;
}
function run(fn2) {
  return fn2();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store2, ...callbacks) {
  if (store2 == null) {
    return noop;
  }
  const unsub = store2.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store2) {
  let value;
  subscribe(store2, (_) => value = _)();
  return value;
}
function component_subscribe(component, store2, callback) {
  component.$$.on_destroy.push(subscribe(store2, callback));
}
function create_slot(definition, ctx, $$scope, fn2) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn2);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn2) {
  return definition[1] && fn2 ? assign($$scope.ctx.slice(), definition[1](fn2(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn2) {
  if (definition[2] && fn2) {
    const lets = definition[2](fn2(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
function set_store_value(store2, ret, value) {
  store2.set(value);
  return ret;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function to_number(value) {
  return value === "" ? null : +value;
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value === null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function select_option(select, value) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  select.selectedIndex = -1;
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, cancelable, detail);
  return e;
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn2) {
  get_current_component().$$.on_mount.push(fn2);
}
function onDestroy(fn2) {
  get_current_component().$$.on_destroy.push(fn2);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail, { cancelable });
      callbacks.slice().forEach((fn2) => {
        fn2.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn2) => fn2.call(this, event));
  }
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn2) {
  render_callbacks.push(fn2);
}
function add_flush_callback(fn2) {
  flush_callbacks.push(fn2);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance20, create_fragment20, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance20 ? instance20(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment20 ? create_fragment20($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function readable(value, start2) {
  return {
    subscribe: writable(value, start2).subscribe
  };
}
function writable(value, start2 = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn2) {
    set(fn2(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start2(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
function derived(stores, fn2, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  const auto2 = fn2.length < 2;
  return readable(initial_value, (set) => {
    let inited = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn2(single ? values[0] : values, set);
      if (auto2) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map((store2, i) => subscribe(store2, (value) => {
      values[i] = value;
      pending &= ~(1 << i);
      if (inited) {
        sync();
      }
    }, () => {
      pending |= 1 << i;
    }));
    inited = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
    };
  });
}

// src/walkthrough/WalkthroughStatus.ts
var WalkthroughStatuses = /* @__PURE__ */ ((WalkthroughStatuses2) => {
  WalkthroughStatuses2["unstarted"] = "unstarted";
  WalkthroughStatuses2["setCompareFileOrFolder"] = "setCompareFileOrFolder";
  WalkthroughStatuses2["setCompareType"] = "setCompareType";
  WalkthroughStatuses2["setInboxPath"] = "setInboxPath";
  WalkthroughStatuses2["restartObsidian"] = "restartObsidian";
  WalkthroughStatuses2["completed"] = "completed";
  return WalkthroughStatuses2;
})(WalkthroughStatuses || {});

// src/walkthrough/walkthrough-state-machine.ts
var machine = {
  initial: "unstarted" /* unstarted */,
  states: {
    ["unstarted" /* unstarted */]: {
      ["next" /* next */]: "setCompareFileOrFolder" /* setCompareFileOrFolder */
    },
    ["setCompareFileOrFolder" /* setCompareFileOrFolder */]: {
      ["next" /* next */]: {
        ["note" /* note */]: "setCompareType" /* setCompareType */,
        ["folder" /* folder */]: "setInboxPath" /* setInboxPath */
      }
    },
    ["setCompareType" /* setCompareType */]: {
      ["previous" /* previous */]: "setCompareFileOrFolder" /* setCompareFileOrFolder */,
      ["next" /* next */]: "setInboxPath" /* setInboxPath */
    },
    ["setInboxPath" /* setInboxPath */]: {
      ["previous" /* previous */]: {
        ["note" /* note */]: "setCompareType" /* setCompareType */,
        ["folder" /* folder */]: "setCompareFileOrFolder" /* setCompareFileOrFolder */
      },
      ["next" /* next */]: "restartObsidian" /* restartObsidian */
    },
    ["restartObsidian" /* restartObsidian */]: {
      ["previous" /* previous */]: "setInboxPath" /* setInboxPath */,
      ["next" /* next */]: "completed" /* completed */
    },
    ["completed" /* completed */]: {
      ["previous" /* previous */]: "restartObsidian" /* restartObsidian */
    }
  }
};
function transition(state, action) {
  var _a;
  const to = machine.states[state.walkthroughStatus][action];
  if (typeof to === "string") {
    state.walkthroughStatus = to;
  } else if (typeof to === "object") {
    const trackingType = (_a = state.inboxes.at(-1)) == null ? void 0 : _a.trackingType;
    if (trackingType) {
      state.walkthroughStatus = to[trackingType];
    }
  }
  return state;
}

// src/settings/Inbox.ts
var DEFAULT_INBOX = Object.freeze({
  trackingType: "note",
  path: "",
  compareType: "compareToLastTracked",
  inboxNoteBaseContents: "",
  inboxNoteContents: "",
  inboxFolderFiles: [],
  noticeDurationSeconds: null
});

// src/store.ts
function createStore() {
  const { subscribe: subscribe2, set, update: update2 } = writable();
  const walkthrough = {
    next() {
      update2((settings) => transition(settings, "next" /* next */));
    },
    previous() {
      update2((settings) => transition(settings, "previous" /* previous */));
    },
    complete() {
      update2((settings) => {
        settings.walkthroughStatus = "completed" /* completed */;
        return settings;
      });
    },
    start() {
      update2((settings) => {
        settings.walkthroughStatus = "setCompareFileOrFolder" /* setCompareFileOrFolder */;
        return settings;
      });
    }
  };
  function addInbox() {
    update2((settings) => {
      settings.inboxes.push({ ...DEFAULT_INBOX });
      return settings;
    });
  }
  function moveInboxUp(index) {
    update2((settings) => {
      if (index - 1 >= 0) {
        const replaced = settings.inboxes.at(index - 1);
        if (replaced) {
          settings.inboxes[index - 1] = settings.inboxes[index];
          settings.inboxes[index] = replaced;
        }
      }
      return settings;
    });
  }
  function moveInboxDown(index) {
    update2((settings) => {
      if (index <= settings.inboxes.length) {
        const replaced = settings.inboxes.at(index + 1);
        if (replaced) {
          settings.inboxes[index + 1] = settings.inboxes[index];
          settings.inboxes[index] = replaced;
        }
      }
      return settings;
    });
  }
  function removeInbox(index) {
    update2((settings) => {
      settings.inboxes.splice(index, 1);
      return settings;
    });
  }
  return {
    subscribe: subscribe2,
    set,
    walkthrough,
    addInbox,
    moveInboxUp,
    moveInboxDown,
    removeInbox
  };
}
var store = createStore();
var lastInbox = derived(store, (values) => values.inboxes[values.inboxes.length - 1]);
var lastInboxIndex = derived(store, (values) => values.inboxes.length - 1);
var store_default = store;

// src/obsidian/tabstractfile-helpers.ts
var import_obsidian = require("obsidian");
function getAllFilesInFolderRecursive(folder) {
  return folder.children.flatMap((child) => {
    if (child instanceof import_obsidian.TFolder) {
      return getAllFilesInFolderRecursive(child);
    }
    return child.path;
  });
}
async function readFile(app, file) {
  return (await app.vault.read(file)).trim();
}

// src/obsidian/workspace-helpers.ts
var import_obsidian2 = require("obsidian");
function findMarkdownLeavesMatchingPath(workspace, path) {
  const results = [];
  workspace.iterateAllLeaves((leaf) => {
    var _a;
    if (leaf.view instanceof import_obsidian2.MarkdownView) {
      const leafFilePath = (_a = leaf.getViewState().state) == null ? void 0 : _a.file;
      if (leafFilePath && leafFilePath === path) {
        results.push(leaf);
      }
    }
  });
  return results;
}

// src/Notice.ts
var import_obsidian3 = require("obsidian");
var DEFAULT_NOTICE_TIMEOUT_SECONDS = 5;
var InfoNotice = class extends import_obsidian3.Notice {
  constructor(message, timeout = DEFAULT_NOTICE_TIMEOUT_SECONDS) {
    super(`Inbox
${message}`, timeout * 1e3);
    console.info(`obsidian-inbox: ${message}`);
  }
};
var ErrorNotice = class extends import_obsidian3.Notice {
  constructor(message, timeout = DEFAULT_NOTICE_TIMEOUT_SECONDS) {
    super(`Inbox
${message}`, timeout * 1e3);
    console.error(`obsidian-inbox: ${message}`);
  }
};

// src/settings/InboxPluginSettingsV2.ts
var DEFAULT_SETTINGS = Object.freeze({
  inboxes: [{ ...DEFAULT_INBOX }],
  walkthroughStatus: "unstarted"
});
function isInboxPluginSettingsV2(obj) {
  return !!(obj && typeof obj === "object" && "inboxes" in obj);
}

// src/settings/InboxPluginSettingsV1.ts
function isInboxPluginSettingsV1(obj) {
  return !!(obj && typeof obj === "object" && "inboxNotePath" in obj);
}

// src/settings/migrate-settings.ts
function migrateSettings(settings) {
  if (isInboxPluginSettingsV1(settings)) {
    if (settings.trackingType === "note" && settings.inboxNotePath && !settings.inboxNotePath.endsWith(".md")) {
      settings.inboxNotePath += ".md";
    }
    settings = migrateV1ToV2(settings);
  }
  if (isInboxPluginSettingsV2(settings)) {
    return settings;
  }
}
function migrateV1ToV2(settings) {
  const inbox = { ...settings, path: settings.inboxNotePath };
  if ("inboxNotePath" in inbox) {
    delete inbox.inboxNotePath;
  }
  if ("walkthroughStatus" in inbox) {
    delete inbox.walkthroughStatus;
  }
  return {
    inboxes: [inbox],
    walkthroughStatus: settings.walkthroughStatus
  };
}

// src/settings-tab/SettingsTab.ts
var import_obsidian7 = require("obsidian");

// src/obsidian/vault-helpers.ts
var import_obsidian4 = require("obsidian");
function getFolders(vault) {
  return vault.getAllLoadedFiles().filter((x) => x instanceof import_obsidian4.TFolder);
}

// node_modules/tslib/modules/index.js
var import_tslib = __toESM(require_tslib(), 1);
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn
} = import_tslib.default;

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element2) {
  return element2 ? (element2.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element2 = state.elements[name];
    if (!isHTMLElement(element2) || !getNodeName(element2)) {
      return;
    }
    Object.assign(element2.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element2.removeAttribute(name2);
      } else {
        element2.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element2 = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element2) || !getNodeName(element2)) {
        return;
      }
      Object.assign(element2.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element2.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element2, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element2.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element2)) {
    scaleX = element2.offsetWidth > 0 ? round(clientRect.width) / element2.offsetWidth || 1 : 1;
    scaleY = element2.offsetHeight > 0 ? round(clientRect.height) / element2.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element2) ? getWindow(element2) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element2) {
  var clientRect = getBoundingClientRect(element2);
  var width = element2.offsetWidth;
  var height = element2.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element2.offsetLeft,
    y: element2.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle2(element2) {
  return getWindow(element2).getComputedStyle(element2);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element2) {
  return ["table", "td", "th"].indexOf(getNodeName(element2)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element2) {
  return ((isElement(element2) ? element2.ownerDocument : element2.document) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element2) {
  if (getNodeName(element2) === "html") {
    return element2;
  }
  return element2.assignedSlot || element2.parentNode || (isShadowRoot(element2) ? element2.host : null) || getDocumentElement(element2);
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element2) {
  if (!isHTMLElement(element2) || getComputedStyle2(element2).position === "fixed") {
    return null;
  }
  return element2.offsetParent;
}
function getContainingBlock(element2) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element2)) {
    var elementCss = getComputedStyle2(element2);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element2);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element2) {
  var window2 = getWindow(element2);
  var offsetParent = getTrueOffsetParent(element2);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (true) {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x = _ref.x, y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if (true) {
    var transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance20 = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance20.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance20.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance20.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance20.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element2, strategy) {
  var win = getWindow(element2);
  var html = getDocumentElement(element2);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element2),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element2) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element2);
  var winScroll = getWindowScroll(element2);
  var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element2);
  var y = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element2) {
  var _getComputedStyle = getComputedStyle2(element2), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element2, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element2);
  var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element2, strategy) {
  var rect = getBoundingClientRect(element2, false, strategy === "fixed");
  rect.top = rect.top + element2.clientTop;
  rect.left = rect.left + element2.clientLeft;
  rect.bottom = rect.top + element2.clientHeight;
  rect.right = rect.left + element2.clientWidth;
  rect.width = element2.clientWidth;
  rect.height = element2.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element2, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element2, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));
}
function getClippingParents(element2) {
  var clippingParents2 = listScrollParents(getParentNode(element2));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element2).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element2, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element2) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element2, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element2, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element2 = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element2.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element2.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element2 = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
    if (true) {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element2) {
  return {
    scrollLeft: element2.scrollLeft,
    scrollTop: element2.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element2) {
  var rect = element2.getBoundingClientRect();
  var scaleX = round(rect.width) / element2.offsetWidth || 1;
  var scaleY = round(rect.height) / element2.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/format.js
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p, c) {
    return p.replace(/%s/, c);
  }, str);
}

// node_modules/@popperjs/core/lib/utils/validateModifiers.js
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self2) {
      return self2.indexOf(value) === index;
    }).forEach(function(key) {
      switch (key) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
          break;
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (modifier.effect != null && typeof modifier.effect !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
            return '"' + s + '"';
          }).join(", ") + '; but "' + key + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

// node_modules/@popperjs/core/lib/utils/uniqueBy.js
function uniqueBy(arr, fn2) {
  var identifiers = /* @__PURE__ */ new Set();
  return arr.filter(function(item) {
    var identifier = fn2(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element2) {
    return !(element2 && typeof element2.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance20 = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        if (true) {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name = _ref2.name;
              return name === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle2(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance20.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (true) {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance: instance20
            }) || state;
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance20.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance20;
    }
    instance20.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance: instance20,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance20;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// node_modules/svelte-portal/src/Portal.svelte
function create_fragment(ctx) {
  let div;
  let portal_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      div.hidden = true;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(portal_action = portal.call(null, div, ctx[0]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[1], !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null), null);
        }
      }
      if (portal_action && is_function(portal_action.update) && dirty & 1)
        portal_action.update.call(null, ctx2[0]);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function portal(el, target = "body") {
  let targetEl;
  async function update2(newTarget) {
    target = newTarget;
    if (typeof target === "string") {
      targetEl = document.querySelector(target);
      if (targetEl === null) {
        await tick();
        targetEl = document.querySelector(target);
      }
      if (targetEl === null) {
        throw new Error(`No element found matching css selector: "${target}"`);
      }
    } else if (target instanceof HTMLElement) {
      targetEl = target;
    } else {
      throw new TypeError(`Unknown portal target type: ${target === null ? "null" : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);
    }
    targetEl.appendChild(el);
    el.hidden = false;
  }
  function destroy() {
    if (el.parentNode) {
      el.parentNode.removeChild(el);
    }
  }
  update2(target);
  return { update: update2, destroy };
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { target = "body" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("target" in $$props2)
      $$invalidate(0, target = $$props2.target);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [target, $$scope, slots];
}
var Portal = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { target: 0 });
  }
};
var Portal_default = Portal;

// node_modules/svelte-portal/src/main.es.js
var main_es_default = Portal_default;

// node_modules/obsidian-svelte/Popover/useClickOutside.js
function useClickOutside(element2, { onClickOutside, anchorEl, open }) {
  function onClick(event) {
    if (open && !anchorEl.contains(event.target) && !element2.contains(event.target)) {
      onClickOutside();
    }
  }
  document.body.addEventListener("click", onClick);
  return {
    update(props) {
      onClickOutside = props.onClickOutside;
    },
    destroy() {
      document.body.removeEventListener("click", onClick);
    }
  };
}

// node_modules/obsidian-svelte/Popover/Popover.svelte
function add_css(target) {
  append_styles(target, "svelte-1xg3ic1", ".layer.svelte-1xg3ic1{z-index:var(--layer-popover)}");
}
function create_if_block(ctx) {
  let portal2;
  let current;
  portal2 = new main_es_default({
    props: {
      target: document.body,
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(portal2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(portal2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const portal_changes = {};
      if (dirty & 527) {
        portal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portal2.$set(portal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portal2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portal2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(portal2, detaching);
    }
  };
}
function create_default_slot(ctx) {
  let div;
  let div_class_value;
  let useClickOutside_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", div_class_value = null_to_empty(ctx[2]) + " svelte-1xg3ic1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[7](div);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useClickOutside_action = useClickOutside.call(null, div, {
          open: ctx[0],
          anchorEl: ctx[1],
          onClickOutside: ctx[8]
        }));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[9], !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, null), null);
        }
      }
      if (!current || dirty & 4 && div_class_value !== (div_class_value = null_to_empty(ctx2[2]) + " svelte-1xg3ic1")) {
        attr(div, "class", div_class_value);
      }
      if (useClickOutside_action && is_function(useClickOutside_action.update) && dirty & 3)
        useClickOutside_action.update.call(null, {
          open: ctx2[0],
          anchorEl: ctx2[1],
          onClickOutside: ctx2[8]
        });
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] && create_if_block(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { anchorEl } = $$props;
  let { open } = $$props;
  let { className = "popover layer" } = $$props;
  let { onClose = () => {
  } } = $$props;
  let { placement = "bottom-start" } = $$props;
  let popperEl;
  let popper2 = null;
  const params = {
    placement,
    modifiers: [
      {
        name: "offset",
        options: { offset: [0, 4] }
      }
    ]
  };
  onDestroy(() => {
    if (popper2) {
      popper2.destroy();
    }
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      popperEl = $$value;
      $$invalidate(3, popperEl);
    });
  }
  const useClickOutside_function = () => $$invalidate(0, open = false);
  $$self.$$set = ($$props2) => {
    if ("anchorEl" in $$props2)
      $$invalidate(1, anchorEl = $$props2.anchorEl);
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
    if ("className" in $$props2)
      $$invalidate(2, className = $$props2.className);
    if ("onClose" in $$props2)
      $$invalidate(4, onClose = $$props2.onClose);
    if ("placement" in $$props2)
      $$invalidate(5, placement = $$props2.placement);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 10) {
      $: {
        if (anchorEl && popperEl) {
          popper2 = createPopper(anchorEl, popperEl, params);
        }
      }
    }
    if ($$self.$$.dirty & 17) {
      $:
        if (!open) {
          onClose();
        }
    }
  };
  return [
    open,
    anchorEl,
    className,
    popperEl,
    onClose,
    placement,
    slots,
    div_binding,
    useClickOutside_function,
    $$scope
  ];
}
var Popover = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      anchorEl: 1,
      open: 0,
      className: 2,
      onClose: 4,
      placement: 5
    }, add_css);
  }
};
var Popover_default = Popover;

// node_modules/obsidian-svelte/Icon/Icon.svelte
function add_css2(target) {
  append_styles(target, "svelte-s7qdhh", "span.svelte-s7qdhh{color:var(--icon-color);fill:var(--icon-color);opacity:var(--icon-opacity);display:flex;flex:0 1 auto}.icon-xs.svelte-s7qdhh{--icon-size:var(--icon-xs);--icon-stroke:var(--icon-xs-stroke-width)}.icon-sm.svelte-s7qdhh{--icon-size:var(--icon-s);--icon-stroke:var(--icon-s-stroke-width)}.icon-md.svelte-s7qdhh{--icon-size:var(--icon-m);--icon-stroke:var(--icon-m-stroke-width)}.icon-lg.svelte-s7qdhh{--icon-size:var(--icon-l);--icon-stroke:var(--icon-l-stroke-width)}.accent.svelte-s7qdhh{color:var(--text-on-accent);fill:var(--text-on-accent)}");
}
function create_fragment3(ctx) {
  let span;
  let useIcon_action;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      attr(span, "aria-label", ctx[3]);
      attr(span, "class", "svelte-s7qdhh");
      toggle_class(span, "accent", ctx[2]);
      toggle_class(span, "icon-xs", ctx[1] === "xs");
      toggle_class(span, "icon-sm", ctx[1] === "sm");
      toggle_class(span, "icon-md", ctx[1] === "md");
      toggle_class(span, "icon-lg", ctx[1] === "lg");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (!mounted) {
        dispose = action_destroyer(useIcon_action = useIcon.call(null, span, ctx[0]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 8) {
        attr(span, "aria-label", ctx2[3]);
      }
      if (useIcon_action && is_function(useIcon_action.update) && dirty & 1)
        useIcon_action.update.call(null, ctx2[0]);
      if (dirty & 4) {
        toggle_class(span, "accent", ctx2[2]);
      }
      if (dirty & 2) {
        toggle_class(span, "icon-xs", ctx2[1] === "xs");
      }
      if (dirty & 2) {
        toggle_class(span, "icon-sm", ctx2[1] === "sm");
      }
      if (dirty & 2) {
        toggle_class(span, "icon-md", ctx2[1] === "md");
      }
      if (dirty & 2) {
        toggle_class(span, "icon-lg", ctx2[1] === "lg");
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { name } = $$props;
  let { size = "md" } = $$props;
  let { accent = false } = $$props;
  let { tooltip = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("size" in $$props2)
      $$invalidate(1, size = $$props2.size);
    if ("accent" in $$props2)
      $$invalidate(2, accent = $$props2.accent);
    if ("tooltip" in $$props2)
      $$invalidate(3, tooltip = $$props2.tooltip);
  };
  return [name, size, accent, tooltip];
}
var Icon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, { name: 0, size: 1, accent: 2, tooltip: 3 }, add_css2);
  }
};
var Icon_default = Icon;

// node_modules/obsidian-svelte/Icon/useIcon.js
var import_obsidian5 = require("obsidian");
function useIcon(node, name) {
  (0, import_obsidian5.setIcon)(node, name);
  return {
    update(name2) {
      (0, import_obsidian5.setIcon)(node, name2);
    }
  };
}

// node_modules/obsidian-svelte/Popover/Suggestion.svelte
function create_default_slot2(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "suggestion");
      set_style(div, "max-height", "300px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment4(ctx) {
  let popover;
  let current;
  popover = new Popover_default({
    props: {
      anchorEl: ctx[0],
      open: ctx[1],
      placement: ctx[3],
      className: "suggestion-container",
      onClose: ctx[2],
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(popover.$$.fragment);
    },
    m(target, anchor) {
      mount_component(popover, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const popover_changes = {};
      if (dirty & 1)
        popover_changes.anchorEl = ctx2[0];
      if (dirty & 2)
        popover_changes.open = ctx2[1];
      if (dirty & 8)
        popover_changes.placement = ctx2[3];
      if (dirty & 4)
        popover_changes.onClose = ctx2[2];
      if (dirty & 32) {
        popover_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popover.$set(popover_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(popover.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popover.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(popover, detaching);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { anchorEl } = $$props;
  let { open } = $$props;
  let { onClose = () => {
  } } = $$props;
  let { placement = "bottom-start" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("anchorEl" in $$props2)
      $$invalidate(0, anchorEl = $$props2.anchorEl);
    if ("open" in $$props2)
      $$invalidate(1, open = $$props2.open);
    if ("onClose" in $$props2)
      $$invalidate(2, onClose = $$props2.onClose);
    if ("placement" in $$props2)
      $$invalidate(3, placement = $$props2.placement);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [anchorEl, open, onClose, placement, slots, $$scope];
}
var Suggestion = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      anchorEl: 0,
      open: 1,
      onClose: 2,
      placement: 3
    });
  }
};
var Suggestion_default = Suggestion;

// node_modules/obsidian-svelte/Popover/SuggestionItem.svelte
function create_fragment5(ctx) {
  let div4;
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  let t3;
  let div3;
  let mounted;
  let dispose;
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text(ctx[1]);
      t1 = space();
      div1 = element("div");
      t2 = text(ctx[2]);
      t3 = space();
      div3 = element("div");
      attr(div0, "class", "suggestion-title");
      attr(div1, "class", "suggestion-note");
      attr(div2, "class", "suggestion-content");
      attr(div3, "class", "suggestion-aux");
      attr(div4, "class", "suggestion-item mod-complex");
      toggle_class(div4, "is-selected", ctx[0]);
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t2);
      append(div4, t3);
      append(div4, div3);
      ctx[5](div4);
      if (!mounted) {
        dispose = [
          listen(div4, "mouseenter", ctx[6]),
          listen(div4, "mouseleave", ctx[7]),
          listen(div4, "mousedown", ctx[8])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2)
        set_data(t0, ctx2[1]);
      if (dirty & 4)
        set_data(t2, ctx2[2]);
      if (dirty & 1) {
        toggle_class(div4, "is-selected", ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div4);
      ctx[5](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { label } = $$props;
  let { description = "" } = $$props;
  let { selected = false } = $$props;
  const dispatch = createEventDispatcher();
  let ref;
  function div4_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(3, ref);
    });
  }
  const mouseenter_handler = () => {
    $$invalidate(0, selected = true);
  };
  const mouseleave_handler = () => $$invalidate(0, selected = false);
  const mousedown_handler = () => dispatch("click");
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
    if ("description" in $$props2)
      $$invalidate(2, description = $$props2.description);
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        dispatch("select", selected);
    }
    if ($$self.$$.dirty & 9) {
      $: {
        if (selected && ref) {
          ref.scrollIntoView({ block: "nearest", inline: "nearest" });
        }
      }
    }
  };
  return [
    selected,
    label,
    description,
    ref,
    dispatch,
    div4_binding,
    mouseenter_handler,
    mouseleave_handler,
    mousedown_handler
  ];
}
var SuggestionItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, { label: 1, description: 2, selected: 0 });
  }
};
var SuggestionItem_default = SuggestionItem;

// node_modules/obsidian-svelte/Input/Input.svelte
function add_css3(target) {
  append_styles(target, "svelte-su9mt0", ".embed.svelte-su9mt0{all:unset;box-sizing:border-box;padding:6px;font-weight:400;font-family:var(--font-default);color:var(--text-normal)}.embed.svelte-su9mt0:focus{box-shadow:none}.noPadding.svelte-su9mt0{padding:0}.error.svelte-su9mt0{border-color:var(--background-modifier-error)}.error.svelte-su9mt0:hover{border-color:var(--background-modifier-error-hover)}.error.svelte-su9mt0:focus{box-shadow:0 0 0 2px var(--background-modifier-error);border-color:var(--background-modifier-error)}small.svelte-su9mt0{margin-top:var(--size-4-1);font-size:var(--font-ui-smaller);color:var(--text-muted);display:block}.errorText.svelte-su9mt0{color:var(--text-error)}");
}
function create_if_block2(ctx) {
  let small;
  let t;
  return {
    c() {
      small = element("small");
      t = text(ctx[9]);
      attr(small, "class", "svelte-su9mt0");
      toggle_class(small, "errorText", ctx[6]);
    },
    m(target, anchor) {
      insert(target, small, anchor);
      append(small, t);
    },
    p(ctx2, dirty) {
      if (dirty & 512)
        set_data(t, ctx2[9]);
      if (dirty & 64) {
        toggle_class(small, "errorText", ctx2[6]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
function create_fragment6(ctx) {
  let div;
  let input;
  let input_style_value;
  let t;
  let div_style_value;
  let mounted;
  let dispose;
  let if_block = !!ctx[9] && create_if_block2(ctx);
  return {
    c() {
      div = element("div");
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      input.value = ctx[2];
      attr(input, "type", ctx[1]);
      attr(input, "placeholder", ctx[4]);
      input.readOnly = ctx[3];
      attr(input, "style", input_style_value = `width: ${ctx[5]}`);
      attr(input, "class", "svelte-su9mt0");
      toggle_class(input, "error", ctx[6]);
      toggle_class(input, "embed", ctx[7]);
      toggle_class(input, "noPadding", ctx[8]);
      attr(div, "style", div_style_value = `width: ${ctx[5]}`);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      ctx[16](input);
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[11]),
          listen(input, "focus", ctx[12]),
          listen(input, "blur", ctx[13]),
          listen(input, "keydown", ctx[14]),
          listen(input, "keyup", ctx[15])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4 && input.value !== ctx2[2]) {
        input.value = ctx2[2];
      }
      if (dirty & 2) {
        attr(input, "type", ctx2[1]);
      }
      if (dirty & 16) {
        attr(input, "placeholder", ctx2[4]);
      }
      if (dirty & 8) {
        input.readOnly = ctx2[3];
      }
      if (dirty & 32 && input_style_value !== (input_style_value = `width: ${ctx2[5]}`)) {
        attr(input, "style", input_style_value);
      }
      if (dirty & 64) {
        toggle_class(input, "error", ctx2[6]);
      }
      if (dirty & 128) {
        toggle_class(input, "embed", ctx2[7]);
      }
      if (dirty & 256) {
        toggle_class(input, "noPadding", ctx2[8]);
      }
      if (!!ctx2[9]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 32 && div_style_value !== (div_style_value = `width: ${ctx2[5]}`)) {
        attr(div, "style", div_style_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[16](null);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { type } = $$props;
  let { value } = $$props;
  let { ref = null } = $$props;
  let { readonly = false } = $$props;
  let { placeholder = "" } = $$props;
  let { autoFocus = false } = $$props;
  let { width = "auto" } = $$props;
  let { error = false } = $$props;
  let { embed = false } = $$props;
  let { noPadding = false } = $$props;
  let { helperText = "" } = $$props;
  const dispatch = createEventDispatcher();
  onMount(() => {
    if (autoFocus && ref) {
      ref.focus();
    }
  });
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(1, type = $$props2.type);
    if ("value" in $$props2)
      $$invalidate(2, value = $$props2.value);
    if ("ref" in $$props2)
      $$invalidate(0, ref = $$props2.ref);
    if ("readonly" in $$props2)
      $$invalidate(3, readonly = $$props2.readonly);
    if ("placeholder" in $$props2)
      $$invalidate(4, placeholder = $$props2.placeholder);
    if ("autoFocus" in $$props2)
      $$invalidate(10, autoFocus = $$props2.autoFocus);
    if ("width" in $$props2)
      $$invalidate(5, width = $$props2.width);
    if ("error" in $$props2)
      $$invalidate(6, error = $$props2.error);
    if ("embed" in $$props2)
      $$invalidate(7, embed = $$props2.embed);
    if ("noPadding" in $$props2)
      $$invalidate(8, noPadding = $$props2.noPadding);
    if ("helperText" in $$props2)
      $$invalidate(9, helperText = $$props2.helperText);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        dispatch("input", value);
    }
  };
  return [
    ref,
    type,
    value,
    readonly,
    placeholder,
    width,
    error,
    embed,
    noPadding,
    helperText,
    autoFocus,
    input_handler,
    focus_handler,
    blur_handler,
    keydown_handler,
    keyup_handler,
    input_binding
  ];
}
var Input = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      type: 1,
      value: 2,
      ref: 0,
      readonly: 3,
      placeholder: 4,
      autoFocus: 10,
      width: 5,
      error: 6,
      embed: 7,
      noPadding: 8,
      helperText: 9
    }, add_css3);
  }
};
var Input_default = Input;

// node_modules/obsidian-svelte/Input/TextInput.svelte
function create_fragment7(ctx) {
  let input;
  let updating_ref;
  let updating_value;
  let current;
  function input_ref_binding(value) {
    ctx[11](value);
  }
  function input_value_binding(value) {
    ctx[12](value);
  }
  let input_props = {
    type: "text",
    readonly: ctx[2],
    noPadding: ctx[9],
    placeholder: ctx[3],
    autoFocus: ctx[4],
    width: ctx[5],
    embed: ctx[8],
    error: ctx[6],
    helperText: ctx[7]
  };
  if (ctx[1] !== void 0) {
    input_props.ref = ctx[1];
  }
  if (ctx[0] !== void 0) {
    input_props.value = ctx[0];
  }
  input = new Input_default({ props: input_props });
  binding_callbacks.push(() => bind(input, "ref", input_ref_binding));
  binding_callbacks.push(() => bind(input, "value", input_value_binding));
  input.$on("input", ctx[10]);
  input.$on("focus", ctx[13]);
  input.$on("blur", ctx[14]);
  input.$on("keydown", ctx[15]);
  input.$on("keyup", ctx[16]);
  return {
    c() {
      create_component(input.$$.fragment);
    },
    m(target, anchor) {
      mount_component(input, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const input_changes = {};
      if (dirty & 4)
        input_changes.readonly = ctx2[2];
      if (dirty & 512)
        input_changes.noPadding = ctx2[9];
      if (dirty & 8)
        input_changes.placeholder = ctx2[3];
      if (dirty & 16)
        input_changes.autoFocus = ctx2[4];
      if (dirty & 32)
        input_changes.width = ctx2[5];
      if (dirty & 256)
        input_changes.embed = ctx2[8];
      if (dirty & 64)
        input_changes.error = ctx2[6];
      if (dirty & 128)
        input_changes.helperText = ctx2[7];
      if (!updating_ref && dirty & 2) {
        updating_ref = true;
        input_changes.ref = ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_value && dirty & 1) {
        updating_value = true;
        input_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(input.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(input.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(input, detaching);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { readonly = false } = $$props;
  let { placeholder = "" } = $$props;
  let { autoFocus = false } = $$props;
  let { width = "auto" } = $$props;
  let { error = false } = $$props;
  let { helperText = "" } = $$props;
  let { embed = false } = $$props;
  let { noPadding = false } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  function handleInput(event) {
    if (event.currentTarget instanceof HTMLInputElement) {
      $$invalidate(0, value = event.currentTarget.value);
    }
  }
  function input_ref_binding(value2) {
    ref = value2;
    $$invalidate(1, ref);
  }
  function input_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("readonly" in $$props2)
      $$invalidate(2, readonly = $$props2.readonly);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("autoFocus" in $$props2)
      $$invalidate(4, autoFocus = $$props2.autoFocus);
    if ("width" in $$props2)
      $$invalidate(5, width = $$props2.width);
    if ("error" in $$props2)
      $$invalidate(6, error = $$props2.error);
    if ("helperText" in $$props2)
      $$invalidate(7, helperText = $$props2.helperText);
    if ("embed" in $$props2)
      $$invalidate(8, embed = $$props2.embed);
    if ("noPadding" in $$props2)
      $$invalidate(9, noPadding = $$props2.noPadding);
    if ("ref" in $$props2)
      $$invalidate(1, ref = $$props2.ref);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        dispatch("input", value);
    }
  };
  return [
    value,
    ref,
    readonly,
    placeholder,
    autoFocus,
    width,
    error,
    helperText,
    embed,
    noPadding,
    handleInput,
    input_ref_binding,
    input_value_binding,
    focus_handler,
    blur_handler,
    keydown_handler,
    keyup_handler
  ];
}
var TextInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, {
      value: 0,
      readonly: 2,
      placeholder: 3,
      autoFocus: 4,
      width: 5,
      error: 6,
      helperText: 7,
      embed: 8,
      noPadding: 9,
      ref: 1
    });
  }
};
var TextInput_default = TextInput;

// node_modules/obsidian-svelte/Autocomplete/Autocomplete.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i].label;
  child_ctx[24] = list[i].description;
  child_ctx[26] = i;
  return child_ctx;
}
function create_if_block3(ctx) {
  let suggestionitem;
  let current;
  suggestionitem = new SuggestionItem_default({
    props: { label: "", description: "No options" }
  });
  return {
    c() {
      create_component(suggestionitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(suggestionitem, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(suggestionitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(suggestionitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(suggestionitem, detaching);
    }
  };
}
function create_each_block(ctx) {
  let suggestionitem;
  let current;
  function click_handler() {
    return ctx[20](ctx[26]);
  }
  function select_handler(...args) {
    return ctx[21](ctx[26], ...args);
  }
  suggestionitem = new SuggestionItem_default({
    props: {
      label: ctx[23],
      description: ctx[24],
      selected: ctx[8] === ctx[26]
    }
  });
  suggestionitem.$on("click", click_handler);
  suggestionitem.$on("select", select_handler);
  return {
    c() {
      create_component(suggestionitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(suggestionitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const suggestionitem_changes = {};
      if (dirty & 1024)
        suggestionitem_changes.label = ctx[23];
      if (dirty & 1024)
        suggestionitem_changes.description = ctx[24];
      if (dirty & 256)
        suggestionitem_changes.selected = ctx[8] === ctx[26];
      suggestionitem.$set(suggestionitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(suggestionitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(suggestionitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(suggestionitem, detaching);
    }
  };
}
function create_default_slot3(ctx) {
  let t;
  let each_1_anchor;
  let current;
  let if_block = !ctx[10].length && create_if_block3(ctx);
  let each_value = ctx[10];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!ctx2[10].length) {
        if (if_block) {
          if (dirty & 1024) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & 3329) {
        each_value = ctx2[10];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment8(ctx) {
  let textinput;
  let updating_value;
  let updating_ref;
  let t;
  let suggestion;
  let current;
  function textinput_value_binding(value) {
    ctx[14](value);
  }
  function textinput_ref_binding(value) {
    ctx[15](value);
  }
  let textinput_props = {
    readonly: ctx[2],
    width: ctx[4],
    placeholder: ctx[3],
    autoFocus: ctx[6],
    embed: ctx[5]
  };
  if (ctx[0] !== void 0) {
    textinput_props.value = ctx[0];
  }
  if (ctx[9] !== void 0) {
    textinput_props.ref = ctx[9];
  }
  textinput = new TextInput_default({ props: textinput_props });
  binding_callbacks.push(() => bind(textinput, "value", textinput_value_binding));
  binding_callbacks.push(() => bind(textinput, "ref", textinput_ref_binding));
  textinput.$on("focus", ctx[16]);
  textinput.$on("blur", ctx[17]);
  textinput.$on("input", ctx[18]);
  textinput.$on("keydown", ctx[19]);
  suggestion = new Suggestion_default({
    props: {
      anchorEl: ctx[9],
      open: ctx[1],
      onClose: ctx[22],
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
      t = space();
      create_component(suggestion.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      insert(target, t, anchor);
      mount_component(suggestion, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const textinput_changes = {};
      if (dirty & 4)
        textinput_changes.readonly = ctx2[2];
      if (dirty & 16)
        textinput_changes.width = ctx2[4];
      if (dirty & 8)
        textinput_changes.placeholder = ctx2[3];
      if (dirty & 64)
        textinput_changes.autoFocus = ctx2[6];
      if (dirty & 32)
        textinput_changes.embed = ctx2[5];
      if (!updating_value && dirty & 1) {
        updating_value = true;
        textinput_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      if (!updating_ref && dirty & 512) {
        updating_ref = true;
        textinput_changes.ref = ctx2[9];
        add_flush_callback(() => updating_ref = false);
      }
      textinput.$set(textinput_changes);
      const suggestion_changes = {};
      if (dirty & 512)
        suggestion_changes.anchorEl = ctx2[9];
      if (dirty & 2)
        suggestion_changes.open = ctx2[1];
      if (dirty & 2)
        suggestion_changes.onClose = ctx2[22];
      if (dirty & 134219009) {
        suggestion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      suggestion.$set(suggestion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      transition_in(suggestion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      transition_out(suggestion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
      if (detaching)
        detach(t);
      destroy_component(suggestion, detaching);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let filteredOptions;
  let { value } = $$props;
  let { options } = $$props;
  let { maxItems = 50 } = $$props;
  let { open = false } = $$props;
  let { readonly = false } = $$props;
  let { placeholder = "" } = $$props;
  let { width = "auto" } = $$props;
  let { embed = false } = $$props;
  let { autoFocus = false } = $$props;
  let selected = -1;
  let inputRef;
  const dispatch = createEventDispatcher();
  let willClose = false;
  function textinput_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function textinput_ref_binding(value2) {
    inputRef = value2;
    $$invalidate(9, inputRef);
  }
  const focus_handler = () => $$invalidate(1, open = true);
  const blur_handler = (event) => {
    $$invalidate(1, open = false);
    dispatch("change", value);
    dispatch("blur", event);
  };
  const input_handler = () => $$invalidate(1, open = true);
  const keydown_handler = (event) => {
    var _a, _b;
    if (open) {
      switch (event.key) {
        case "ArrowUp":
          const prev = selected - 1;
          $$invalidate(8, selected = prev < 0 ? filteredOptions.length - 1 : prev);
          event.stopPropagation();
          break;
        case "ArrowDown":
          const next = selected + 1;
          $$invalidate(8, selected = next > filteredOptions.length - 1 ? 0 : next);
          event.stopPropagation();
          break;
        case "Enter":
          $$invalidate(0, value = (_b = (_a = filteredOptions[selected]) == null ? void 0 : _a.label) != null ? _b : value);
          $$invalidate(7, willClose = true);
          break;
      }
    }
  };
  const click_handler = (i) => {
    var _a, _b;
    $$invalidate(0, value = (_b = (_a = filteredOptions[i]) == null ? void 0 : _a.label) != null ? _b : value);
    dispatch("change", value);
  };
  const select_handler = (i, { detail }) => {
    if (detail) {
      $$invalidate(8, selected = i);
    }
  };
  const func3 = () => $$invalidate(1, open = false);
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("options" in $$props2)
      $$invalidate(12, options = $$props2.options);
    if ("maxItems" in $$props2)
      $$invalidate(13, maxItems = $$props2.maxItems);
    if ("open" in $$props2)
      $$invalidate(1, open = $$props2.open);
    if ("readonly" in $$props2)
      $$invalidate(2, readonly = $$props2.readonly);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("width" in $$props2)
      $$invalidate(4, width = $$props2.width);
    if ("embed" in $$props2)
      $$invalidate(5, embed = $$props2.embed);
    if ("autoFocus" in $$props2)
      $$invalidate(6, autoFocus = $$props2.autoFocus);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 12289) {
      $:
        $$invalidate(10, filteredOptions = options.filter((option) => !value || option.label.toLocaleLowerCase().contains(value.toLocaleLowerCase())).slice(0, Math.min(maxItems, options.length)));
    }
    if ($$self.$$.dirty & 128) {
      $:
        if (willClose) {
          $$invalidate(1, open = false);
          $$invalidate(7, willClose = false);
        }
    }
  };
  return [
    value,
    open,
    readonly,
    placeholder,
    width,
    embed,
    autoFocus,
    willClose,
    selected,
    inputRef,
    filteredOptions,
    dispatch,
    options,
    maxItems,
    textinput_value_binding,
    textinput_ref_binding,
    focus_handler,
    blur_handler,
    input_handler,
    keydown_handler,
    click_handler,
    select_handler,
    func3
  ];
}
var Autocomplete = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      value: 0,
      options: 12,
      maxItems: 13,
      open: 1,
      readonly: 2,
      placeholder: 3,
      width: 4,
      embed: 5,
      autoFocus: 6
    });
  }
};
var Autocomplete_default = Autocomplete;

// node_modules/obsidian-svelte/Autocomplete/FileAutocomplete.svelte
function create_fragment9(ctx) {
  let autocomplete;
  let updating_value;
  let updating_options;
  let current;
  function autocomplete_value_binding(value) {
    ctx[10](value);
  }
  function autocomplete_options_binding(value) {
    ctx[11](value);
  }
  let autocomplete_props = {
    readonly: ctx[2],
    placeholder: ctx[3],
    width: ctx[4],
    embed: ctx[1],
    autoFocus: ctx[5]
  };
  if (ctx[0] !== void 0) {
    autocomplete_props.value = ctx[0];
  }
  if (ctx[6] !== void 0) {
    autocomplete_props.options = ctx[6];
  }
  autocomplete = new Autocomplete_default({ props: autocomplete_props });
  binding_callbacks.push(() => bind(autocomplete, "value", autocomplete_value_binding));
  binding_callbacks.push(() => bind(autocomplete, "options", autocomplete_options_binding));
  autocomplete.$on("change", ctx[12]);
  autocomplete.$on("blur", ctx[13]);
  return {
    c() {
      create_component(autocomplete.$$.fragment);
    },
    m(target, anchor) {
      mount_component(autocomplete, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const autocomplete_changes = {};
      if (dirty & 4)
        autocomplete_changes.readonly = ctx2[2];
      if (dirty & 8)
        autocomplete_changes.placeholder = ctx2[3];
      if (dirty & 16)
        autocomplete_changes.width = ctx2[4];
      if (dirty & 2)
        autocomplete_changes.embed = ctx2[1];
      if (dirty & 32)
        autocomplete_changes.autoFocus = ctx2[5];
      if (!updating_value && dirty & 1) {
        updating_value = true;
        autocomplete_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      if (!updating_options && dirty & 64) {
        updating_options = true;
        autocomplete_changes.options = ctx2[6];
        add_flush_callback(() => updating_options = false);
      }
      autocomplete.$set(autocomplete_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(autocomplete.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(autocomplete.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(autocomplete, detaching);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let options;
  let { value } = $$props;
  let { files } = $$props;
  let { getLabel = (file) => file.name } = $$props;
  let { getDescription = () => "" } = $$props;
  let { embed = false } = $$props;
  let { readonly = false } = $$props;
  let { placeholder = "" } = $$props;
  let { width = "auto" } = $$props;
  let { autoFocus = false } = $$props;
  function autocomplete_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function autocomplete_options_binding(value2) {
    options = value2;
    $$invalidate(6, options), $$invalidate(7, files), $$invalidate(8, getLabel), $$invalidate(9, getDescription);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("files" in $$props2)
      $$invalidate(7, files = $$props2.files);
    if ("getLabel" in $$props2)
      $$invalidate(8, getLabel = $$props2.getLabel);
    if ("getDescription" in $$props2)
      $$invalidate(9, getDescription = $$props2.getDescription);
    if ("embed" in $$props2)
      $$invalidate(1, embed = $$props2.embed);
    if ("readonly" in $$props2)
      $$invalidate(2, readonly = $$props2.readonly);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("width" in $$props2)
      $$invalidate(4, width = $$props2.width);
    if ("autoFocus" in $$props2)
      $$invalidate(5, autoFocus = $$props2.autoFocus);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 896) {
      $:
        $$invalidate(6, options = files.map((file) => ({
          label: getLabel(file),
          description: getDescription(file)
        })));
    }
  };
  return [
    value,
    embed,
    readonly,
    placeholder,
    width,
    autoFocus,
    options,
    files,
    getLabel,
    getDescription,
    autocomplete_value_binding,
    autocomplete_options_binding,
    change_handler,
    blur_handler
  ];
}
var FileAutocomplete = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      value: 0,
      files: 7,
      getLabel: 8,
      getDescription: 9,
      embed: 1,
      readonly: 2,
      placeholder: 3,
      width: 4,
      autoFocus: 5
    });
  }
};
var FileAutocomplete_default = FileAutocomplete;

// node_modules/obsidian-svelte/Button/Button.svelte
function add_css4(target) {
  append_styles(target, "svelte-12xcpmj", "button.svelte-12xcpmj{gap:var(--size-4-1)}.mod-plain.svelte-12xcpmj{background:none;box-shadow:none;border:none;color:var(--text-muted)}.mod-plain.svelte-12xcpmj:hover{color:var(--text-normal)}.disabled.svelte-12xcpmj{opacity:0.6}");
}
function create_fragment10(ctx) {
  let button;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  return {
    c() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      attr(button, "aria-label", ctx[3]);
      button.disabled = ctx[2];
      attr(button, "class", "svelte-12xcpmj");
      toggle_class(button, "mod-cta", ctx[1] === "primary");
      toggle_class(button, "mod-warning", ctx[1] === "destructive");
      toggle_class(button, "mod-plain", ctx[1] === "plain");
      toggle_class(button, "disabled", ctx[2]);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      ctx[7](button);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[4], !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null), null);
        }
      }
      if (!current || dirty & 8) {
        attr(button, "aria-label", ctx2[3]);
      }
      if (!current || dirty & 4) {
        button.disabled = ctx2[2];
      }
      if (!current || dirty & 2) {
        toggle_class(button, "mod-cta", ctx2[1] === "primary");
      }
      if (!current || dirty & 2) {
        toggle_class(button, "mod-warning", ctx2[1] === "destructive");
      }
      if (!current || dirty & 2) {
        toggle_class(button, "mod-plain", ctx2[1] === "plain");
      }
      if (!current || dirty & 4) {
        toggle_class(button, "disabled", ctx2[2]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
      mounted = false;
      dispose();
    }
  };
}
function instance10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { variant = "default" } = $$props;
  let { disabled = false } = $$props;
  let { tooltip = "" } = $$props;
  let { ref = null } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("variant" in $$props2)
      $$invalidate(1, variant = $$props2.variant);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled = $$props2.disabled);
    if ("tooltip" in $$props2)
      $$invalidate(3, tooltip = $$props2.tooltip);
    if ("ref" in $$props2)
      $$invalidate(0, ref = $$props2.ref);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [ref, variant, disabled, tooltip, $$scope, slots, click_handler, button_binding];
}
var Button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance10, create_fragment10, safe_not_equal, {
      variant: 1,
      disabled: 2,
      tooltip: 3,
      ref: 0
    }, add_css4);
  }
};
var Button_default = Button;

// node_modules/obsidian-svelte/DateInput/DateInput.svelte
var import_dayjs = __toESM(require_dayjs_min(), 1);

// node_modules/obsidian-svelte/Select/SelectItem.svelte
function create_fragment11(ctx) {
  let option;
  let t_value = (ctx[0] || ctx[1]) + "";
  let t;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = ctx[1];
      option.value = option.__value;
      option.disabled = ctx[2];
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, [dirty]) {
      if (dirty & 3 && t_value !== (t_value = (ctx2[0] || ctx2[1]) + ""))
        set_data(t, t_value);
      if (dirty & 2) {
        option.__value = ctx2[1];
        option.value = option.__value;
      }
      if (dirty & 4) {
        option.disabled = ctx2[2];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function instance11($$self, $$props, $$invalidate) {
  let { text: text2 } = $$props;
  let { value } = $$props;
  let { disabled = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled = $$props2.disabled);
  };
  return [text2, value, disabled];
}
var SelectItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance11, create_fragment11, safe_not_equal, { text: 0, value: 1, disabled: 2 });
  }
};
var SelectItem_default = SelectItem;

// node_modules/obsidian-svelte/Select/Select.svelte
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function create_if_block_1(ctx) {
  let selectitem;
  let current;
  selectitem = new SelectItem_default({
    props: {
      text: ctx[2],
      value: "",
      disabled: true
    }
  });
  return {
    c() {
      create_component(selectitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectitem_changes = {};
      if (dirty & 4)
        selectitem_changes.text = ctx2[2];
      selectitem.$set(selectitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectitem, detaching);
    }
  };
}
function create_if_block4(ctx) {
  let selectitem;
  let current;
  selectitem = new SelectItem_default({
    props: { text: ctx[2], value: "" }
  });
  return {
    c() {
      create_component(selectitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectitem_changes = {};
      if (dirty & 4)
        selectitem_changes.text = ctx2[2];
      selectitem.$set(selectitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectitem, detaching);
    }
  };
}
function create_each_block2(ctx) {
  let selectitem;
  let current;
  selectitem = new SelectItem_default({
    props: {
      text: ctx[8].label,
      value: ctx[8].value
    }
  });
  return {
    c() {
      create_component(selectitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectitem_changes = {};
      if (dirty & 1)
        selectitem_changes.text = ctx2[8].label;
      if (dirty & 1)
        selectitem_changes.value = ctx2[8].value;
      selectitem.$set(selectitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectitem, detaching);
    }
  };
}
function create_fragment12(ctx) {
  let select;
  let if_block0_anchor;
  let if_block1_anchor;
  let select_disabled_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = !ctx[0].length && ctx[2] && create_if_block_1(ctx);
  let if_block1 = ctx[3] && create_if_block4(ctx);
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      select = element("select");
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(select, "aria-label", ctx[5]);
      select.disabled = select_disabled_value = ctx[4] || !ctx[0].length && !!ctx[2];
      attr(select, "class", "dropdown");
    },
    m(target, anchor) {
      insert(target, select, anchor);
      if (if_block0)
        if_block0.m(select, null);
      append(select, if_block0_anchor);
      if (if_block1)
        if_block1.m(select, null);
      append(select, if_block1_anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(select, null);
      }
      select_option(select, ctx[1]);
      current = true;
      if (!mounted) {
        dispose = listen(select, "change", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!ctx2[0].length && ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 5) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(select, if_block0_anchor);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[3]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block4(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(select, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (dirty & 1) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(select, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & 32) {
        attr(select, "aria-label", ctx2[5]);
      }
      if (!current || dirty & 21 && select_disabled_value !== (select_disabled_value = ctx2[4] || !ctx2[0].length && !!ctx2[2])) {
        select.disabled = select_disabled_value;
      }
      if (!current || dirty & 2) {
        select_option(select, ctx2[1]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(select);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance12($$self, $$props, $$invalidate) {
  let { options } = $$props;
  let { value } = $$props;
  let { placeholder = "" } = $$props;
  let { allowEmpty = false } = $$props;
  let { disabled = false } = $$props;
  let { tooltip = "" } = $$props;
  const dispatch = createEventDispatcher();
  function handleChange(event) {
    if (event.currentTarget instanceof HTMLSelectElement) {
      dispatch("change", event.currentTarget.value);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("options" in $$props2)
      $$invalidate(0, options = $$props2.options);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("placeholder" in $$props2)
      $$invalidate(2, placeholder = $$props2.placeholder);
    if ("allowEmpty" in $$props2)
      $$invalidate(3, allowEmpty = $$props2.allowEmpty);
    if ("disabled" in $$props2)
      $$invalidate(4, disabled = $$props2.disabled);
    if ("tooltip" in $$props2)
      $$invalidate(5, tooltip = $$props2.tooltip);
  };
  return [options, value, placeholder, allowEmpty, disabled, tooltip, handleChange];
}
var Select = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance12, create_fragment12, safe_not_equal, {
      options: 0,
      value: 1,
      placeholder: 2,
      allowEmpty: 3,
      disabled: 4,
      tooltip: 5
    });
  }
};
var Select_default = Select;

// node_modules/obsidian-svelte/Setting/SettingItem.svelte
function add_css5(target) {
  append_styles(target, "svelte-17mpvkc", ".vertical.svelte-17mpvkc{flex-direction:column;align-items:flex-start;gap:var(--size-4-1)}.vertical-control.svelte-17mpvkc{flex-direction:column;align-items:flex-start;gap:var(--size-4-1);width:100%}");
}
function create_fragment13(ctx) {
  var _a, _b;
  let div4;
  let div2;
  let div0;
  let t0_value = ((_a = ctx[0]) != null ? _a : "") + "";
  let t0;
  let t1;
  let div1;
  let t2_value = ((_b = ctx[1]) != null ? _b : "") + "";
  let t2;
  let t3;
  let div3;
  let current;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      div3 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "setting-item-name");
      attr(div1, "class", "setting-item-description");
      attr(div2, "class", "setting-item-info");
      attr(div3, "class", "setting-item-control svelte-17mpvkc");
      toggle_class(div3, "vertical-control", ctx[3]);
      attr(div4, "class", "setting-item svelte-17mpvkc");
      toggle_class(div4, "setting-item-heading", ctx[2]);
      toggle_class(div4, "vertical", ctx[3]);
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t2);
      append(div4, t3);
      append(div4, div3);
      if (default_slot) {
        default_slot.m(div3, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2, _b2;
      if ((!current || dirty & 1) && t0_value !== (t0_value = ((_a2 = ctx2[0]) != null ? _a2 : "") + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 2) && t2_value !== (t2_value = ((_b2 = ctx2[1]) != null ? _b2 : "") + ""))
        set_data(t2, t2_value);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[4], !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null), null);
        }
      }
      if (!current || dirty & 8) {
        toggle_class(div3, "vertical-control", ctx2[3]);
      }
      if (!current || dirty & 4) {
        toggle_class(div4, "setting-item-heading", ctx2[2]);
      }
      if (!current || dirty & 8) {
        toggle_class(div4, "vertical", ctx2[3]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance13($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name = void 0 } = $$props;
  let { description = void 0 } = $$props;
  let { heading = false } = $$props;
  let { vertical = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("description" in $$props2)
      $$invalidate(1, description = $$props2.description);
    if ("heading" in $$props2)
      $$invalidate(2, heading = $$props2.heading);
    if ("vertical" in $$props2)
      $$invalidate(3, vertical = $$props2.vertical);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [name, description, heading, vertical, $$scope, slots];
}
var SettingItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance13, create_fragment13, safe_not_equal, {
      name: 0,
      description: 1,
      heading: 2,
      vertical: 3
    }, add_css5);
  }
};
var SettingItem_default = SettingItem;

// node_modules/obsidian-svelte/TextArea/TextArea.svelte
function add_css6(target) {
  append_styles(target, "svelte-1yhxf9x", "textarea.svelte-1yhxf9x{font-family:var(--font-monospace-default)}");
}
function create_fragment14(ctx) {
  let textarea;
  let textarea_style_value;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      attr(textarea, "rows", ctx[1]);
      attr(textarea, "style", textarea_style_value = `width: ${ctx[2]}`);
      attr(textarea, "placeholder", ctx[3]);
      attr(textarea, "class", "svelte-1yhxf9x");
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      set_input_value(textarea, ctx[0]);
      if (!mounted) {
        dispose = listen(textarea, "input", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        attr(textarea, "rows", ctx2[1]);
      }
      if (dirty & 4 && textarea_style_value !== (textarea_style_value = `width: ${ctx2[2]}`)) {
        attr(textarea, "style", textarea_style_value);
      }
      if (dirty & 8) {
        attr(textarea, "placeholder", ctx2[3]);
      }
      if (dirty & 1) {
        set_input_value(textarea, ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(textarea);
      mounted = false;
      dispose();
    }
  };
}
function instance14($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { rows } = $$props;
  let { width = "auto" } = $$props;
  let { placeholder = "" } = $$props;
  const dispatch = createEventDispatcher();
  function textarea_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("rows" in $$props2)
      $$invalidate(1, rows = $$props2.rows);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        dispatch("input", value);
    }
  };
  return [value, rows, width, placeholder, textarea_input_handler];
}
var TextArea = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance14, create_fragment14, safe_not_equal, {
      value: 0,
      rows: 1,
      width: 2,
      placeholder: 3
    }, add_css6);
  }
};
var TextArea_default = TextArea;

// src/components/CompareTypeSelect.svelte
function create_fragment15(ctx) {
  let select;
  let current;
  select = new Select_default({
    props: {
      options: ctx[1],
      value: ctx[0],
      tooltip: "What to compare the inbox note contents to when deciding whether or not to notify. 'Compare to last tracked' will compare to a snapshot from when Obsidian was last closed. 'Compare to base' will compare to a base contents that you define."
    }
  });
  select.$on("change", ctx[2]);
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const select_changes = {};
      if (dirty & 1)
        select_changes.value = ctx2[0];
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function instance15($$self, $$props, $$invalidate) {
  let { value } = $$props;
  const options = [
    {
      label: "Compare to last tracked",
      value: "compareToLastTracked"
    },
    {
      label: "Compare to base",
      value: "compareToBase"
    }
  ];
  const dispatch = createEventDispatcher();
  function handleChange({ detail }) {
    if (detail === "compareToBase" || detail === "compareToLastTracked") {
      dispatch("change", detail);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  return [value, options, handleChange];
}
var CompareTypeSelect = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance15, create_fragment15, safe_not_equal, { value: 0 });
  }
};
var CompareTypeSelect_default = CompareTypeSelect;

// src/components/FileOrFolderSelect.svelte
function create_fragment16(ctx) {
  let select;
  let current;
  select = new Select_default({
    props: {
      options: ctx[1],
      value: ctx[0],
      tooltip: "If tracking note, will notify when a note's content is updated. If tracking folder, will notify when new files are added to a folder."
    }
  });
  select.$on("change", ctx[2]);
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const select_changes = {};
      if (dirty & 1)
        select_changes.value = ctx2[0];
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function instance16($$self, $$props, $$invalidate) {
  let { value } = $$props;
  const options = [{ label: "Note", value: "note" }, { label: "Folder", value: "folder" }];
  const dispatch = createEventDispatcher();
  function handleChange({ detail }) {
    if (detail === "note" || detail === "folder") {
      dispatch("change", detail);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  return [value, options, handleChange];
}
var FileOrFolderSelect = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance16, create_fragment16, safe_not_equal, { value: 0 });
  }
};
var FileOrFolderSelect_default = FileOrFolderSelect;

// src/inbox-helpers.ts
var import_obsidian6 = require("obsidian");
function setTrackingType(trackingType, index) {
  const settings = get_store_value(store_default);
  const matchingInbox = settings.inboxes.at(index);
  if (!matchingInbox) {
    new ErrorNotice(`Failed to find inbox at index ${index}.`);
    return;
  }
  matchingInbox.trackingType = trackingType;
  matchingInbox.path = "";
  store_default.set(settings);
}
async function setInboxNote({
  app,
  notePath,
  index
}) {
  const matchingFile = app.vault.getMarkdownFiles().find((file) => file.path === notePath);
  if (!matchingFile || !(matchingFile instanceof import_obsidian6.TFile)) {
    new ErrorNotice(`Failed to set inbox note, ${notePath} could not be found or is not a note.`);
    return;
  }
  const settings = get_store_value(store_default);
  const matchingInbox = settings.inboxes.at(index);
  if (!matchingInbox) {
    new ErrorNotice(`Failed to find inbox at index ${index}.`);
    return;
  }
  matchingInbox.path = notePath;
  const contents = await readFile(app, matchingFile);
  matchingInbox.inboxNoteContents = contents;
  store_default.set(settings);
}
async function setInboxFolder({
  app,
  folderPath,
  index
}) {
  const folder = getFolders(app.vault).find((folder2) => folder2.path === folderPath);
  if (!folder) {
    new ErrorNotice(`Failed to set inbox folder, ${folderPath} could not be found.`);
    return;
  }
  const settings = get_store_value(store_default);
  const matchingInbox = settings.inboxes.at(index);
  if (!matchingInbox) {
    new ErrorNotice(`Failed to find inbox at index ${index}.`);
    return;
  }
  matchingInbox.path = folder.path;
  const filesInFolder = getAllFilesInFolderRecursive(folder);
  filesInFolder.sort((a, b) => a.localeCompare(b));
  matchingInbox.inboxFolderFiles.sort((a, b) => a.localeCompare(b));
  matchingInbox.inboxFolderFiles = filesInFolder;
  store_default.set(settings);
}

// src/settings-tab/InboxSettings.svelte
function add_css7(target) {
  append_styles(target, "svelte-1lft1wy", ".inbox-setting-item-control.svelte-1lft1wy{justify-content:start;flex-wrap:wrap}");
}
function create_if_block_2(ctx) {
  let fileautocomplete;
  let t0;
  let comparetypeselect;
  let t1;
  let if_block_anchor;
  let current;
  fileautocomplete = new FileAutocomplete_default({
    props: {
      placeholder: "Inbox.md",
      value: ctx[0].path,
      files: ctx[3],
      getLabel: func
    }
  });
  fileautocomplete.$on("change", ctx[11]);
  comparetypeselect = new CompareTypeSelect_default({
    props: { value: ctx[0].compareType }
  });
  comparetypeselect.$on("change", ctx[12]);
  let if_block = ctx[0].compareType === "compareToBase" && create_if_block_3(ctx);
  return {
    c() {
      create_component(fileautocomplete.$$.fragment);
      t0 = space();
      create_component(comparetypeselect.$$.fragment);
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(fileautocomplete, target, anchor);
      insert(target, t0, anchor);
      mount_component(comparetypeselect, target, anchor);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const fileautocomplete_changes = {};
      if (dirty & 1)
        fileautocomplete_changes.value = ctx2[0].path;
      if (dirty & 8)
        fileautocomplete_changes.files = ctx2[3];
      fileautocomplete.$set(fileautocomplete_changes);
      const comparetypeselect_changes = {};
      if (dirty & 1)
        comparetypeselect_changes.value = ctx2[0].compareType;
      comparetypeselect.$set(comparetypeselect_changes);
      if (ctx2[0].compareType === "compareToBase") {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(fileautocomplete.$$.fragment, local);
      transition_in(comparetypeselect.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(fileautocomplete.$$.fragment, local);
      transition_out(comparetypeselect.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(fileautocomplete, detaching);
      if (detaching)
        detach(t0);
      destroy_component(comparetypeselect, detaching);
      if (detaching)
        detach(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_3(ctx) {
  let textarea;
  let current;
  textarea = new TextArea_default({
    props: {
      placeholder: "# Inbox",
      value: ctx[0].inboxNoteBaseContents,
      rows: 1
    }
  });
  textarea.$on("input", ctx[13]);
  return {
    c() {
      create_component(textarea.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textarea, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textarea_changes = {};
      if (dirty & 1)
        textarea_changes.value = ctx2[0].inboxNoteBaseContents;
      textarea.$set(textarea_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textarea.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textarea.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textarea, detaching);
    }
  };
}
function create_if_block_12(ctx) {
  let fileautocomplete;
  let current;
  fileautocomplete = new FileAutocomplete_default({
    props: {
      placeholder: "Inbox",
      value: ctx[0].path,
      files: ctx[4],
      getLabel: func_1
    }
  });
  fileautocomplete.$on("change", ctx[14]);
  return {
    c() {
      create_component(fileautocomplete.$$.fragment);
    },
    m(target, anchor) {
      mount_component(fileautocomplete, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const fileautocomplete_changes = {};
      if (dirty & 1)
        fileautocomplete_changes.value = ctx2[0].path;
      if (dirty & 16)
        fileautocomplete_changes.files = ctx2[4];
      fileautocomplete.$set(fileautocomplete_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fileautocomplete.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fileautocomplete.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fileautocomplete, detaching);
    }
  };
}
function create_default_slot_2(ctx) {
  let icon;
  let current;
  icon = new Icon_default({ props: { name: "chevron-up" } });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_default_slot_1(ctx) {
  let icon;
  let current;
  icon = new Icon_default({ props: { name: "chevron-down" } });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_if_block5(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    }
  });
  button.$on("click", ctx[9]);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 65536) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot4(ctx) {
  let icon;
  let current;
  icon = new Icon_default({ props: { name: "cross" } });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_fragment17(ctx) {
  let div1;
  let div0;
  let fileorfolderselect;
  let t0;
  let t1;
  let t2;
  let input;
  let t3;
  let button0;
  let t4;
  let button1;
  let t5;
  let current;
  let mounted;
  let dispose;
  fileorfolderselect = new FileOrFolderSelect_default({
    props: { value: ctx[0].trackingType }
  });
  fileorfolderselect.$on("change", ctx[10]);
  let if_block0 = ctx[0].trackingType === "note" && create_if_block_2(ctx);
  let if_block1 = ctx[0].trackingType === "folder" && create_if_block_12(ctx);
  button0 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  button0.$on("click", ctx[7]);
  button1 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  button1.$on("click", ctx[8]);
  let if_block2 = ctx[1] !== ctx[6] && create_if_block5(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(fileorfolderselect.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      input = element("input");
      t3 = space();
      create_component(button0.$$.fragment);
      t4 = space();
      create_component(button1.$$.fragment);
      t5 = space();
      if (if_block2)
        if_block2.c();
      attr(input, "type", "number");
      attr(input, "placeholder", "0");
      attr(input, "aria-label", "Duration to show Notice when there is data to process, in seconds. Set to 0 for infinite duration. Clear to use global default Notice duration.");
      set_style(input, "width", "40px");
      attr(div0, "class", "setting-item-control inbox-setting-item-control svelte-1lft1wy");
      attr(div1, "class", "setting-item");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(fileorfolderselect, div0, null);
      append(div0, t0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t1);
      if (if_block1)
        if_block1.m(div0, null);
      append(div0, t2);
      append(div0, input);
      set_input_value(input, ctx[5].inboxes[ctx[1]].noticeDurationSeconds);
      append(div0, t3);
      mount_component(button0, div0, null);
      append(div0, t4);
      mount_component(button1, div0, null);
      append(div0, t5);
      if (if_block2)
        if_block2.m(div0, null);
      current = true;
      if (!mounted) {
        dispose = listen(input, "input", ctx[15]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const fileorfolderselect_changes = {};
      if (dirty & 1)
        fileorfolderselect_changes.value = ctx2[0].trackingType;
      fileorfolderselect.$set(fileorfolderselect_changes);
      if (ctx2[0].trackingType === "note") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[0].trackingType === "folder") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_12(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (dirty & 34 && to_number(input.value) !== ctx2[5].inboxes[ctx2[1]].noticeDurationSeconds) {
        set_input_value(input, ctx2[5].inboxes[ctx2[1]].noticeDurationSeconds);
      }
      const button0_changes = {};
      if (dirty & 65536) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & 65536) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      if (ctx2[1] !== ctx2[6]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 66) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block5(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(fileorfolderselect.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(fileorfolderselect.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(fileorfolderselect);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_component(button0);
      destroy_component(button1);
      if (if_block2)
        if_block2.d();
      mounted = false;
      dispose();
    }
  };
}
var func = (file) => file.path;
var func_1 = (file) => file.path;
function instance17($$self, $$props, $$invalidate) {
  let $store;
  let $lastInboxIndex;
  component_subscribe($$self, store_default, ($$value) => $$invalidate(5, $store = $$value));
  component_subscribe($$self, lastInboxIndex, ($$value) => $$invalidate(6, $lastInboxIndex = $$value));
  let { inbox } = $$props;
  let { index } = $$props;
  let { app } = $$props;
  let { markdownFiles } = $$props;
  let { folders } = $$props;
  function moveInboxUp() {
    store_default.moveInboxUp(index);
  }
  function moveInboxDown() {
    store_default.moveInboxDown(index);
  }
  function removeInbox() {
    store_default.removeInbox(index);
  }
  const change_handler = async ({ detail }) => {
    if (detail !== inbox.trackingType) {
      setTrackingType(detail, index);
    }
  };
  const change_handler_1 = async ({ detail }) => {
    if (detail !== inbox.path) {
      await setInboxNote({ app, notePath: detail, index });
    }
  };
  const change_handler_2 = ({ detail }) => {
    set_store_value(store_default, $store.inboxes[index].compareType = detail, $store);
  };
  const input_handler = ({ detail }) => {
    set_store_value(store_default, $store.inboxes[index].inboxNoteBaseContents = detail, $store);
  };
  const change_handler_3 = async ({ detail }) => {
    if (detail !== inbox.path) {
      await setInboxFolder({ app, folderPath: detail, index });
    }
  };
  function input_input_handler() {
    $store.inboxes[index].noticeDurationSeconds = to_number(this.value);
    store_default.set($store);
  }
  $$self.$$set = ($$props2) => {
    if ("inbox" in $$props2)
      $$invalidate(0, inbox = $$props2.inbox);
    if ("index" in $$props2)
      $$invalidate(1, index = $$props2.index);
    if ("app" in $$props2)
      $$invalidate(2, app = $$props2.app);
    if ("markdownFiles" in $$props2)
      $$invalidate(3, markdownFiles = $$props2.markdownFiles);
    if ("folders" in $$props2)
      $$invalidate(4, folders = $$props2.folders);
  };
  return [
    inbox,
    index,
    app,
    markdownFiles,
    folders,
    $store,
    $lastInboxIndex,
    moveInboxUp,
    moveInboxDown,
    removeInbox,
    change_handler,
    change_handler_1,
    change_handler_2,
    input_handler,
    change_handler_3,
    input_input_handler
  ];
}
var InboxSettings = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance17, create_fragment17, safe_not_equal, {
      inbox: 0,
      index: 1,
      app: 2,
      markdownFiles: 3,
      folders: 4
    }, add_css7);
  }
};
var InboxSettings_default = InboxSettings;

// src/settings-tab/SettingsTab.svelte
function add_css8(target) {
  append_styles(target, "svelte-1o4pnzj", ".inbox-setting-heading-with-button.svelte-1o4pnzj{display:flex;justify-content:space-between;align-items:center}");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  child_ctx[9] = i;
  return child_ctx;
}
function create_default_slot_22(ctx) {
  let t;
  return {
    c() {
      t = text("Start");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_12(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "primary",
      $$slots: { default: [create_default_slot_22] },
      $$scope: { ctx }
    }
  });
  button.$on("click", ctx[4]);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 1024) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot5(ctx) {
  let icon;
  let current;
  icon = new Icon_default({ props: { name: "plus" } });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_each_block3(ctx) {
  let inboxsettings;
  let current;
  inboxsettings = new InboxSettings_default({
    props: {
      inbox: ctx[7],
      index: ctx[9],
      app: ctx[0],
      markdownFiles: ctx[1],
      folders: ctx[2]
    }
  });
  return {
    c() {
      create_component(inboxsettings.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inboxsettings, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inboxsettings_changes = {};
      if (dirty & 8)
        inboxsettings_changes.inbox = ctx2[7];
      if (dirty & 1)
        inboxsettings_changes.app = ctx2[0];
      if (dirty & 2)
        inboxsettings_changes.markdownFiles = ctx2[1];
      if (dirty & 4)
        inboxsettings_changes.folders = ctx2[2];
      inboxsettings.$set(inboxsettings_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inboxsettings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inboxsettings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inboxsettings, detaching);
    }
  };
}
function create_fragment18(ctx) {
  let h20;
  let t1;
  let settingitem;
  let t2;
  let div0;
  let h21;
  let t4;
  let button;
  let t5;
  let div1;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: "Start walkthrough",
      description: "This will open a pane in the sidebar to guide you through how to use this plugin.",
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    }
  });
  button = new Button_default({
    props: {
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    }
  });
  button.$on("click", ctx[5]);
  let each_value = ctx[3].inboxes;
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      h20 = element("h2");
      h20.textContent = "Walkthrough";
      t1 = space();
      create_component(settingitem.$$.fragment);
      t2 = space();
      div0 = element("div");
      h21 = element("h2");
      h21.textContent = "Inboxes";
      t4 = space();
      create_component(button.$$.fragment);
      t5 = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "inbox-setting-heading-with-button svelte-1o4pnzj");
    },
    m(target, anchor) {
      insert(target, h20, anchor);
      insert(target, t1, anchor);
      mount_component(settingitem, target, anchor);
      insert(target, t2, anchor);
      insert(target, div0, anchor);
      append(div0, h21);
      append(div0, t4);
      mount_component(button, div0, null);
      insert(target, t5, anchor);
      insert(target, div1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      const settingitem_changes = {};
      if (dirty & 1024) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
      const button_changes = {};
      if (dirty & 1024) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
      if (dirty & 15) {
        each_value = ctx2[3].inboxes;
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div1, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      transition_in(button.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      transition_out(button.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h20);
      if (detaching)
        detach(t1);
      destroy_component(settingitem, detaching);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div0);
      destroy_component(button);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(div1);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance18($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store_default, ($$value) => $$invalidate(3, $store = $$value));
  let { activateWalkthroughView } = $$props;
  let { app } = $$props;
  let { markdownFiles } = $$props;
  let { folders } = $$props;
  function startWalkthrough() {
    return __awaiter(this, void 0, void 0, function* () {
      store_default.walkthrough.start();
      activateWalkthroughView();
    });
  }
  function addInbox() {
    store_default.addInbox();
  }
  $$self.$$set = ($$props2) => {
    if ("activateWalkthroughView" in $$props2)
      $$invalidate(6, activateWalkthroughView = $$props2.activateWalkthroughView);
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("markdownFiles" in $$props2)
      $$invalidate(1, markdownFiles = $$props2.markdownFiles);
    if ("folders" in $$props2)
      $$invalidate(2, folders = $$props2.folders);
  };
  return [
    app,
    markdownFiles,
    folders,
    $store,
    startWalkthrough,
    addInbox,
    activateWalkthroughView
  ];
}
var SettingsTab = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance18, create_fragment18, safe_not_equal, {
      activateWalkthroughView: 6,
      app: 0,
      markdownFiles: 1,
      folders: 2
    }, add_css8);
  }
};
var SettingsTab_default = SettingsTab;

// src/settings-tab/SettingsTab.ts
var SettingsTab2 = class extends import_obsidian7.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.component = new SettingsTab_default({
      target: containerEl,
      props: {
        activateWalkthroughView: () => {
          this.plugin.ensureWalkthroughViewExists(true);
          this.app.setting.close();
        },
        app: this.app,
        markdownFiles: this.app.vault.getMarkdownFiles(),
        folders: getFolders(this.app.vault)
      }
    });
  }
};

// src/walkthrough/WalkthroughView.ts
var import_obsidian8 = require("obsidian");

// src/walkthrough/WalkthroughView.svelte
function add_css9(target) {
  append_styles(target, "svelte-17115i5", ".flex.svelte-17115i5{display:flex}.mt-1.svelte-17115i5{margin-block-start:1em}.ml-auto.svelte-17115i5{margin-left:auto}");
}
function create_if_block_122(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "Looks like you haven't setup Obsidian Inbox yet! Let's get started!";
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_if_block_11(ctx) {
  let p0;
  let t1;
  let p1;
  return {
    c() {
      p0 = element("p");
      p0.textContent = "You've completed the walkthrough!";
      t1 = space();
      p1 = element("p");
      p1.textContent = "Feel free to close the walkthrough, or go back if you missed something!\n		You can always re-open this walkthrough in the plugin settings.";
    },
    m(target, anchor) {
      insert(target, p0, anchor);
      insert(target, t1, anchor);
      insert(target, p1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(p1);
    }
  };
}
function create_if_block_7(ctx) {
  let p0;
  let t1;
  let t2;
  let p1;
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[4].trackingType === "note" /* note */ && ctx2[4].compareType === "compareToBase")
      return create_if_block_8;
    if (ctx2[4].trackingType === "note" /* note */ && ctx2[4].compareType === "compareToLastTracked")
      return create_if_block_9;
    if (ctx2[4].trackingType === "folder" /* folder */)
      return create_if_block_10;
  }
  let current_block_type = select_block_type_2(ctx, -1);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      p0 = element("p");
      p0.textContent = "Alright, let's verify that this is working.";
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      p1 = element("p");
      p1.textContent = 'Click the "Next" button below to continue.';
    },
    m(target, anchor) {
      insert(target, p0, anchor);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t2, anchor);
      insert(target, p1, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_2(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(t2.parentNode, t2);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p0);
      if (detaching)
        detach(t1);
      if (if_block) {
        if_block.d(detaching);
      }
      if (detaching)
        detach(t2);
      if (detaching)
        detach(p1);
    }
  };
}
function create_if_block_4(ctx) {
  let p;
  let t0;
  let t1_value = ctx[4].trackingType.toString() + "";
  let t1;
  let t2;
  let t3_value = ctx[4].trackingType.toString() + "";
  let t3;
  let t4;
  let t5;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_5, create_if_block_6];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[4].trackingType === "note" /* note */)
      return 0;
    if (ctx2[4].trackingType === "folder" /* folder */)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      p = element("p");
      t0 = text("Let's setup which ");
      t1 = text(t1_value);
      t2 = text(" will be your inbox\n		");
      t3 = text(t3_value);
      t4 = text(".");
      t5 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t0);
      append(p, t1);
      append(p, t2);
      append(p, t3);
      append(p, t4);
      insert(target, t5, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 16) && t1_value !== (t1_value = ctx2[4].trackingType.toString() + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & 16) && t3_value !== (t3_value = ctx2[4].trackingType.toString() + ""))
        set_data(t3, t3_value);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(p);
      if (detaching)
        detach(t5);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_32(ctx) {
  let p0;
  let t1;
  let comparetypeselect;
  let t2;
  let p1;
  let t4;
  let p2;
  let current;
  comparetypeselect = new CompareTypeSelect_default({
    props: { value: ctx[4].compareType }
  });
  comparetypeselect.$on("change", ctx[9]);
  return {
    c() {
      p0 = element("p");
      p0.textContent = "What would you like to compare your inbox note's contents to when\n		deciding whether or not to show a notification on startup?";
      t1 = space();
      create_component(comparetypeselect.$$.fragment);
      t2 = space();
      p1 = element("p");
      p1.textContent = "'Compare to last tracked' will compare to a snapshot from when Obsidian\n		was last closed. This is the default, and is most commonly used when you\n		want to know if a note was changes externally outside of Obsidian.";
      t4 = space();
      p2 = element("p");
      p2.textContent = "'Compare to base' will compare to a base contents that you define. This\n		is used for when you want to know if there's anything in your inbox\n		note, even if there haven't been any changes to your note since your\n		last startup.";
    },
    m(target, anchor) {
      insert(target, p0, anchor);
      insert(target, t1, anchor);
      mount_component(comparetypeselect, target, anchor);
      insert(target, t2, anchor);
      insert(target, p1, anchor);
      insert(target, t4, anchor);
      insert(target, p2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const comparetypeselect_changes = {};
      if (dirty & 16)
        comparetypeselect_changes.value = ctx2[4].compareType;
      comparetypeselect.$set(comparetypeselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(comparetypeselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(comparetypeselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(p0);
      if (detaching)
        detach(t1);
      destroy_component(comparetypeselect, detaching);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(p1);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(p2);
    }
  };
}
function create_if_block_22(ctx) {
  let p;
  let t1;
  let fileorfolderselect;
  let current;
  fileorfolderselect = new FileOrFolderSelect_default({
    props: {
      value: ctx[4].trackingType
    }
  });
  fileorfolderselect.$on("change", ctx[8]);
  return {
    c() {
      p = element("p");
      p.textContent = "Would you like to be notified when changes are made to a note, or when\n		new files are added to a folder?";
      t1 = space();
      create_component(fileorfolderselect.$$.fragment);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      insert(target, t1, anchor);
      mount_component(fileorfolderselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const fileorfolderselect_changes = {};
      if (dirty & 16)
        fileorfolderselect_changes.value = ctx2[4].trackingType;
      fileorfolderselect.$set(fileorfolderselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fileorfolderselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fileorfolderselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(p);
      if (detaching)
        detach(t1);
      destroy_component(fileorfolderselect, detaching);
    }
  };
}
function create_if_block_10(ctx) {
  let ol;
  let li0;
  let t3;
  let li1;
  let t4;
  let t5_value = ctx[4].path + "";
  let t5;
  let t6;
  let t7;
  let li2;
  return {
    c() {
      ol = element("ol");
      li0 = element("li");
      li0.innerHTML = `Restart Obsidian. You should <i>not</i> get a notification, since
				your Inbox folder hasn&#39;t been updated externally.`;
      t3 = space();
      li1 = element("li");
      t4 = text('Close Obsidian, and add or remove a note to your Inbox folder\n				(located at "');
      t5 = text(t5_value);
      t6 = text('").');
      t7 = space();
      li2 = element("li");
      li2.innerHTML = `Open Obsidian. You <i>should</i> get a notification, because your
				&quot;Inbox&quot; folder was changed outside of Obsidian.`;
    },
    m(target, anchor) {
      insert(target, ol, anchor);
      append(ol, li0);
      append(ol, t3);
      append(ol, li1);
      append(li1, t4);
      append(li1, t5);
      append(li1, t6);
      append(ol, t7);
      append(ol, li2);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t5_value !== (t5_value = ctx2[4].path + ""))
        set_data(t5, t5_value);
    },
    d(detaching) {
      if (detaching)
        detach(ol);
    }
  };
}
function create_if_block_9(ctx) {
  let ol;
  let li0;
  let t3;
  let li1;
  let t4;
  let t5_value = ctx[4].path + "";
  let t5;
  let t6;
  let t7;
  let li2;
  return {
    c() {
      ol = element("ol");
      li0 = element("li");
      li0.innerHTML = `Restart Obsidian. You should <i>not</i> get a notification, since
				your Inbox note hasn&#39;t been updated externally.`;
      t3 = space();
      li1 = element("li");
      t4 = text('Close Obsidian, and add or remove some content to your Inbox\n				note (located at "');
      t5 = text(t5_value);
      t6 = text('").');
      t7 = space();
      li2 = element("li");
      li2.innerHTML = `Open Obsidian. You <i>should</i> get a notification, because your
				&quot;Inbox&quot; note was changed outside of Obsidian.`;
    },
    m(target, anchor) {
      insert(target, ol, anchor);
      append(ol, li0);
      append(ol, t3);
      append(ol, li1);
      append(li1, t4);
      append(li1, t5);
      append(li1, t6);
      append(ol, t7);
      append(ol, li2);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t5_value !== (t5_value = ctx2[4].path + ""))
        set_data(t5, t5_value);
    },
    d(detaching) {
      if (detaching)
        detach(ol);
    }
  };
}
function create_if_block_8(ctx) {
  let ol;
  return {
    c() {
      ol = element("ol");
      ol.innerHTML = `<li>Restart Obsidian. You should <i>not</i> get a notification, since
				you haven&#39;t added anything to your &quot;Inbox&quot; note aside from anything
				added before you ran the &quot;Set inbox note&quot; command.</li> 
			<li>Add anything to your &quot;Inbox&quot; note.</li> 
			<li>Restart Obsidian. You <i>should</i> get a notification, because your
				&quot;Inbox&quot; note no longer matches what you set it to when you ran the
				&quot;Set inbox note&quot; command.</li>`;
    },
    m(target, anchor) {
      insert(target, ol, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(ol);
    }
  };
}
function create_if_block_6(ctx) {
  let p;
  let t1;
  let fileautocomplete;
  let current;
  fileautocomplete = new FileAutocomplete_default({
    props: {
      placeholder: "Inbox",
      value: ctx[4].path,
      files: ctx[2],
      getLabel: func_12
    }
  });
  fileautocomplete.$on("change", ctx[11]);
  return {
    c() {
      p = element("p");
      p.textContent = "Select the folder that you want to be notifified of when files are\n			added/removed to this folder outside of Obsidian.";
      t1 = space();
      create_component(fileautocomplete.$$.fragment);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      insert(target, t1, anchor);
      mount_component(fileautocomplete, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const fileautocomplete_changes = {};
      if (dirty & 16)
        fileautocomplete_changes.value = ctx2[4].path;
      if (dirty & 4)
        fileautocomplete_changes.files = ctx2[2];
      fileautocomplete.$set(fileautocomplete_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fileautocomplete.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fileautocomplete.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(p);
      if (detaching)
        detach(t1);
      destroy_component(fileautocomplete, detaching);
    }
  };
}
function create_if_block_5(ctx) {
  let p;
  let t1;
  let fileautocomplete;
  let current;
  fileautocomplete = new FileAutocomplete_default({
    props: {
      placeholder: "Inbox.md",
      value: ctx[4].path,
      files: ctx[1],
      getLabel: func2
    }
  });
  fileautocomplete.$on("change", ctx[10]);
  return {
    c() {
      p = element("p");
      p.textContent = "Select the note that you want to be notified of when it's contents\n			are changed.";
      t1 = space();
      create_component(fileautocomplete.$$.fragment);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      insert(target, t1, anchor);
      mount_component(fileautocomplete, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const fileautocomplete_changes = {};
      if (dirty & 16)
        fileautocomplete_changes.value = ctx2[4].path;
      if (dirty & 2)
        fileautocomplete_changes.files = ctx2[1];
      fileautocomplete.$set(fileautocomplete_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fileautocomplete.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fileautocomplete.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(p);
      if (detaching)
        detach(t1);
      destroy_component(fileautocomplete, detaching);
    }
  };
}
function create_if_block_13(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "Back";
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", store_default.walkthrough.previous);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_else_block(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "Close";
      attr(button, "class", "flex ml-auto svelte-17115i5");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[6]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block6(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "Next";
      attr(button, "class", "flex ml-auto svelte-17115i5");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", store_default.walkthrough.next);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment19(ctx) {
  let h1;
  let t1;
  let show_if_2 = ctx[3].walkthroughStatus === Object.values(WalkthroughStatuses)[1];
  let t2;
  let current_block_type_index;
  let if_block1;
  let t3;
  let div;
  let show_if_1 = ctx[3].walkthroughStatus !== Object.values(WalkthroughStatuses)[1];
  let t4;
  let show_if;
  let current;
  let if_block0 = show_if_2 && create_if_block_122(ctx);
  const if_block_creators = [
    create_if_block_22,
    create_if_block_32,
    create_if_block_4,
    create_if_block_7,
    create_if_block_11
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3].walkthroughStatus === "setCompareFileOrFolder" /* setCompareFileOrFolder */)
      return 0;
    if (ctx2[3].walkthroughStatus === "setCompareType" /* setCompareType */)
      return 1;
    if (ctx2[3].walkthroughStatus === "setInboxPath" /* setInboxPath */)
      return 2;
    if (ctx2[3].walkthroughStatus === "restartObsidian" /* restartObsidian */)
      return 3;
    if (ctx2[3].walkthroughStatus === "completed" /* completed */)
      return 4;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block2 = show_if_1 && create_if_block_13(ctx);
  function select_block_type_3(ctx2, dirty) {
    if (dirty & 8)
      show_if = null;
    if (show_if == null)
      show_if = !!(ctx2[3].walkthroughStatus !== Object.values(WalkthroughStatuses)[Object.values(WalkthroughStatuses).length - 1]);
    if (show_if)
      return create_if_block6;
    return create_else_block;
  }
  let current_block_type = select_block_type_3(ctx, -1);
  let if_block3 = current_block_type(ctx);
  return {
    c() {
      h1 = element("h1");
      h1.textContent = "Obsidian Inbox Walkthrough";
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      div = element("div");
      if (if_block2)
        if_block2.c();
      t4 = space();
      if_block3.c();
      attr(div, "class", "flex mt-1 svelte-17115i5");
    },
    m(target, anchor) {
      insert(target, h1, anchor);
      insert(target, t1, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t2, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, t3, anchor);
      insert(target, div, anchor);
      if (if_block2)
        if_block2.m(div, null);
      append(div, t4);
      if_block3.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 8)
        show_if_2 = ctx2[3].walkthroughStatus === Object.values(WalkthroughStatuses)[1];
      if (show_if_2) {
        if (if_block0) {
        } else {
          if_block0 = create_if_block_122(ctx2);
          if_block0.c();
          if_block0.m(t2.parentNode, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(t3.parentNode, t3);
        } else {
          if_block1 = null;
        }
      }
      if (dirty & 8)
        show_if_1 = ctx2[3].walkthroughStatus !== Object.values(WalkthroughStatuses)[1];
      if (show_if_1) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_13(ctx2);
          if_block2.c();
          if_block2.m(div, t4);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (current_block_type === (current_block_type = select_block_type_3(ctx2, dirty)) && if_block3) {
        if_block3.p(ctx2, dirty);
      } else {
        if_block3.d(1);
        if_block3 = current_block_type(ctx2);
        if (if_block3) {
          if_block3.c();
          if_block3.m(div, null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h1);
      if (detaching)
        detach(t1);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t2);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div);
      if (if_block2)
        if_block2.d();
      if_block3.d();
    }
  };
}
var func2 = (file) => file.path;
var func_12 = (file) => file.path;
function instance19($$self, $$props, $$invalidate) {
  let $store;
  let $lastInbox;
  let $lastInboxIndex;
  component_subscribe($$self, store_default, ($$value) => $$invalidate(3, $store = $$value));
  component_subscribe($$self, lastInbox, ($$value) => $$invalidate(4, $lastInbox = $$value));
  component_subscribe($$self, lastInboxIndex, ($$value) => $$invalidate(5, $lastInboxIndex = $$value));
  let { app } = $$props;
  let { closeWalkthroughView } = $$props;
  let { markdownFiles } = $$props;
  let { folders } = $$props;
  function handleCloseWalkthrough() {
    closeWalkthroughView();
    store_default.walkthrough.complete();
  }
  const change_handler = async ({ detail }) => {
    if (detail !== $lastInbox.trackingType) {
      setTrackingType(detail, $lastInboxIndex);
    }
  };
  const change_handler_1 = ({ detail }) => {
    set_store_value(lastInbox, $lastInbox.compareType = detail, $lastInbox);
  };
  const change_handler_2 = async ({ detail }) => {
    if (detail !== $lastInbox.path) {
      await setInboxNote({
        app,
        notePath: detail,
        index: $lastInboxIndex
      });
    }
  };
  const change_handler_3 = async ({ detail }) => {
    if (detail !== $lastInbox.path) {
      await setInboxFolder({
        app,
        folderPath: detail,
        index: $lastInboxIndex
      });
    }
  };
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("closeWalkthroughView" in $$props2)
      $$invalidate(7, closeWalkthroughView = $$props2.closeWalkthroughView);
    if ("markdownFiles" in $$props2)
      $$invalidate(1, markdownFiles = $$props2.markdownFiles);
    if ("folders" in $$props2)
      $$invalidate(2, folders = $$props2.folders);
  };
  return [
    app,
    markdownFiles,
    folders,
    $store,
    $lastInbox,
    $lastInboxIndex,
    handleCloseWalkthrough,
    closeWalkthroughView,
    change_handler,
    change_handler_1,
    change_handler_2,
    change_handler_3
  ];
}
var WalkthroughView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance19, create_fragment19, safe_not_equal, {
      app: 0,
      closeWalkthroughView: 7,
      markdownFiles: 1,
      folders: 2
    }, add_css9);
  }
};
var WalkthroughView_default = WalkthroughView;

// src/walkthrough/WalkthroughView.ts
var VIEW_TYPE_WALKTHROUGH = "inbox-walkthrough-view";
var InboxWalkthroughView = class extends import_obsidian8.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_WALKTHROUGH;
  }
  getDisplayText() {
    return "Inbox Walkthrough";
  }
  getIcon() {
    return "info";
  }
  async onOpen() {
    this.component = new WalkthroughView_default({
      target: this.contentEl,
      props: {
        app: this.app,
        closeWalkthroughView: () => this.closeWalkthroughView(),
        markdownFiles: this.app.vault.getMarkdownFiles(),
        folders: getFolders(this.app.vault)
      }
    });
  }
  async onClose() {
    this.component.$destroy();
  }
  closeWalkthroughView() {
    this.plugin.app.workspace.detachLeavesOfType(VIEW_TYPE_WALKTHROUGH);
  }
};

// src/register-events.ts
function registerEvents(plugin) {
  plugin.registerEvent(plugin.app.metadataCache.on("changed", async (file, data, cache) => {
    const settings = get_store_value(store_default);
    if (plugin.hasPerformedCheck) {
      const matchingInboxes = settings.inboxes.filter((inbox) => inbox.trackingType === "note" /* note */ && inbox.path === file.path);
      if (matchingInboxes.length > 0) {
        for (const inbox of matchingInboxes) {
          inbox.inboxNoteContents = data.trim();
        }
        store_default.set(settings);
      }
    }
  }));
  plugin.registerEvent(plugin.app.vault.on("create", async (file) => {
    const settings = get_store_value(store_default);
    if (plugin.hasPerformedCheck) {
      const matchingInboxes = settings.inboxes.filter((inbox) => inbox.trackingType === "folder" /* folder */ && file.path.startsWith(inbox.path));
      if (matchingInboxes.length > 0) {
        for (const inbox of matchingInboxes) {
          inbox.inboxFolderFiles.push(file.name);
          inbox.inboxFolderFiles.sort((a, b) => a.localeCompare(b));
        }
        store_default.set(settings);
      }
    }
  }));
  plugin.registerEvent(plugin.app.vault.on("rename", async (file, oldPath) => {
    const settings = get_store_value(store_default);
    if (plugin.hasPerformedCheck) {
      const oldName = oldPath.split("/").at(-1);
      const matchingInboxes = settings.inboxes.filter((inbox) => inbox.trackingType === "folder" /* folder */ && inbox.inboxFolderFiles.includes(file.name));
      if (matchingInboxes.length > 0) {
        for (const inbox of matchingInboxes) {
          inbox.inboxFolderFiles = [
            ...inbox.inboxFolderFiles.filter((x) => x !== oldName),
            file.name
          ];
          inbox.inboxFolderFiles.sort((a, b) => a.localeCompare(b));
        }
        store_default.set(settings);
      }
    }
  }));
  plugin.registerEvent(plugin.app.vault.on("delete", async (file) => {
    const settings = get_store_value(store_default);
    if (plugin.hasPerformedCheck) {
      const matchingInboxes = settings.inboxes.filter((inbox) => inbox.trackingType === "folder" /* folder */ && file.path.startsWith(inbox.path));
      if (matchingInboxes.length > 0) {
        for (const inbox of matchingInboxes) {
          inbox.inboxFolderFiles = inbox.inboxFolderFiles.filter((x) => x !== file.name);
          inbox.inboxFolderFiles.sort((a, b) => a.localeCompare(b));
        }
        store_default.set(settings);
      }
    }
  }));
}

// src/main.ts
var InboxPlugin = class extends import_obsidian9.Plugin {
  async onload() {
    this.hasPerformedCheck = false;
    await this.loadSettings();
    this.register(store_default.subscribe(async (settings) => {
      await this.saveData(settings);
    }));
    this.registerView(VIEW_TYPE_WALKTHROUGH, (leaf) => new InboxWalkthroughView(leaf, this));
    registerEvents(this);
    this.addSettingTab(new SettingsTab2(this.app, this));
    this.app.workspace.onLayoutReady(async () => {
      const settings = get_store_value(store_default);
      if (settings.walkthroughStatus === "unstarted" /* unstarted */) {
        store_default.walkthrough.start();
        this.ensureWalkthroughViewExists();
      } else {
        await this.notifyIfInboxNeedsProcessing();
      }
    });
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_WALKTHROUGH);
    this.hasPerformedCheck = false;
  }
  async loadSettings() {
    let settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    settings = migrateSettings(settings);
    if (isInboxPluginSettingsV2(settings)) {
      store_default.set(settings);
    } else {
      new ErrorNotice(`Failed to load settings.
Settings could not be migrated to match schema.
${settings}`);
    }
  }
  ensureWalkthroughViewExists(active = false) {
    const { workspace } = this.app;
    let leaf;
    const existingPluginLeaves = workspace.getLeavesOfType(VIEW_TYPE_WALKTHROUGH);
    if (existingPluginLeaves.length > 0) {
      leaf = existingPluginLeaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        workspace.revealLeaf(leaf);
        leaf.setViewState({ type: VIEW_TYPE_WALKTHROUGH });
      }
    }
    if (active && leaf) {
      workspace.setActiveLeaf(leaf);
    }
  }
  getIsWalkthroughViewOpen() {
    return this.app.workspace.getLeavesOfType(VIEW_TYPE_WALKTHROUGH).length > 0;
  }
  async notifyIfInboxNeedsProcessing() {
    const settings = get_store_value(store_default);
    try {
      if (settings.inboxes.length > 0) {
        const updatedInboxes = await Promise.all(settings.inboxes.map(async (inbox, index) => {
          var _a;
          if (!inbox.path) {
            return inbox;
          }
          const inboxAbstractFile = this.app.vault.getAbstractFileByPath(inbox.path);
          if (!inboxAbstractFile) {
            new ErrorNotice(`Failed to find inbox ${inbox.trackingType.toString()} at path ${inbox.path}.`);
            return inbox;
          }
          let shouldNotify = false;
          if (inboxAbstractFile instanceof import_obsidian9.TFile) {
            const contents = (await this.app.vault.read(inboxAbstractFile)).trim();
            switch (inbox.compareType) {
              case "compareToBase":
                shouldNotify = contents !== inbox.inboxNoteBaseContents.trim();
                break;
              case "compareToLastTracked":
                shouldNotify = contents !== inbox.inboxNoteContents.trim();
                break;
              default:
                break;
            }
            inbox.inboxNoteContents = contents;
          } else if (inboxAbstractFile instanceof import_obsidian9.TFolder) {
            const filesInFolder = getAllFilesInFolderRecursive(inboxAbstractFile);
            filesInFolder.sort((a, b) => a.localeCompare(b));
            inbox.inboxFolderFiles.sort((a, b) => a.localeCompare(b));
            shouldNotify = filesInFolder.join("") !== inbox.inboxFolderFiles.join("");
            inbox.inboxFolderFiles = filesInFolder;
          }
          if (shouldNotify) {
            const enableClickToView = import_obsidian9.Platform.isDesktop && inboxAbstractFile instanceof import_obsidian9.TFile;
            const baseMessage = `You have data to process in ${inbox.path}`;
            const message = enableClickToView ? `${baseMessage}
Click to dismiss, or right click to view inbox note.` : `${baseMessage}
Click to dismiss.`;
            const notice = new InfoNotice(message, (_a = inbox.noticeDurationSeconds) != null ? _a : void 0);
            if (enableClickToView) {
              notice.noticeEl.oncontextmenu = () => {
                this.ensureLeafAtPathIsActive(inbox.path);
                notice.hide();
              };
            }
          }
          return inbox;
        }));
        settings.inboxes = updatedInboxes;
        store_default.set(settings);
      }
    } catch (error) {
      new ErrorNotice(`Failed to process inboxes.
${error}`);
    }
    this.hasPerformedCheck = true;
  }
  ensureLeafAtPathIsActive(path) {
    const leavesMatchingPath = findMarkdownLeavesMatchingPath(this.app.workspace, path);
    if (leavesMatchingPath.some(Boolean)) {
      this.app.workspace.setActiveLeaf(leavesMatchingPath[0], {
        focus: true
      });
      return;
    }
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file instanceof import_obsidian9.TFile) {
      const leaf = this.app.workspace.getLeaf(true);
      leaf.openFile(file);
      return;
    }
    new ErrorNotice(`Failed to find note at path ${path}.`);
  }
};
