/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AliasManagementPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/settings.ts
var import_obsidian2 = require("obsidian");

// src/const.ts
var PluginIdentifier = "alias-management";
var ListAliasesViewIdentifier = `${PluginIdentifier}_list-aliases-view`;
var ListAliasesViewName = "ListAliasesView";
var ListAliasesViewIcon = "bullet-list";
var ListAliasesViewCommandDesc = "Open list aliases view";
var DuplicateAliasesViewIdentifier = `${PluginIdentifier}_duplicate-aliases-view`;
var DuplicateAliasesViewName = "DuplicateAliasesView";
var DuplicateAliasesViewIcon = "languages";
var DuplicateAliasesViewCommandDesc = "Open duplicate aliases view";

// src/funcs.ts
var import_obsidian = require("obsidian");
function find_list_aliases_view() {
  return document.querySelector(`.${ListAliasesViewIdentifier}`);
}
function find_duplicate_aliases_view() {
  return document.querySelector(`.${DuplicateAliasesViewIdentifier} .body`);
}
function get_physical_aliases_from_fpath(plugin, fpath, do_not_store, fpath_old) {
  var _a, _b;
  let cached_metadata = plugin.app.metadataCache.getCache(fpath);
  if (!cached_metadata && fpath_old) {
    cached_metadata = plugin.app.metadataCache.getCache(fpath_old);
  }
  if (!cached_metadata) {
    return [];
  }
  let physical_aliases = [];
  if (!cached_metadata.frontmatter) {
    cached_metadata["frontmatter"] = { "aliases": physical_aliases };
  } else if ((_a = cached_metadata.frontmatter) == null ? void 0 : _a.aliases) {
    physical_aliases = cached_metadata.frontmatter.aliases;
  } else if ((_b = cached_metadata.frontmatter) == null ? void 0 : _b.alias) {
    const alias = cached_metadata.frontmatter.alias;
    if (typeof alias === "string") {
      const aliases_splitted = alias.split(",");
      physical_aliases = aliases_splitted;
    } else {
      physical_aliases.push(alias);
    }
    delete cached_metadata.frontmatter["alias"];
  }
  physical_aliases = physical_aliases.filter((entry) => {
    if (typeof entry === "string") {
      return entry.trim() !== "";
    } else if (typeof entry === "number") {
      return true;
    }
    return false;
  }).map((entry) => {
    if (typeof entry === "string") {
      return entry.trim();
    } else {
      return entry.toString();
    }
  });
  if (cached_metadata.frontmatter) {
    cached_metadata.frontmatter["aliases"] = [...physical_aliases];
  }
  if (plugin.settings.add_filename_to_aliases) {
    let file = plugin.app.vault.getAbstractFileByPath(fpath);
    if (!(file instanceof import_obsidian.TFile) && fpath_old) {
      file = plugin.app.vault.getAbstractFileByPath(fpath_old);
    }
    if (file instanceof import_obsidian.TFile) {
      physical_aliases.unshift(file.basename);
    }
  }
  if (plugin.exclude_physical_aliases_regex.length > 0) {
    physical_aliases = physical_aliases.filter((physical_alias, index) => {
      const is_excluded = plugin.exclude_physical_aliases_regex.some((regex_pattern) => regex_pattern.test(physical_alias));
      if (is_excluded && plugin.settings.add_filename_to_aliases && index === 0) {
        plugin.fpath_filename_ignored.add(fpath);
      }
      return !is_excluded;
    });
    if (fpath_old) {
      plugin.fpath_filename_ignored.delete(fpath_old);
    }
  }
  if (do_not_store !== true) {
    plugin.fpath_to_physical_aliases.set(fpath, physical_aliases);
  }
  return physical_aliases;
}
function generate_aliases(plugin, physical_alias, add_to_dupes, fpath, type) {
  let generated_aliases = plugin.physical_alias_to_generated_aliases.get(physical_alias);
  if (!generated_aliases) {
    const physical_alias_preprocessed = plugin.settings.case_insensitive ? physical_alias.toLowerCase() : physical_alias;
    generated_aliases = /* @__PURE__ */ new Set([physical_alias_preprocessed]);
    const sort_fname = plugin.settings.add_filename_as_alphabetical_sorted_words && type === "fname";
    const sort_alias = plugin.settings.add_aliases_as_alphabetical_sorted_words && type === "alias";
    if (sort_fname || sort_alias) {
      generated_aliases.add(sort_words_in_string(physical_alias_preprocessed));
    }
    if (plugin.replace_regex) {
      for (const [regex, replacement] of plugin.replace_regex) {
        for (let generated_alias of generated_aliases) {
          generated_alias = generated_alias.replace(regex, replacement);
          if (!generated_alias) {
            continue;
          }
          generated_aliases.add(generated_alias);
        }
      }
      if (sort_fname || sort_alias) {
        for (let generated_alias of generated_aliases) {
          generated_aliases.add(sort_words_in_string(generated_alias));
        }
      }
    }
  }
  plugin.physical_alias_to_generated_aliases.set(physical_alias, generated_aliases);
  if (add_to_dupes && fpath && physical_alias && type) {
    add_generated_aliases_with_fpath_to_dupes(plugin, generated_aliases, fpath, physical_alias, type);
  }
  return generated_aliases;
}
function init_list_aliases_view(plugin, fpath_in, fpath_new) {
  var _a;
  const view = find_list_aliases_view();
  if (!view) {
    return;
  }
  empty_list_aliases_view();
  const fpath = fpath_new || fpath_in || ((_a = plugin.app.workspace.getActiveFile()) == null ? void 0 : _a.path);
  if (!fpath) {
    return;
  }
  if (!find_duplicate_aliases_view()) {
    plugin.fpath_filename_ignored.clear();
  }
  if (plugin.ignore_folders && plugin.ignore_folders.some((skip_folder) => fpath.startsWith(`${skip_folder}/`))) {
    return;
  }
  const do_not_store = true;
  let physical_aliases;
  if (fpath_in && fpath_new) {
    physical_aliases = get_physical_aliases_from_fpath(plugin, fpath_new, do_not_store, fpath_in);
  } else {
    physical_aliases = get_physical_aliases_from_fpath(plugin, fpath, do_not_store);
  }
  if (physical_aliases.length === 0) {
    return;
  }
  const div = view.createEl("div", { cls: JSON.stringify({ "fpath": fpath }) });
  const occurrences = /* @__PURE__ */ new Map();
  const add_to_dupes = false;
  for (let i = 0; i < physical_aliases.length; i++) {
    const physical_alias = physical_aliases[i];
    let type = "";
    if (i === 0 && plugin.settings.add_filename_to_aliases) {
      if (fpath_new && !plugin.fpath_filename_ignored.has(fpath_new)) {
        type = "fname";
      } else if (fpath && !plugin.fpath_filename_ignored.has(fpath)) {
        type = "fname";
      }
    }
    if (!type) {
      type = "alias";
    }
    const details = div.createEl("details", { cls: type });
    details.setAttribute("open", "");
    const summary = details.createEl("summary");
    const link_title = type === "fname" ? "from filename" : "from alias";
    const link = summary.createEl("a", { href: fpath, text: physical_alias, title: `${physical_alias} (${link_title})` });
    if (type === "fname") {
      link.addEventListener("click", () => open_file(plugin, fpath));
    } else {
      let occurrence = occurrences.get(physical_alias) || 0;
      occurrences.set(physical_alias, ++occurrence);
      link.addEventListener("click", () => select_physical_alias_in_file(plugin, fpath, physical_alias, occurrence));
    }
    const generated_aliases = generate_aliases(plugin, physical_alias, add_to_dupes, fpath, type);
    const ul = details.createEl("ul");
    for (const generated_alias of generated_aliases) {
      let li = createEl("li", { text: generated_alias });
      ul.appendChild(li);
    }
  }
}
function empty_list_aliases_view(fpath) {
  const view = find_list_aliases_view();
  if (!view) {
    return;
  }
  if (fpath && !aliases_listed_for_fpath(fpath)) {
    return;
  }
  view.empty();
}
function init_duplicate_aliases_view(plugin, view) {
  if (!view) {
    view = find_duplicate_aliases_view();
    if (!view) {
      return;
    }
  }
  view.empty();
  plugin.generated_alias_to_fpaths = /* @__PURE__ */ new Map();
  const add_to_dupes = true;
  const files = plugin.app.vault.getFiles();
  for (let i = 0; i < files.length; i++) {
    const fpath = files[i].path;
    if (plugin.ignore_folders && plugin.ignore_folders.some((skip_folder) => fpath.startsWith(`${skip_folder}/`))) {
      continue;
    }
    const physical_aliases = get_physical_aliases_from_fpath(plugin, fpath);
    add_physical_aliases(plugin, physical_aliases, fpath, add_to_dupes, view);
  }
  sort_duplicate_aliases_view(plugin, view);
}
function add_generated_alias_with_fpath_to_dupes(plugin, generated_alias, fpath, physical_alias, type) {
  if (!plugin.generated_alias_to_fpaths.has(generated_alias)) {
    plugin.generated_alias_to_fpaths.set(generated_alias, new Array());
  }
  plugin.generated_alias_to_fpaths.get(generated_alias).push([fpath, physical_alias, type]);
}
function add_generated_aliases_with_fpath_to_dupes(plugin, generated_aliases, fpath, physical_alias, type) {
  for (const generated_alias of generated_aliases) {
    add_generated_alias_with_fpath_to_dupes(plugin, generated_alias, fpath, physical_alias, type);
  }
}
function active_leaf_changed(plugin, leaf) {
  const list_aliases_view = plugin.app.workspace.getLeavesOfType(ListAliasesViewIdentifier);
  if (list_aliases_view.length === 1) {
    const active_file = plugin.app.workspace.getActiveFile();
    if (!active_file) {
      empty_list_aliases_view();
      return;
    }
    if (aliases_listed_for_fpath(active_file.path)) {
      return;
    }
    init_list_aliases_view(plugin, active_file.path);
  }
}
function file_changed(plugin, file, md_content, cache) {
  const fpath = file.path;
  file_changed_duplicate_aliases(plugin, fpath);
  file_changed_list_aliases(plugin, fpath);
}
function file_changed_list_aliases(plugin, fpath) {
  const leaves = plugin.app.workspace.getLeavesOfType(ListAliasesViewIdentifier);
  if (leaves.length === 1 && aliases_listed_for_fpath(fpath)) {
    init_list_aliases_view(plugin, fpath);
  }
}
function file_changed_duplicate_aliases(plugin, fpath) {
  const leaves = plugin.app.workspace.getLeavesOfType(DuplicateAliasesViewIdentifier);
  if (leaves.length !== 1) {
    return;
  }
  const view = find_duplicate_aliases_view();
  if (!view) {
    return;
  }
  let physical_aliases_old = plugin.fpath_to_physical_aliases.get(fpath);
  const file_moved_outside_obsidian = physical_aliases_old === void 0;
  if (physical_aliases_old === void 0) {
    physical_aliases_old = [];
  }
  const physical_aliases_new = get_physical_aliases_from_fpath(plugin, fpath);
  const aliases = compare_lists(physical_aliases_old, physical_aliases_new);
  if (aliases.removed.length === 0 && aliases.added.length === 0) {
    return;
  }
  if (aliases.removed.length > 0) {
    const type = "alias";
    remove_physical_aliases(plugin, aliases.removed, fpath, view, type);
  }
  if (aliases.added.length > 0) {
    const add_to_dupes = true;
    if (!file_moved_outside_obsidian) {
      const type = aliases.added.length === 1 && physical_aliases_old.length === 0 && !plugin.fpath_filename_ignored.has(fpath) ? "fname" : "alias";
      add_physical_aliases(plugin, aliases.added, fpath, add_to_dupes, view, type);
    } else {
      add_physical_aliases(plugin, aliases.added, fpath, add_to_dupes, view);
    }
  }
  sort_duplicate_aliases_view(plugin, view);
  plugin.fpath_to_physical_aliases.set(fpath, physical_aliases_new);
}
function file_renamed(plugin, file_new, fpath_old) {
  file_renamed_duplicate_aliases(plugin, file_new, fpath_old);
  file_renamed_list_aliases(plugin, file_new.path, fpath_old);
}
function file_renamed_list_aliases(plugin, fpath_new, fpath_old) {
  const leaves = plugin.app.workspace.getLeavesOfType(ListAliasesViewIdentifier);
  if (leaves.length === 1 && (aliases_listed_for_fpath(fpath_old) || fpath_new && aliases_listed_for_fpath(fpath_new) || no_aliases_listed())) {
    init_list_aliases_view(plugin, fpath_old, fpath_new);
  }
}
function file_renamed_duplicate_aliases(plugin, file_new, fpath_old) {
  const leaves = plugin.app.workspace.getLeavesOfType(DuplicateAliasesViewIdentifier);
  if (leaves.length !== 1) {
    return;
  }
  const view = find_duplicate_aliases_view();
  if (!view) {
    return;
  }
  const add_to_dupes = true;
  if (!plugin.fpath_to_physical_aliases.has(fpath_old)) {
    const do_not_store = false;
    const physical_aliases2 = get_physical_aliases_from_fpath(plugin, file_new.path, do_not_store, fpath_old);
    add_physical_aliases(plugin, physical_aliases2, file_new.path, add_to_dupes, view);
    sort_duplicate_aliases_view(plugin, view);
    return;
  }
  let physical_aliases = plugin.fpath_to_physical_aliases.get(fpath_old);
  if (physical_aliases !== void 0) {
    remove_physical_aliases(plugin, physical_aliases, fpath_old, view);
  }
  if (plugin.ignore_folders && plugin.ignore_folders.some((skip_folder) => file_new.path.startsWith(`${skip_folder}/`))) {
    sort_duplicate_aliases_view(plugin, view);
    plugin.fpath_to_physical_aliases.delete(fpath_old);
    plugin.fpath_filename_ignored.delete(fpath_old);
    return;
  }
  if (physical_aliases && plugin.settings.add_filename_to_aliases) {
    const physical_alias_fname_new = file_new.basename;
    if (plugin.exclude_physical_aliases_regex.length > 0) {
      const should_exclude_filename = !plugin.exclude_physical_aliases_regex.every((regex_pattern) => !regex_pattern.test(physical_alias_fname_new));
      if (should_exclude_filename) {
        if (!plugin.fpath_filename_ignored.has(fpath_old)) {
          physical_aliases.shift();
        }
        plugin.fpath_filename_ignored.add(file_new.path);
      } else if (plugin.fpath_filename_ignored.has(fpath_old)) {
        physical_aliases.unshift(physical_alias_fname_new);
      } else {
        physical_aliases[0] = physical_alias_fname_new;
      }
    } else {
      physical_aliases[0] = physical_alias_fname_new;
    }
    plugin.fpath_filename_ignored.delete(fpath_old);
  }
  if (physical_aliases !== void 0) {
    add_physical_aliases(plugin, physical_aliases, file_new.path, add_to_dupes, view);
  }
  sort_duplicate_aliases_view(plugin, view);
  if (physical_aliases !== void 0) {
    plugin.fpath_to_physical_aliases.set(file_new.path, physical_aliases);
  }
  plugin.fpath_to_physical_aliases.delete(fpath_old);
}
function file_deleted(plugin, file, prevCache) {
  file_deleted_duplicate_aliases(plugin, file);
  plugin.fpath_filename_ignored.delete(file.path);
  file_deleted_list_aliases(plugin, file.path);
}
function file_deleted_list_aliases(plugin, fpath, fpath_new) {
  const leaves = plugin.app.workspace.getLeavesOfType(ListAliasesViewIdentifier);
  if (leaves.length === 1 && aliases_listed_for_fpath(fpath)) {
    empty_list_aliases_view();
  }
}
function file_deleted_duplicate_aliases(plugin, file) {
  const leaves = plugin.app.workspace.getLeavesOfType(DuplicateAliasesViewIdentifier);
  if (leaves.length !== 1) {
    return;
  }
  const view = find_duplicate_aliases_view();
  if (!view) {
    return;
  }
  const fpath = file.path;
  if (!plugin.fpath_to_physical_aliases.has(fpath)) {
    return;
  }
  const physical_aliases = plugin.fpath_to_physical_aliases.get(fpath);
  if (physical_aliases !== void 0) {
    remove_physical_aliases(plugin, physical_aliases, fpath, view);
  }
  sort_duplicate_aliases_view(plugin, view);
  plugin.fpath_to_physical_aliases.delete(fpath);
}
function sort_duplicate_aliases_view(plugin, view) {
  if (!view || !view.parentElement) {
    return;
  }
  const selector = `details:has(> ul:empty), details:has(ul > li:first-child:last-child)`;
  let details_elements_to_remove = view.querySelectorAll(selector);
  for (let i = 0; i < details_elements_to_remove.length; i++) {
    details_elements_to_remove[i].remove();
  }
  const details_elements = view.querySelectorAll("details");
  const header = view.parentElement.querySelector(".header");
  if ((!details_elements || details_elements.length === 0) && header) {
    header.empty();
    return;
  }
  const details_arr = Array.from(details_elements);
  details_arr.sort((a, b) => {
    const li_a_list = a.querySelectorAll("li");
    const li_b_list = b.querySelectorAll("li");
    const order_list = plugin.settings.sort_desc ? li_a_list.length - li_b_list.length : li_b_list.length - li_a_list.length;
    const summary_a = a.querySelector("summary");
    const summary_b = b.querySelector("summary");
    if (order_list === 0 && (summary_a == null ? void 0 : summary_a.textContent) && (summary_b == null ? void 0 : summary_b.textContent)) {
      const summary_a_text = summary_a.textContent.trim();
      const summary_b_text = summary_b.textContent.trim();
      return plugin.settings.sort_desc ? summary_b_text.localeCompare(summary_a_text) : summary_a_text.localeCompare(summary_b_text);
    }
    return order_list;
  }).forEach((details) => view.insertBefore(details, view.firstChild));
  details_arr.forEach((details) => {
    const li_arr = Array.from(details.querySelectorAll("li"));
    const ul = details.querySelector("ul");
    li_arr.sort((a, b) => a.classList[0] === "fname" && !(b.classList[0] === "fname") ? 1 : !(a.classList[0] === "fname") && b.classList[0] === "fname" ? -1 : 0).forEach((li) => ul.insertBefore(li, ul.firstChild));
    li_arr.sort((a, b) => a.classList[0] === "fname" ? 0 : -1).forEach((li) => ul.insertBefore(li, ul.firstChild));
  });
  const li_elements = view.querySelectorAll("li");
  const ul_elements = view.querySelectorAll("ul");
  const ul_elements_unique = /* @__PURE__ */ new Map();
  ul_elements.forEach((ul) => {
    const li_elements2 = ul.querySelectorAll("li");
    const classnames_array = [];
    li_elements2.forEach((li) => {
      classnames_array.push(li.className);
    });
    classnames_array.sort();
    const class_str = classnames_array.join(" ");
    ul_elements_unique.set(class_str, ul);
  });
  if (header) {
    header.empty();
    const header_text = `${li_elements.length} links in ${ul_elements.length} list${ul_elements.length !== 1 ? "s" : ""}`;
    const header_main = header.createEl("div", { text: header_text, title: `${header_text}${ul_elements.length > 1 ? ` (${ul_elements_unique.size} unique list${ul_elements_unique.size > 1 ? "s" : ""})` : ""}` });
  }
}
function remove_physical_alias(plugin, physical_alias, fpath, view, type) {
  const generated_aliases = plugin.physical_alias_to_generated_aliases.get(physical_alias);
  if (!generated_aliases) {
    return;
  }
  for (const generated_alias of generated_aliases) {
    const selector_details = CSS.escape(JSON.stringify({ "generated_alias": generated_alias }));
    const ul_element = view.querySelector(`details[class="${selector_details}"] ul`);
    if (ul_element) {
      const selector_li = type + " " + CSS.escape(JSON.stringify({ "physical_alias": physical_alias, "href": fpath }));
      const li_elements = ul_element.querySelectorAll(`li[class="${selector_li}"]`);
      if (li_elements.length > 0) {
        li_elements[0].remove();
        for (let i = 1; i < li_elements.length; i++) {
          li_elements[i].remove();
          add_li_to_ul(plugin, ul_element, physical_alias, fpath, type, i);
        }
      }
    }
    if (!plugin.generated_alias_to_fpaths.has(generated_alias)) {
      continue;
    }
    const arr = plugin.generated_alias_to_fpaths.get(generated_alias);
    if (arr === void 0) {
      continue;
    }
    const index_to_remove = arr.findIndex((sub_array) => sub_array[0] === fpath && sub_array[1] === physical_alias && sub_array[2] === type);
    if (index_to_remove === -1) {
      return;
    }
    arr.splice(index_to_remove, 1);
    if (arr.length === 0) {
      plugin.generated_alias_to_fpaths.delete(generated_alias);
    }
  }
}
function remove_physical_aliases(plugin, physical_aliases, fpath, view, type) {
  for (let i = 0; i < physical_aliases.length; i++) {
    const physical_alias = physical_aliases[i];
    const type_final = type ? type : plugin.settings.add_filename_to_aliases && i === 0 && !plugin.fpath_filename_ignored.has(fpath) ? "fname" : "alias";
    remove_physical_alias(plugin, physical_alias, fpath, view, type_final);
  }
}
function add_physical_alias(plugin, physical_alias, fpath, add_to_dupes, view, type) {
  const generated_aliases = generate_aliases(
    plugin,
    physical_alias,
    add_to_dupes,
    fpath,
    type
  );
  for (const generated_alias of generated_aliases) {
    const selector = CSS.escape(JSON.stringify({ "generated_alias": generated_alias }));
    const ul_elements = view.querySelectorAll(`details[class="${selector}"] ul`);
    if (ul_elements.length > 0) {
      for (let j = 0; j < ul_elements.length; j++) {
        const ul2 = ul_elements[j];
        add_li_to_ul(plugin, ul2, physical_alias, fpath, type);
      }
      continue;
    }
    if (!plugin.generated_alias_to_fpaths.has(generated_alias)) {
      continue;
    }
    const generated_alias_in_fpaths = plugin.generated_alias_to_fpaths.get(generated_alias);
    if (!generated_alias_in_fpaths || generated_alias_in_fpaths.length < 2) {
      continue;
    }
    const details = view.createEl("details", { cls: JSON.stringify({ "generated_alias": generated_alias }) });
    details.setAttribute("open", "");
    details.createEl("summary", { text: generated_alias, title: generated_alias });
    const ul = details.createEl("ul");
    for (let j = 0; j < generated_alias_in_fpaths.length; j++) {
      const fpath2 = generated_alias_in_fpaths[j][0];
      const physical_alias2 = generated_alias_in_fpaths[j][1];
      const type2 = generated_alias_in_fpaths[j][2];
      add_li_to_ul(plugin, ul, physical_alias2, fpath2, type2);
    }
  }
}
function add_physical_aliases(plugin, physical_aliases, fpath, add_to_dupes, view, type) {
  for (let i = 0; i < physical_aliases.length; i++) {
    const physical_alias = physical_aliases[i];
    const type_final = type ? type : plugin.settings.add_filename_to_aliases && i === 0 && !plugin.fpath_filename_ignored.has(fpath) ? "fname" : "alias";
    add_physical_alias(plugin, physical_alias, fpath, add_to_dupes, view, type_final);
  }
}
function add_li_to_ul(plugin, ul, physical_alias, fpath, type, occurrence) {
  const selector = JSON.stringify({ "physical_alias": physical_alias, "href": fpath });
  const li = createEl("li", { cls: `${type} ${selector}` });
  const link_title = type === "fname" ? "from filename" : "from alias";
  const link = li.createEl("a", { text: physical_alias, href: fpath, title: `${fpath} (${link_title})` });
  if (type === "fname") {
    link.addEventListener("click", (event) => {
      open_file(plugin, fpath);
    });
  } else {
    let occurrence_final;
    if (occurrence) {
      occurrence_final = occurrence;
    } else {
      const li_elements_already_added = ul.querySelectorAll(`li[class="${type} ${CSS.escape(selector)}"`);
      occurrence_final = li_elements_already_added.length + 1;
    }
    link.addEventListener("click", (event) => {
      select_physical_alias_in_file(plugin, fpath, physical_alias, occurrence_final);
    });
  }
  ul.appendChild(li);
}
async function select_physical_alias_in_file(plugin, fpath, physical_alias, occurrence) {
  const file_opened = await open_file(plugin, fpath);
  if (!file_opened) {
    return;
  }
  const selector = `div.metadata-property[data-property-key="aliases"] div.multi-select-pill-content`;
  const aliases_in_reading_view = document.querySelectorAll(selector);
  for (let i = 0; i < aliases_in_reading_view.length; i++) {
    if (aliases_in_reading_view[i].textContent !== physical_alias) {
      continue;
    }
    aliases_in_reading_view[i].classList.add("alias-management_highlight");
    setTimeout(() => {
      aliases_in_reading_view[i].classList.remove("alias-management_highlight");
    }, 2e3);
  }
  const cached_file = plugin.app.metadataCache.getCache(fpath);
  if (!cached_file || !cached_file.frontmatterPosition || !cached_file.frontmatterPosition["start"]) {
    return;
  }
  const fm_start_offset = cached_file.frontmatterPosition["start"]["offset"];
  const fm_end_offset = cached_file.frontmatterPosition["end"]["offset"];
  const file = plugin.app.vault.getAbstractFileByPath(fpath);
  if (!(file instanceof import_obsidian.TFile)) {
    return;
  }
  const file_content = await get_file_content(plugin, file);
  const frontmatter = file_content.slice(fm_start_offset, fm_end_offset);
  const physical_alias_escaped_regex = escape_regex(physical_alias);
  let re_pattern = `" *${physical_alias_escaped_regex} *"`;
  let re = new RegExp(re_pattern);
  let alias_index_start = regex_index_of(frontmatter, re, occurrence);
  if (alias_index_start === -1) {
    re_pattern = `\\b${physical_alias_escaped_regex}\\b`;
    re = new RegExp(re_pattern);
    alias_index_start = regex_index_of(frontmatter, re, occurrence);
  }
  let selection_len = physical_alias.length;
  const must_be_escaped = physical_alias.indexOf('"') !== -1 || physical_alias.indexOf("\\") !== -1;
  if (alias_index_start === -1 && must_be_escaped) {
    let occurrences_escape_char = 0;
    let physical_alias_escaped = physical_alias;
    if (physical_alias.indexOf("\\") !== -1) {
      physical_alias_escaped = physical_alias_escaped.replace(/\\/g, "\\\\");
      occurrences_escape_char += physical_alias.split("\\").length - 1;
    }
    if (physical_alias.indexOf('"') !== -1) {
      physical_alias_escaped = physical_alias_escaped.replace(/"/g, '\\"');
      occurrences_escape_char += physical_alias.split('"').length - 1;
    }
    re_pattern = `" *${escape_regex(physical_alias_escaped)} *"`;
    re = new RegExp(re_pattern);
    alias_index_start = regex_index_of(frontmatter, re, occurrence);
    if (alias_index_start !== -1) {
      selection_len += occurrences_escape_char;
    }
  }
  if (alias_index_start === -1) {
    re_pattern = `${physical_alias_escaped_regex}`;
    re = new RegExp(re_pattern);
    alias_index_start = regex_index_of(frontmatter, re, occurrence);
  }
  const line_no = frontmatter.slice(0, alias_index_start).split(/\r\n|\r|\n/).length - 1;
  let chars_before_line = 0;
  const chars_per_linebreak = frontmatter.includes("\r\n") ? 2 : 1;
  for (const i of Array(line_no).keys()) {
    chars_before_line += frontmatter.split(/\r\n|\r|\n/)[i].length + chars_per_linebreak;
  }
  const line = frontmatter.split(/\r\n|\r|\n/)[line_no];
  const column_from = alias_index_start - chars_before_line;
  const leaf = plugin.app.workspace.getLeaf();
  adjust_selection(line, line_no, column_from, selection_len, chars_per_linebreak, fm_start_offset, leaf);
}
function adjust_selection(line, line_no, column_from, selection_len, chars_per_linebreak, fm_start_offset, leaf) {
  if (column_from > 0) {
    if (is_simple_markdown_list_entry(line)) {
      const from2 = { line: line_no, ch: 0 };
      const to2 = { line: line_no, ch: line.length + chars_per_linebreak };
      leaf.view.editor.setSelection(from2, to2);
      return;
    }
    if (line.charAt(column_from) == '"') {
      selection_len += 1;
    }
    if (line.charAt(column_from + selection_len) == '"') {
      selection_len += 1;
    }
    if (line.slice(column_from - 2, column_from) === ", ") {
      column_from -= 2;
      selection_len += 2;
      const column_to2 = fm_start_offset + column_from + selection_len;
      const from2 = { line: line_no, ch: column_from };
      const to2 = { line: line_no, ch: column_to2 };
      leaf.view.editor.setSelection(from2, to2);
      return;
    }
    if (line.charAt(column_from + selection_len) == ",") {
      selection_len += 1;
    }
    if (line.charAt(column_from + selection_len) == " ") {
      selection_len += 1;
    }
    if (line.charAt(column_from + selection_len) == "]") {
      if (line.charAt(column_from - 1) == " " || line.charAt(column_from - 1) == ",") {
        column_from -= 1;
        selection_len += 1;
      }
    }
  }
  const column_to = fm_start_offset + column_from + selection_len;
  const from = { line: line_no, ch: column_from };
  const to = { line: line_no, ch: column_to };
  leaf.view.editor.setSelection(from, to);
}
function is_simple_markdown_list_entry(line) {
  const regular_expression = /^ +- /;
  return regular_expression.test(line);
}
function sort_words_in_string(input) {
  const words_array = input.split(" ");
  if (words_array.length === 1) {
    return input;
  }
  const sorted_words_array = words_array.sort();
  const sorted_string = sorted_words_array.join(" ");
  return sorted_string;
}
function parse_regex_lines_sed(regex_input) {
  try {
    return regex_input.trim().split("\n").map((line) => {
      const [, regex_str, replacement, flags] = line.trim().match(/^s\/(.*?)\/(.*?)\/([gimy]*)$/) || [];
      if (regex_str && replacement !== void 0) {
        const regex = new RegExp(regex_str, flags);
        return [regex, replacement];
      } else {
        throw new Error(`Invalid regex syntax: ${line}`);
      }
    });
  } catch (error) {
    console.error(`Error parsing regex: ${error.message}`);
    return [];
  }
}
function parse_regex_lines_simple_flags(regex_input) {
  try {
    return regex_input.trim().split("\n").map((line) => {
      const [, regex_str, flags] = line.trim().match(/^(.*?)\/([gimy]*)$/) || [];
      if (regex_str) {
        const regex = new RegExp(regex_str, flags);
        return regex;
      } else {
        throw new Error(`Invalid regex syntax: ${line}`);
      }
    });
  } catch (error) {
    console.error(`Error parsing regex: ${error.message}`);
    return [];
  }
}
function escape_regex(txt) {
  return txt.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
async function open_file(plugin, fpath) {
  let target_leaf = void 0;
  let num_leaves = 0;
  plugin.app.workspace.iterateAllLeaves((leaf) => {
    var _a, _b;
    if (leaf.view instanceof import_obsidian.MarkdownView) {
      num_leaves += 1;
      if (((_b = (_a = leaf.view) == null ? void 0 : _a.file) == null ? void 0 : _b.path) === fpath) {
        target_leaf = leaf;
      }
    }
  });
  if (target_leaf) {
    plugin.app.workspace.setActiveLeaf(target_leaf, true, true);
    return target_leaf;
  }
  if (num_leaves === 0) {
    target_leaf = plugin.app.workspace.getLeaf(false);
  } else if (plugin.settings.open_links_vertically_splitted) {
    target_leaf = plugin.app.workspace.splitActiveLeaf("vertical");
  } else {
    target_leaf = plugin.app.workspace.getLeaf("tab");
  }
  if (!target_leaf) {
    return false;
  }
  let file_opened = false;
  const file = plugin.app.vault.getAbstractFileByPath(fpath);
  if (!(file instanceof import_obsidian.TFile)) {
    return false;
  }
  await target_leaf.openFile(file).then(() => {
    if (target_leaf && target_leaf.view instanceof import_obsidian.MarkdownView) {
      plugin.app.workspace.setActiveLeaf(target_leaf, true, true);
      file_opened = true;
    }
  });
  if (!file_opened) {
    return false;
  }
  return target_leaf;
}
async function get_file_content(plugin, file) {
  return await plugin.app.vault.cachedRead(file);
}
function regex_index_of(txt, regex, occurrence) {
  const match_index = txt.search(regex);
  if (occurrence <= 1) {
    return match_index;
  }
  let char_counter = match_index;
  let remaining_text = txt.substring(match_index + 1);
  let new_match_index;
  for (let index of [...Array(occurrence - 1).keys()]) {
    new_match_index = remaining_text.search(regex) + 1;
    char_counter += new_match_index;
    remaining_text = remaining_text.substring(new_match_index);
  }
  return char_counter;
}
function aliases_listed_for_fpath(fpath) {
  const selector = CSS.escape(JSON.stringify({ "fpath": fpath }));
  const div = document.querySelector(`.${ListAliasesViewIdentifier} div[class*="${selector}"]`);
  return div ? true : false;
}
function no_aliases_listed() {
  const div = document.querySelector(`.${ListAliasesViewIdentifier}:empty`);
  return div ? true : false;
}
function compare_lists(oldList, newList) {
  const old_map = count_elements(oldList);
  const new_map = count_elements(newList);
  const removed = [];
  const added = [];
  old_map.forEach((count, item) => {
    const new_count = new_map.get(item) || 0;
    if (new_count < count) {
      for (let i = new_count; i < count; i++) {
        removed.push(item);
      }
    }
  });
  new_map.forEach((count, item) => {
    const old_count = old_map.get(item) || 0;
    if (old_count < count) {
      for (let i = old_count; i < count; i++) {
        added.push(item);
      }
    }
  });
  return { removed, added };
}
function count_elements(list) {
  const element_count = /* @__PURE__ */ new Map();
  for (const item of list) {
    element_count.set(item, (element_count.get(item) || 0) + 1);
  }
  return element_count;
}
function split_csv_string(input) {
  return input.split(",").map((item) => item.trim().replace(/^\/|\/$/g, "")).filter((item) => item !== "");
}

// src/settings.ts
var DefaultSettings = {
  add_filename_to_aliases: true,
  add_filename_as_alphabetical_sorted_words: true,
  add_aliases_as_alphabetical_sorted_words: true,
  case_insensitive: true,
  ignore_folders_csv: "assets, images",
  replace_regex_str: `s/[^\\w\\s]|_/ /g
s/ //g`,
  exclude_physical_aliases_regex_str: `^readme$/i
^general$/i`,
  sort_desc: true,
  open_links_vertically_splitted: true
};
var SettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    let view = containerEl.createEl("div", { cls: `${PluginIdentifier}_settings` });
    new import_obsidian2.Setting(view).setName("Add filenames to aliases").setDesc("Toggle to include filenames as aliases.").addToggle((toggle) => toggle.setValue(this.plugin.settings.add_filename_to_aliases).onChange(async (value) => {
      this.plugin.settings.add_filename_to_aliases = value;
      await this.plugin.saveSettings();
      this.reload();
    }));
    new import_obsidian2.Setting(view).setName("Sort multi-word filenames alphabetically").setDesc("Arrange filenames with multiple words alphabetically. For example, `to go` becomes `go to`.").addToggle((toggle) => toggle.setValue(this.plugin.settings.add_filename_as_alphabetical_sorted_words).onChange(async (value) => {
      this.plugin.settings.add_filename_as_alphabetical_sorted_words = value;
      await this.plugin.saveSettings();
      this.reload();
    }));
    new import_obsidian2.Setting(view).setName("Sort multi-word aliases alphabetically").setDesc("Arrange aliases with multiple words alphabetically.").addToggle((toggle) => toggle.setValue(this.plugin.settings.add_aliases_as_alphabetical_sorted_words).onChange(async (value) => {
      this.plugin.settings.add_aliases_as_alphabetical_sorted_words = value;
      await this.plugin.saveSettings();
      this.reload();
    }));
    new import_obsidian2.Setting(view).setName("Ignore capitalization").setDesc("Toggle to disregard capitalization differences in aliases and filenames. For example, `NOTE` is treated as `note`.").addToggle((toggle) => toggle.setValue(this.plugin.settings.case_insensitive).onChange(async (value) => {
      this.plugin.settings.case_insensitive = value;
      await this.plugin.saveSettings();
      this.reload();
    }));
    new import_obsidian2.Setting(view).setName("Exclude files").setDesc("Exclude files located within specified folder paths. Paths should be comma-separated and relative to the root.").addText((text) => text.setValue(this.plugin.settings.ignore_folders_csv).onChange(async (value) => {
      this.plugin.settings.ignore_folders_csv = value;
      await this.plugin.saveSettings();
      this.plugin.ignore_folders = split_csv_string(this.plugin.settings.ignore_folders_csv);
      this.reload();
    }));
    new import_obsidian2.Setting(view).setName("Replace aliases").setDesc("Define regular expressions to replace specific patterns within aliases. For instance, special characters can be replaced with spaces.").addTextArea((text) => text.setValue(this.plugin.settings.replace_regex_str).onChange(async (value) => {
      this.plugin.settings.replace_regex_str = value;
      await this.plugin.saveSettings();
      this.plugin.replace_regex = parse_regex_lines_sed(value);
      this.reload();
    }));
    new import_obsidian2.Setting(view).setName("Exclude aliases").setDesc("Define regular expressions to exclude specific aliases. This can be useful for filtering out common or irrelevant aliases.").addTextArea((text) => text.setValue(this.plugin.settings.exclude_physical_aliases_regex_str).onChange(async (value) => {
      this.plugin.settings.exclude_physical_aliases_regex_str = value;
      await this.plugin.saveSettings();
      this.plugin.exclude_physical_aliases_regex = parse_regex_lines_simple_flags(value);
      this.reload();
    }));
    new import_obsidian2.Setting(view).setName("Descending order").setDesc("Sort the lists of duplicate aliases in descending order based on the number of occurrences.").addToggle((toggle) => toggle.setValue(this.plugin.settings.sort_desc).onChange(async (value) => {
      this.plugin.settings.sort_desc = value;
      await this.plugin.saveSettings();
      if (this.plugin.app.workspace.getLeavesOfType(DuplicateAliasesViewIdentifier).length === 1) {
        const view2 = find_duplicate_aliases_view();
        if (!view2) {
          return;
        }
        sort_duplicate_aliases_view(this.plugin, view2);
      }
    }));
    new import_obsidian2.Setting(view).setName("Open notes side by side").setDesc("Enable to open notes side by side, facilitating easier comparison between files.").addToggle((toggle) => toggle.setValue(this.plugin.settings.open_links_vertically_splitted).onChange(async (value) => {
      this.plugin.settings.open_links_vertically_splitted = value;
      await this.plugin.saveSettings();
    }));
  }
  reload() {
    this.plugin.physical_alias_to_generated_aliases = /* @__PURE__ */ new Map();
    if (this.plugin.app.workspace.getLeavesOfType(ListAliasesViewIdentifier).length === 1) {
      init_list_aliases_view(this.plugin);
    }
    if (this.plugin.app.workspace.getLeavesOfType(DuplicateAliasesViewIdentifier).length === 1) {
      init_duplicate_aliases_view(this.plugin);
    }
  }
};

// src/ListAliasesView.ts
var import_obsidian3 = require("obsidian");
var ListAliasesView = class extends import_obsidian3.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return ListAliasesViewIdentifier;
  }
  getDisplayText() {
    return ListAliasesViewName;
  }
  getIcon() {
    return ListAliasesViewIcon;
  }
  async onOpen() {
    let container = this.containerEl.children[1];
    container.empty();
    container.createEl("div", { cls: ListAliasesViewIdentifier });
    init_list_aliases_view(this.plugin);
  }
  async onClose() {
    let container = this.containerEl.children[1];
    container.empty();
  }
};

// src/DuplicateAliasesView.ts
var import_obsidian4 = require("obsidian");
var DuplicateAliasesView = class extends import_obsidian4.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return DuplicateAliasesViewIdentifier;
  }
  getDisplayText() {
    return DuplicateAliasesViewName;
  }
  getIcon() {
    return DuplicateAliasesViewIcon;
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    const view = container.createEl("div", { cls: DuplicateAliasesViewIdentifier });
    view.createEl("div", { cls: "header" });
    const body = view.createEl("div", { cls: "body" });
    init_duplicate_aliases_view(this.plugin, body);
  }
  async onClose() {
    const container = this.containerEl.children[1];
    container.empty();
  }
};

// src/main.ts
var AliasManagementPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DefaultSettings;
    this.fpath_to_physical_aliases = /* @__PURE__ */ new Map();
    this.physical_alias_to_generated_aliases = /* @__PURE__ */ new Map();
    this.generated_alias_to_fpaths = /* @__PURE__ */ new Map();
    // If there are aliases to be excluded matching filenames: keep mapping for correct color representation
    this.fpath_filename_ignored = /* @__PURE__ */ new Set();
  }
  async onload() {
    await this.loadSettings();
    this.registerView(
      ListAliasesViewIdentifier,
      (leaf) => new ListAliasesView(leaf, this)
    );
    this.addRibbonIcon(ListAliasesViewIcon, ListAliasesViewName, async () => {
      this.activateListAliasesView();
    });
    this.addCommand({
      id: `${ListAliasesViewIdentifier}_open-view`,
      name: ListAliasesViewCommandDesc,
      callback: () => {
        this.activateListAliasesView();
      }
    });
    this.registerView(
      DuplicateAliasesViewIdentifier,
      (leaf) => new DuplicateAliasesView(leaf, this)
    );
    this.addRibbonIcon(DuplicateAliasesViewIcon, DuplicateAliasesViewName, async () => {
      this.activateDuplicateAliasesView();
    });
    this.addCommand({
      id: `${DuplicateAliasesViewIdentifier}_open-view`,
      name: DuplicateAliasesViewCommandDesc,
      callback: () => {
        this.activateDuplicateAliasesView();
      }
    });
    this.addSettingTab(new SettingsTab(this.app, this));
    this.registerEvent(this.app.vault.on("rename", this.onRename, this));
    this.registerEvent(this.app.metadataCache.on("changed", this.onChanged, this));
    this.registerEvent(this.app.metadataCache.on("deleted", this.onDeleted, this));
    this.registerEvent(this.app.workspace.on("active-leaf-change", this.onActiveLeafChange, this));
  }
  async loadSettings() {
    this.settings = Object.assign({}, DefaultSettings, await this.loadData());
    this.replace_regex = parse_regex_lines_sed(this.settings.replace_regex_str);
    this.ignore_folders = split_csv_string(this.settings.ignore_folders_csv);
    this.exclude_physical_aliases_regex = parse_regex_lines_simple_flags(this.settings.exclude_physical_aliases_regex_str);
  }
  async activateListAliasesView() {
    let leaves = this.app.workspace.getLeavesOfType(ListAliasesViewIdentifier);
    if (leaves.length === 0) {
      await this.app.workspace.getRightLeaf(false).setViewState({
        type: ListAliasesViewIdentifier,
        active: true
      });
    }
    leaves = this.app.workspace.getLeavesOfType(ListAliasesViewIdentifier);
    this.app.workspace.revealLeaf(leaves[0]);
  }
  async activateDuplicateAliasesView() {
    let leaves = this.app.workspace.getLeavesOfType(DuplicateAliasesViewIdentifier);
    if (leaves.length === 0) {
      await this.app.workspace.getRightLeaf(false).setViewState({
        type: DuplicateAliasesViewIdentifier,
        active: true
      });
    }
    leaves = this.app.workspace.getLeavesOfType(DuplicateAliasesViewIdentifier);
    this.app.workspace.revealLeaf(leaves[0]);
  }
  async onActiveLeafChange(leaf) {
    active_leaf_changed(this, leaf);
  }
  async onRename(file_new, fpath_old) {
    file_renamed(this, file_new, fpath_old);
  }
  async onChanged(file, md_content, cache) {
    file_changed(this, file, md_content, cache);
  }
  async onDeleted(file, prevCache) {
    file_deleted(this, file, prevCache);
  }
  onunload() {
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
