/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CanvasSendToBackPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/Notice.ts
var import_obsidian = require("obsidian");
var DEFAULT_NOTICE_TIMEOUT_SECONDS = 5;
var ErrorNotice = class extends import_obsidian.Notice {
  constructor(message, timeout = DEFAULT_NOTICE_TIMEOUT_SECONDS) {
    super(`Canvas Send To Back
${message}`, timeout * 1e3);
    console.error(`canvas-send-to-back: ${message}`);
  }
};

// src/canvas.ts
var import_obsidian2 = require("obsidian");
function isCanvasNodeData(node) {
  return !!node && typeof node === "object" && "id" in node;
}
function isCanvasData(data) {
  return !!data && typeof data === "object" && "nodes" in data && Array.isArray(data.nodes) && "edges" in data && Array.isArray(data.edges);
}
function isCanvasState(state) {
  return !!state && typeof state === "object" && "viewState" in state && !!state.viewState && typeof state.viewState === "object" && "x" in state.viewState && typeof state.viewState.x === "number" && "y" in state.viewState && typeof state.viewState.y === "number" && "zoom" in state.viewState && typeof state.viewState.zoom === "number";
}
function getActiveCanvas(app) {
  const view = app.workspace.getActiveViewOfType(import_obsidian2.ItemView);
  if (!view || !view.getViewData || !view.setViewData || !view.requestSave) {
    throw new Error("No active view.");
  }
  const data = JSON.parse(view.getViewData());
  if (!isCanvasData(data)) {
    throw new Error("Active view does not contain Canvas data.");
  }
  return { view, data };
}
function setActiveCanvasData(view, data) {
  if (!view || !view.getViewData || !view.setViewData || !view.requestSave) {
    throw new Error("No active view.");
  }
  if (!isCanvasData(data)) {
    throw new Error("Data is not Canvas data.");
  }
  const state = view.getState();
  view.setViewData(JSON.stringify(data), true);
  view.requestSave();
  if (isCanvasState(state)) {
    view.setState(state, {});
  } else {
    throw new Error("Failed to reset zoom.");
  }
}
function getCanvasNodeDataByID(id, data) {
  const matchingNode = data.nodes.find((x) => x.id === id);
  if (!matchingNode) {
    throw new Error(`Could not find matching node with id "${id}".`);
  }
  return matchingNode;
}

// src/register-events.ts
function registerEvents(plugin) {
  const menuSectionName = "canvasSendToBack";
  plugin.registerEvent(
    plugin.app.workspace.on(
      "canvas:node-menu",
      (menu, node) => {
        menu.addItem((item) => {
          item.setTitle("Send to back");
          item.setSection(menuSectionName);
          item.onClick((e) => {
            plugin.sendNodeToBack(node);
          });
        });
      }
    )
  );
  plugin.registerEvent(
    plugin.app.workspace.on(
      "canvas:node-menu",
      (menu, node) => {
        menu.addItem((item) => {
          item.setTitle("Send to front");
          item.setSection(menuSectionName);
          item.onClick((e) => {
            plugin.sendNodeToFront(node);
          });
        });
      }
    )
  );
}

// src/main.ts
var CanvasSendToBackPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    registerEvents(this);
  }
  onunload() {
  }
  sendNodeToBack(node) {
    try {
      if (!isCanvasNodeData(node)) {
        throw new Error(`Must provide a valid node.`);
      }
      const { view, data } = getActiveCanvas(this.app);
      const matchingNode = getCanvasNodeDataByID(node.id, data);
      const filteredNodes = data.nodes.filter((x) => x.id !== node.id);
      filteredNodes.unshift(matchingNode);
      data.nodes = filteredNodes;
      setActiveCanvasData(view, data);
    } catch (err) {
      new ErrorNotice(`Error sending node to back.
${err}`);
    }
  }
  sendNodeToFront(node) {
    try {
      if (!isCanvasNodeData(node)) {
        throw new Error(`Must provide a valid node.`);
      }
      const { view, data } = getActiveCanvas(this.app);
      const matchingNode = getCanvasNodeDataByID(node.id, data);
      const filteredNodes = data.nodes.filter((x) => x.id !== node.id);
      filteredNodes.push(matchingNode);
      data.nodes = filteredNodes;
      setActiveCanvasData(view, data);
    } catch (err) {
      new ErrorNotice(`Error sending node to front.
${err}`);
    }
  }
};
