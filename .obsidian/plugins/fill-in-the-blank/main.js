/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FillInTheBlankPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var FITB_START = "--";
var FITB_STOP = "--";
var FITB_START_SIZE = FITB_START.length;
var FITB_STOP_SIZE = FITB_STOP.length;
var FillInTheBlankPlugin = class extends import_obsidian.Plugin {
  async onload() {
    this.addCommand({
      id: "toggle",
      name: "Toggle",
      icon: "highlight-glyph",
      editorCallback: (editor, context) => {
        let a = editor.getCursor("from"), b = editor.getCursor("to");
        if (a.line > b.line || a.line == b.line && a.ch > b.ch) {
          const c2 = a;
          a = b;
          b = c2;
        }
        const c = { ...a, ch: Math.max(a.ch - FITB_START_SIZE, 0) }, d = { ...b, ch: Math.min(b.ch + FITB_STOP_SIZE, editor.getLine(b.line).length) }, slim = editor.getRange(a, b), wide = editor.getRange(c, d);
        if (slim.startsWith(FITB_START) && slim.endsWith(FITB_STOP)) {
          editor.replaceRange(slim.substring(FITB_START_SIZE, slim.length - FITB_STOP_SIZE), a, b);
          editor.setSelection(a, { ...b, ch: b.ch - FITB_START_SIZE - FITB_STOP_SIZE });
          return;
        }
        if (wide.startsWith(FITB_START) && wide.endsWith(FITB_STOP)) {
          editor.replaceRange(slim, c, d);
          editor.setSelection(c, { ...d, ch: d.ch - FITB_START_SIZE - FITB_STOP_SIZE });
          return;
        }
        editor.replaceRange(`${FITB_START}${slim}${FITB_STOP}`, a, b);
        editor.setSelection(
          { ...a, ch: a.ch + FITB_START_SIZE },
          { ...b, ch: b.ch + FITB_START_SIZE }
        );
      }
    });
    this.addRibbonIcon("highlight-glyph", "Fill in the Blank", (evt) => {
      this.app.commands.executeCommandById("fill-in-the-blank:toggle");
    });
    this.registerMarkdownPostProcessor((element, context) => {
      const items = element.querySelectorAll("p, h1, h2, h3, h4, h5, li, td, th, code");
      items.forEach((item) => {
        var _a, _b;
        while (item.innerHTML.indexOf(FITB_START) >= 0 && item.innerHTML.indexOf(FITB_STOP) >= 0) {
          const a = item.innerHTML.indexOf(FITB_START), b = item.innerHTML.indexOf(FITB_STOP, a + 1);
          if (b === -1)
            break;
          const fitb = (_b = (_a = context.frontmatter) == null ? void 0 : _a.fitb) != null ? _b : true, hide = item.innerHTML.substring(a, b + FITB_START_SIZE), show = hide.substring(FITB_START_SIZE, hide.length - FITB_STOP_SIZE).split(/\s+/g).map((word) => {
            return fitb ? this.blankify(word) : word;
          }).join("  ");
          item.innerHTML = item.innerHTML.replace(hide, show);
        }
      });
    });
  }
  blankify(word, pattern = "__") {
    return "".padStart(word.length * pattern.length, pattern);
  }
  onunload() {
  }
};
