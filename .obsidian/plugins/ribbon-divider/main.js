/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DividerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues, rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues && (getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !getRandomValues))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i)
  byteToHex.push((i + 256).toString(16).slice(1));
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto != "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto), native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options)
    return native_default.randomUUID();
  options = options || {};
  let rnds = options.random || (options.rng || rng)();
  if (rnds[6] = rnds[6] & 15 | 64, rnds[8] = rnds[8] & 63 | 128, buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i)
      buf[offset + i] = rnds[i];
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// main.ts
var DEFAULT_SETTINGS = {
  dividers: {}
}, DividerPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.dividerElements = {};
  }
  async onload() {
    await this.loadSettings(), this.versionCheck(), Object.keys(this.settings.dividers).forEach((dividerId) => {
      let divider = this.settings.dividers[dividerId];
      this.renderDivider(divider);
    }), this.addSettingTab(new DividerSettingTab(this.app, this));
  }
  onunload() {
  }
  /**
   * Load data from disk, stored in data.json in plugin folder
   */
  async loadSettings() {
    let data = await this.loadData() || {};
    this.settings = Object.assign({}, DEFAULT_SETTINGS, data), this.settings.dividers || (this.settings.dividers = {});
  }
  /**
   * Save data to disk, stored in data.json in plugin folder
   */
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Check the local plugin version against github. If there is a new version, notify the user.
   */
  async versionCheck() {
    let localVersion = "1.1.1", stableVersion = await (0, import_obsidian.requestUrl)(
      "https://raw.githubusercontent.com/andrewmcgivery/obsidian-ribbon-divider/main/package.json"
    ).then(async (res) => {
      if (res.status === 200)
        return (await res.json).version;
    }), betaVersion = await (0, import_obsidian.requestUrl)(
      "https://raw.githubusercontent.com/andrewmcgivery/obsidian-ribbon-divider/beta/package.json"
    ).then(async (res) => {
      if (res.status === 200)
        return (await res.json).version;
    });
    (localVersion == null ? void 0 : localVersion.indexOf("beta")) !== -1 ? localVersion !== betaVersion && new import_obsidian.Notice(
      "There is a beta update available for the Ribbon Divider plugin. Please update to to the latest version to get the latest features!",
      0
    ) : localVersion !== stableVersion && new import_obsidian.Notice(
      "There is an update available for the Ribbon Divider plugin. Please update to to the latest version to get the latest features!",
      0
    );
  }
  /**
   * Renders a divider on the ribbon. The HTMLElement is saved to this.dividerElemenets so we can remove it if the
   * user deletes it from the settings screen.
   * @param divider
   */
  async renderDivider(divider) {
    if (document.body.hasClass("is-phone"))
      return;
    let dividerIconEl = this.addRibbonIcon(
      "",
      `ribbon-divider-${divider.id}`,
      (evt) => {
      }
    );
    dividerIconEl.addClass("ribbon-divider"), dividerIconEl.addClass(`ribbon-divider-${divider.id}`), this.dividerElements[divider.id] = dividerIconEl;
  }
  /**
   * Add a new divider and render it
   * @param divider
   */
  async addDivider(divider) {
    this.renderDivider(divider), this.settings.dividers[divider.id] = divider, await this.saveSettings();
  }
  /**
   * Remove an existing divider, both from settings, and from the UI by calling remove() on the saved HTMLElement
   * @param dividerId
   */
  async removeDivider(dividerId) {
    delete this.settings.dividers[dividerId], this.saveSettings(), this.dividerElements[dividerId] && (this.dividerElements[dividerId].remove(), delete this.dividerElements[dividerId]);
  }
}, DividerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty(), containerEl.createEl("p", {
      attr: {
        style: "display: block; margin-bottom: 5px"
      },
      text: 'Use this settings screen to add/update dividers to your ribbon. Clicking "New Divider" below will immediately add the divider.'
    }), containerEl.createEl("hr");
    let dividersContainerEl = containerEl.createDiv("dividers-container");
    Object.keys(this.plugin.settings.dividers).forEach((dividerId) => {
      let divider = this.plugin.settings.dividers[dividerId];
      new import_obsidian.Setting(dividersContainerEl).setName("Divider").setDesc(`Id: ${divider.id}`).addButton((button) => {
        button.setButtonText("Delete").onClick(async () => {
          await this.plugin.removeDivider(divider.id), this.display();
        });
      });
    }), containerEl.createEl("button", { text: "New divider", cls: "mod-cta" }).addEventListener("click", () => {
      this.plugin.addDivider({
        id: v4_default()
      }), this.display();
    });
  }
};
