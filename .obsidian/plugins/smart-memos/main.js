/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// ../jsbrains/smart-chat-model/adapters/anthropic.js
var require_anthropic = __commonJS({
  "../jsbrains/smart-chat-model/adapters/anthropic.js"(exports) {
    var AnthropicAdapter = class {
      /**
       * Prepares the request body for the Anthropic API by converting ChatML format to a format compatible with Anthropic.
       * @param {Object} opts - The options object containing messages and other parameters in ChatML format.
       * @returns {Object} The request body formatted for the Anthropic API.
       */
      prepare_request_body(opts) {
        return chatml_to_anthropic(opts);
      }
      /**
       * Counts the tokens in the input by estimating them, as the Anthropic model does not provide a direct method.
       * @param {string|Object} input - The input text or object to count tokens in.
       * @returns {Promise<number>} The estimated number of tokens in the input.
       */
      async count_tokens(input) {
        return this.estimate_tokens(input);
      }
      /**
       * Estimates the number of tokens in the input based on a rough average token size.
       * @param {string|Object} input - The input text or object to estimate tokens in.
       * @returns {number} The estimated number of tokens.
       */
      estimate_tokens(input) {
        if (typeof input === "object")
          input = JSON.stringify(input);
        return Math.ceil(input.length / 6);
      }
      /**
       * Extracts the first tool call from the JSON response content.
       * @param {Object} json - The JSON response from which to extract the tool call.
       * @returns {Object|null} The first tool call found, or null if none exist.
       */
      get_tool_call(json) {
        return json.content.find((msg) => msg.type === "tool_use");
      }
      /**
       * Retrieves the input content of a tool call.
       * @param {Object} tool_call - The tool call object from which to extract the input.
       * @returns {Object} The input of the tool call.
       */
      get_tool_call_content(tool_call) {
        return tool_call.input;
      }
      /**
       * Retrieves the name of the tool from a tool call object.
       * @param {Object} tool_call - The tool call object from which to extract the name.
       * @returns {string} The name of the tool.
       */
      get_tool_name(tool_call) {
        return tool_call.name;
      }
      /**
       * Extracts the first message from the JSON response content.
       * @param {Object} json - The JSON response from which to extract the message.
       * @returns {Object|null} The first message found, or null if none exist.
       */
      get_message(json) {
        var _a;
        return (_a = json.content) == null ? void 0 : _a[0];
      }
      /**
       * Retrieves the content of the first message from the JSON response.
       * @param {Object} json - The JSON response from which to extract the message content.
       * @returns {string|null} The content of the first message, or null if no message is found.
       */
      get_message_content(json) {
        var _a, _b;
        return (_b = this.get_message(json)) == null ? void 0 : _b[(_a = this.get_message(json)) == null ? void 0 : _a.type];
      }
    };
    exports.AnthropicAdapter = AnthropicAdapter;
    function chatml_to_anthropic(opts) {
      let tool_counter = 0;
      const messages = opts.messages.filter((msg) => msg.role !== "system").map((m) => {
        if (m.role === "tool") {
          return { role: "user", content: [
            {
              type: "tool_result",
              tool_use_id: `tool-${tool_counter}`,
              content: m.content
            }
          ] };
        }
        if (m.role === "assistant" && m.tool_calls) {
          tool_counter++;
          const out2 = {
            role: m.role,
            content: m.tool_calls.map((c) => ({
              type: "tool_use",
              id: `tool-${tool_counter}`,
              name: c.function.name,
              input: typeof c.function.arguments === "string" ? JSON.parse(c.function.arguments) : c.function.arguments
            }))
          };
          if (m.content) {
            if (typeof m.content === "string")
              out2.content.push({ type: "text", text: m.content });
            else
              m.content.forEach((c) => out2.content.push(c));
          }
          return out2;
        }
        if (typeof m.content === "string")
          return { role: m.role, content: m.content };
        if (Array.isArray(m.content)) {
          const content = m.content.map((c) => {
            if (c.type === "text")
              return { type: "text", text: c.text };
            if (c.type === "image_url") {
              const image_url = c.image_url.url;
              let media_type = image_url.split(":")[1].split(";")[0];
              if (media_type === "image/jpg")
                media_type = "image/jpeg";
              return { type: "image", source: { type: "base64", media_type, data: image_url.split(",")[1] } };
            }
          });
          return { role: m.role, content };
        }
        return m;
      });
      const { model, max_tokens, temperature, tools, tool_choice } = opts;
      const last_system_idx = opts.messages.findLastIndex((msg) => msg.role === "system" && msg.content.includes("---BEGIN"));
      if (last_system_idx > -1) {
        const system_prompt = "<context>\n" + opts.messages[last_system_idx].content + "\n</context>\n";
        messages[messages.length - 1].content = system_prompt + messages[messages.length - 1].content;
      }
      console.log(messages);
      const out = {
        messages,
        model,
        max_tokens,
        temperature
      };
      if (tools) {
        out.tools = tools.map((tool) => ({
          name: tool.function.name,
          description: tool.function.description,
          input_schema: tool.function.parameters
        }));
        if ((tool_choice == null ? void 0 : tool_choice.type) === "function") {
          const tool_prompt = `Use the "${tool_choice.function.name}" tool!`;
          const last_user_idx = out.messages.findLastIndex((msg) => msg.role === "user");
          out.messages[last_user_idx].content += "\n" + tool_prompt;
          out.system = `Required: use the "${tool_choice.function.name}" tool!`;
        }
      }
      const last_non_context_system_idx = opts.messages.findLastIndex((msg) => msg.role === "system" && !msg.content.includes("---BEGIN"));
      if (last_non_context_system_idx > -1)
        out.system = opts.messages[last_non_context_system_idx].content;
      return out;
    }
    exports.chatml_to_anthropic = chatml_to_anthropic;
  }
});

// ../jsbrains/smart-chat-model/adapters/cohere.js
var require_cohere = __commonJS({
  "../jsbrains/smart-chat-model/adapters/cohere.js"(exports) {
    var CohereAdapter = class {
      /**
       * Converts a ChatML object to a format suitable for a request to the Cohere API.
       * @param {Object} chatml - The ChatML object containing the chat history and other parameters.
       * @returns {Object} The request body formatted for the Cohere API.
       */
      prepare_request_body(chatml) {
        return chatml_to_cohere(chatml);
      }
      /**
       * Extracts the message content from a JSON response from the Cohere API.
       * @param {Object} json - The JSON response object from which to extract the text content.
       * @returns {string} The extracted text content from the response.
       */
      get_message_content(json) {
        return json.text;
      }
      /**
       * Processes streaming data received from the Cohere API and extracts text chunks.
       * This method handles the accumulation of text data over multiple events and manages the state of the stream.
       * @param {Object} event - The event object containing streaming data.
       * @returns {string} The accumulated text chunk extracted from the stream.
       */
      get_text_chunk_from_stream(event) {
        if (!this.last_line_index)
          this.last_line_index = 0;
        clearTimeout(this.last_line_timeout);
        this.last_line_timeout = setTimeout(() => {
          this.last_line_index = 0;
        }, 1e4);
        const data = event.source.xhr.responseText;
        const lines = data.split("\n").slice(this.last_line_index);
        console.log(lines);
        this.last_line_index += lines.length;
        const text_chunk = lines.filter((line) => line.trim() !== "").map((line) => {
          console.log(line);
          const json = JSON.parse(line);
          if (json.event_type === "stream-end") {
            console.log("stream-end");
            this.end_of_stream = true;
            setTimeout(() => {
              this.end_of_stream = false;
            }, 3e3);
            return "";
          }
          return json.text;
        }).join("");
        console.log(text_chunk);
        return text_chunk;
      }
      /**
       * Determines if the end of the stream has been reached based on the event data.
       * @param {Object} event - The event object that may indicate the end of the stream.
       * @returns {boolean} True if the end of the stream is indicated, false otherwise.
       */
      is_end_of_stream(event) {
        return this.end_of_stream;
      }
    };
    exports.CohereAdapter = CohereAdapter;
    function chatml_to_cohere(chatml) {
      const cohere = {
        model: chatml.model,
        // skip last user message
        chat_history: chatml.messages.slice(0, -1).map((message) => ({
          role: message.role,
          message: parse_message_content_to_string(message)
        })),
        message: parse_message_content_to_string(chatml.messages[chatml.messages.length - 1]),
        temperature: chatml.temperature
        // stream: chatml.stream // currently not supported
      };
      return cohere;
    }
    exports.chatml_to_cohere = chatml_to_cohere;
    function parse_message_content_to_string(message) {
      return Array.isArray(message.content) ? message.content.filter((c) => c.type === "text").map((c) => c.text).join("\n") : message.content;
    }
  }
});

// ../jsbrains/smart-chat-model/adapters/gemini.js
var require_gemini = __commonJS({
  "../jsbrains/smart-chat-model/adapters/gemini.js"(exports) {
    var GeminiAdapter = class {
      /**
       * Constructs a GeminiAdapter instance with a specified model configuration.
       * @param {Object} model - The model configuration object.
       */
      constructor(model) {
        this.model = model;
      }
      /**
       * Prepares the request body for the Gemini API by converting ChatML format to a format compatible with Gemini.
       * @param {Object} body - The options object containing messages and other parameters in ChatML format.
       * @returns {Object} The request body formatted for the Gemini API.
       */
      prepare_request_body(body) {
        return chatml_to_gemini(body);
      }
      /**
       * Extracts the first tool call from the JSON response content.
       * @param {Object} json - The JSON response from which to extract the tool call.
       * @returns {Object|null} The first tool call found, or null if none exist.
       */
      get_tool_call(json) {
        var _a, _b, _c, _d, _e;
        return (_e = (_d = (_c = (_b = (_a = json.candidates) == null ? void 0 : _a[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts) == null ? void 0 : _d[0]) == null ? void 0 : _e.functionCall;
      }
      /**
       * Retrieves the name of the tool from a tool call object.
       * @param {Object} tool_call - The tool call object from which to extract the name.
       * @returns {string|null} The name of the tool, or null if not available.
       */
      get_tool_name(tool_call) {
        return tool_call == null ? void 0 : tool_call.name;
      }
      /**
       * Retrieves the input content of a tool call.
       * @param {Object} tool_call - The tool call object from which to extract the input.
       * @returns {Object|null} The input of the tool call, or null if not available.
       */
      get_tool_call_content(tool_call) {
        return tool_call == null ? void 0 : tool_call.args;
      }
      /**
       * Extracts the first message from the JSON response content.
       * @param {Object} json - The JSON response from which to extract the message.
       * @returns {Object|null} The first message found, or null if none exist.
       */
      get_message(json) {
        var _a;
        return (_a = json.candidates) == null ? void 0 : _a[0];
      }
      /**
       * Retrieves the content of the first message from the JSON response.
       * @param {Object} json - The JSON response from which to extract the message content.
       * @returns {string|null} The content of the first message, or null if no message is found.
       */
      get_message_content(json) {
        var _a, _b;
        return (_b = (_a = this.get_message(json)) == null ? void 0 : _a.content) == null ? void 0 : _b.parts.map((part) => part.text).join("");
      }
      /**
       * Handles escaped newlines in a streaming text chunk.
       * @param {Object} event - The streaming event containing the data.
       * @returns {string} The text chunk with escaped newlines replaced.
       */
      get_text_chunk_from_stream(event) {
        return event.data.replace(/\\n/g, "\n");
      }
      /**
       * Determines if the streaming response has ended based on the readyState of the XMLHttpRequest.
       * @param {Object} event - The streaming event.
       * @returns {boolean} True if the stream has ended, false otherwise.
       */
      is_end_of_stream(event) {
        return event.source.xhr.readyState === 4;
      }
      /**
       * Counts the tokens in the input by making an API request to the Gemini token counting endpoint.
       * @param {string|Object} input - The input text or object to count tokens in.
       * @returns {Promise<number>} The total number of tokens in the input.
       */
      async count_tokens(input) {
        var _a;
        const req = {
          url: `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:countTokens?key=${this.model.api_key}`,
          method: "POST",
          headers: { "Content-Type": "application/json" }
        };
        let body;
        if (typeof input === "string")
          body = chatml_to_gemini({ messages: [{ role: "user", content: input }] });
        else if (Array.isArray(input))
          body = chatml_to_gemini({ messages: input });
        else if (typeof input === "object")
          body = chatml_to_gemini(input);
        else
          return console.error("Invalid input for count_tokens", input);
        delete body.generationConfig;
        delete body.safetySettings;
        req.body = JSON.stringify(body);
        const resp = await this.model.request_adapter(req);
        return (_a = resp == null ? void 0 : resp.json) == null ? void 0 : _a.totalTokens;
      }
      /**
       * Getter for the standard API endpoint with the API key appended.
       * @returns {string} The formatted endpoint URL for non-streaming requests.
       */
      get endpoint() {
        return this.model.config.endpoint.replace("MODEL_NAME", this.model.model_name) + "?key=" + this.model.api_key;
      }
      /**
       * Getter for the streaming API endpoint with the API key appended.
       * @returns {string} The formatted endpoint URL for streaming requests.
       */
      get endpoint_streaming() {
        return this.model.config.endpoint_streaming.replace("MODEL_NAME", this.model.model_name) + "?key=" + this.model.api_key;
      }
    };
    exports.GeminiAdapter = GeminiAdapter;
    function chatml_to_gemini(opts) {
      const messages = opts.messages.filter((msg) => msg.role !== "system");
      const last_system_idx = opts.messages.findLastIndex((msg) => msg.role === "system" && msg.content.includes("---BEGIN"));
      if (last_system_idx > -1) {
        const system_prompt = "---BEGIN IMPORTANT CONTEXT---\n" + opts.messages[last_system_idx].content + "\n---END IMPORTANT CONTEXT---\n\n";
        messages[messages.length - 1].content = system_prompt + messages[messages.length - 1].content;
      }
      const body = {
        contents: messages.filter((msg) => msg.role !== "system").map((msg) => {
          const content = {};
          content.role = msg.role === "assistant" ? "model" : msg.role;
          content.parts = !Array.isArray(msg.content) ? [{ text: msg.content }] : msg.content.map((c) => {
            if (c.type === "text") {
              return { text: c.text };
            }
            if (c.type === "image_url") {
              const image_url = c.image_url.url;
              let mime_type = image_url.split(":")[1].split(";")[0];
              if (mime_type === "image/jpg")
                mime_type = "image/jpeg";
              return { inline_data: { mime_type, data: image_url.split(",")[1] } };
            }
          });
          return content;
          ({
            role: msg.role === "assistant" ? "model" : msg.role,
            parts: Array.isArray(msg.content) ? [{ text: msg.content.filter((c) => c.type === "text").map((c) => c.text).join("\n") }] : [{ text: msg.content }]
          });
        }),
        generationConfig: {
          temperature: opts.temperature || 0.9,
          topK: opts.topK || 1,
          topP: opts.topP || 1,
          maxOutputTokens: opts.max_tokens || 2048,
          stopSequences: opts.stopSequences || [],
          candidate_count: opts.n || 1
        },
        safetySettings: [
          {
            category: "HARM_CATEGORY_HARASSMENT",
            threshold: "BLOCK_NONE"
          },
          {
            category: "HARM_CATEGORY_HATE_SPEECH",
            threshold: "BLOCK_NONE"
          },
          {
            category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
            threshold: "BLOCK_NONE"
          },
          {
            category: "HARM_CATEGORY_DANGEROUS_CONTENT",
            threshold: "BLOCK_NONE"
          }
        ]
      };
      const system_instructions = opts.messages.filter((msg) => msg.role === "system" && !msg.content.includes("---BEGIN"));
      if (system_instructions.length > 0)
        body.systemInstruction = { parts: system_instructions.map((msg) => ({ text: msg.content })) };
      if (opts.tools) {
        body.tools = [{
          function_declarations: opts.tools.map((tool) => ({
            name: tool.function.name,
            description: tool.function.description,
            parameters: tool.function.parameters
          }))
        }];
        if (opts.tool_choice) {
          if (opts.tool_choice !== "auto") {
            if (opts.model.includes("1.5") || opts.model.includes("flash")) {
              body.tool_config = {
                function_calling_config: {
                  mode: "ANY",
                  allowed_function_names: opts.tools.map((tool) => tool.function.name)
                }
              };
              body.systemInstruction = {
                role: "user",
                parts: [
                  {
                    text: `IMPORTANT: You must use the "${body.tools[0].function_declarations[0].name}" function tool!`
                  }
                ]
              };
            }
            const tool_prompt = `IMPORTANT: You must use the "${body.tools[0].function_declarations[0].name}" function tool!`;
            const last_user_idx = body.contents.findLastIndex((msg) => msg.role === "user");
            body.contents[last_user_idx].parts[0].text += "\n\n" + tool_prompt;
          }
        }
      }
      return body;
    }
    exports.chatml_to_gemini = chatml_to_gemini;
  }
});

// ../jsbrains/smart-chat-model/adapters/open_router.js
var require_open_router = __commonJS({
  "../jsbrains/smart-chat-model/adapters/open_router.js"(exports) {
    var OpenRouterAdapter = class {
      constructor(model) {
        this.model = model;
      }
      get_tool_call(json) {
        if (json.choices[0].message.tool_calls) {
          return json.choices[0].message.tool_calls[0].function;
        }
        if (json.choices[0].message.content.includes("function")) {
          const content = JSON.parse(json.choices[0].message.content);
          if (!content.function)
            return null;
          return content;
        }
        return null;
      }
      get_tool_name(tool_call) {
        if (tool_call.function)
          return tool_call.function;
        if (tool_call.name)
          return tool_call.name;
        return null;
      }
      get_tool_call_content(tool_call) {
        if (tool_call.parameters)
          return tool_call.parameters;
        if (tool_call.arguments) {
          const args = JSON.parse(tool_call.arguments);
          Object.entries(args).forEach(([key, value]) => {
            args[key] = value.replace(/\\n/g, "\n").replace(/\\t/g, "	").replace(/\\r/g, "\r").replace(/\\'/g, "'").replace(/\\"/g, '"');
          });
          return args;
        }
        return null;
      }
    };
    exports.OpenRouterAdapter = OpenRouterAdapter;
  }
});

// ../jsbrains/smart-chat-model/adapters.js
var require_adapters = __commonJS({
  "../jsbrains/smart-chat-model/adapters.js"(exports) {
    var { AnthropicAdapter } = require_anthropic();
    var { CohereAdapter } = require_cohere();
    var { GeminiAdapter } = require_gemini();
    var { OpenRouterAdapter } = require_open_router();
    exports.Anthropic = AnthropicAdapter;
    exports.Cohere = CohereAdapter;
    exports.Gemini = GeminiAdapter;
    exports.OpenRouter = OpenRouterAdapter;
  }
});

// ../jsbrains/smart-chat-model/platforms.json
var require_platforms = __commonJS({
  "../jsbrains/smart-chat-model/platforms.json"(exports, module2) {
    module2.exports = {
      openai: {
        description: "OpenAI",
        type: "API",
        endpoint: "https://api.openai.com/v1/chat/completions",
        streaming: true,
        actions: true,
        fetch_models: true,
        default_model: "gpt-3.5-turbo",
        signup_url: "https://platform.openai.com/api-keys"
      },
      google_gemini: {
        description: "Google Gemini",
        type: "API",
        api_key_header: "none",
        endpoint: "https://generativelanguage.googleapis.com/v1beta/models/MODEL_NAME:generateContent",
        endpoint_streaming: "https://generativelanguage.googleapis.com/v1beta/models/MODEL_NAME:streamGenerateContent",
        streaming: true,
        actions: true,
        adapter: "Gemini",
        fetch_models: true,
        default_model: "gemini-1.5-pro",
        signup_url: "https://ai.google.dev/"
      },
      open_router: {
        description: "Open Router",
        type: "API",
        endpoint: "https://openrouter.ai/api/v1/chat/completions",
        streaming: true,
        adapter: "OpenRouter",
        fetch_models: true,
        default_model: "mistralai/mistral-7b-instruct:free",
        signup_url: "https://accounts.openrouter.ai/sign-up?redirect_url=https%3A%2F%2Fopenrouter.ai%2Fkeys"
      },
      cohere: {
        description: "Cohere Command-R",
        type: "API",
        endpoint: "https://api.cohere.ai/v1/chat",
        streaming: false,
        adapter: "Cohere",
        fetch_models: true,
        default_model: "command-r",
        signup_url: "https://dashboard.cohere.com/welcome/register?redirect_uri=%2Fapi-keys"
      },
      anthropic: {
        description: "Anthropic Claude",
        type: "API",
        endpoint: "https://api.anthropic.com/v1/messages",
        streaming: false,
        api_key_header: "x-api-key",
        headers: {
          "anthropic-version": "2023-06-01",
          "anthropic-beta": "tools-2024-04-04"
        },
        adapter: "Anthropic",
        actions: true,
        fetch_models: true,
        default_model: "claude-3-sonnet-20240229",
        signup_url: "https://console.anthropic.com/login?returnTo=%2Fsettings%2Fkeys"
      },
      custom_local: {
        description: "Custom Local (OpenAI format)",
        type: "API"
      },
      custom_api: {
        description: "Custom API (OpenAI format)",
        type: "API"
      }
    };
  }
});

// ../jsbrains/smart-chat-model/utils/is_valid_tool_call.js
var require_is_valid_tool_call = __commonJS({
  "../jsbrains/smart-chat-model/utils/is_valid_tool_call.js"(exports) {
    function is_valid_tool_call(tool, tool_call_content) {
      var _a;
      const props = tool.function.parameters.properties;
      if (typeof props !== "undefined" && Object.keys(tool_call_content).length === 0) {
        console.warn(`Invalid tool call: object is empty`);
        return false;
      }
      Object.entries(tool_call_content).forEach(([key, value]) => {
        if (!props[key]) {
          console.warn(`Invalid tool call: missing key ${key} in tool spec`, props);
          return false;
        }
        if (Array.isArray(value) && props[key].type === "array") {
          const itemType = typeof value[0];
          if (!value.every((item) => typeof item === itemType)) {
            console.warn(`Invalid tool call: array items are not of the same type`);
            return false;
          }
          if (props[key].items.type !== itemType) {
            console.warn(`Invalid tool call: array items are not of the same type as the spec`);
            return false;
          }
        } else if (props[key].type !== typeof value) {
          if (props[key].type === "number" && typeof value === "string") {
            if (isNaN(Number(value))) {
              console.warn(`Invalid tool call: value ${value} is not a valid number`);
              return false;
            }
            tool_call_content[key] = Number(value);
          } else {
            console.warn(`Invalid tool call: value ${value} is not of type ${props[key].type}`);
            return false;
          }
        }
        if (props[key].enum && !props[key].enum.includes(value)) {
          console.warn(`Invalid tool call: value ${value} is not in enum ${props[key].enum}`);
          return false;
        }
      });
      (_a = tool.function.parameters.required) == null ? void 0 : _a.forEach((key) => {
        if (typeof tool_call_content[key] === "undefined") {
          console.warn(`Invalid tool call: missing required key ${key}`);
          return false;
        }
        if (tool_call_content[key] === "") {
          console.warn(`Empty value for required key ${key}`);
          return false;
        }
      });
      return true;
    }
    exports.is_valid_tool_call = is_valid_tool_call;
  }
});

// ../jsbrains/smart-chat-model/streamer.js
var require_streamer = __commonJS({
  "../jsbrains/smart-chat-model/streamer.js"(exports) {
    var _setReadyState, setReadyState_fn, _onStreamFailure, onStreamFailure_fn, _onStreamAbort, onStreamAbort_fn, _onStreamProgress, onStreamProgress_fn, _onStreamLoaded, onStreamLoaded_fn, _parseEventChunk, parseEventChunk_fn, _checkStreamClosed, checkStreamClosed_fn;
    var SmartStreamer = class {
      constructor(url, options = {}) {
        // private methods
        __privateAdd(this, _setReadyState);
        __privateAdd(this, _onStreamFailure);
        __privateAdd(this, _onStreamAbort);
        __privateAdd(this, _onStreamProgress);
        __privateAdd(this, _onStreamLoaded);
        __privateAdd(this, _parseEventChunk);
        __privateAdd(this, _checkStreamClosed);
        const {
          method = "GET",
          headers = {},
          body = null,
          withCredentials = false
        } = options;
        this.url = url;
        this.method = method;
        this.headers = headers;
        this.body = body;
        this.withCredentials = withCredentials;
        this.listeners = {};
        this.readyState = this.CONNECTING;
        this.progress = 0;
        this.chunk = "";
        this.last_event_id = "";
        this.xhr = null;
        this.FIELD_SEPARATOR = ":";
        this.INITIALIZING = -1;
        this.CONNECTING = 0;
        this.OPEN = 1;
        this.CLOSED = 2;
      }
      /**
       * Adds an event listener for the specified event type.
       *
       * @param {string} type - The type of the event.
       * @param {Function} listener - The listener function to be called when the event is triggered.
       */
      addEventListener(type, listener) {
        if (!this.listeners[type])
          this.listeners[type] = [];
        if (!this.listeners[type].includes(listener))
          this.listeners[type].push(listener);
      }
      /**
       * Removes an event listener from the SmartStreamer instance.
       *
       * @param {string} type - The type of event to remove the listener from.
       * @param {Function} listener - The listener function to remove.
       */
      removeEventListener(type, listener) {
        if (!this.listeners[type])
          return;
        this.listeners[type] = this.listeners[type].filter((callback) => callback !== listener);
        if (this.listeners[type].length === 0)
          delete this.listeners[type];
      }
      /**
       * Dispatches an event to the appropriate event handlers.
       *
       * @param {Event} event - The event to be dispatched.
       * @returns {boolean} - Returns true if the event was successfully dispatched, false otherwise.
       */
      dispatchEvent(event) {
        if (!event)
          return true;
        event.source = this;
        const onHandler = "on" + event.type;
        if (Object.prototype.hasOwnProperty.call(this, onHandler)) {
          this[onHandler].call(this, event);
          if (event.defaultPrevented)
            return false;
        }
        if (this.listeners[event.type]) {
          this.listeners[event.type].forEach((callback) => {
            callback(event);
            return !event.defaultPrevented;
          });
        }
        return true;
      }
      /**
       * Initiates the streaming process.
       */
      stream() {
        __privateMethod(this, _setReadyState, setReadyState_fn).call(this, this.CONNECTING);
        this.xhr = new XMLHttpRequest();
        this.xhr.addEventListener("progress", __privateMethod(this, _onStreamProgress, onStreamProgress_fn).bind(this));
        this.xhr.addEventListener("load", __privateMethod(this, _onStreamLoaded, onStreamLoaded_fn).bind(this));
        this.xhr.addEventListener("readystatechange", __privateMethod(this, _checkStreamClosed, checkStreamClosed_fn).bind(this));
        this.xhr.addEventListener("error", __privateMethod(this, _onStreamFailure, onStreamFailure_fn).bind(this));
        this.xhr.addEventListener("abort", __privateMethod(this, _onStreamAbort, onStreamAbort_fn).bind(this));
        this.xhr.open(this.method, this.url);
        for (const header in this.headers) {
          this.xhr.setRequestHeader(header, this.headers[header]);
        }
        if (this.last_event_id)
          this.xhr.setRequestHeader("Last-Event-ID", this.last_event_id);
        this.xhr.withCredentials = this.withCredentials;
        this.xhr.send(this.body);
      }
      /**
       * Ends the streamer connection.
       * Aborts the current XHR request and sets the ready state to CLOSED.
       */
      end() {
        if (this.readyState === this.CLOSED)
          return;
        this.xhr.abort();
        this.xhr = null;
        __privateMethod(this, _setReadyState, setReadyState_fn).call(this, this.CLOSED);
      }
    };
    _setReadyState = new WeakSet();
    setReadyState_fn = function(state) {
      const event = new CustomEvent("readyStateChange");
      event.readyState = state;
      this.readyState = state;
      this.dispatchEvent(event);
    };
    _onStreamFailure = new WeakSet();
    onStreamFailure_fn = function(e) {
      const event = new CustomEvent("error");
      event.data = e.currentTarget.response;
      this.dispatchEvent(event);
      this.end();
    };
    _onStreamAbort = new WeakSet();
    onStreamAbort_fn = function(e) {
      const event = new CustomEvent("abort");
      this.end();
    };
    _onStreamProgress = new WeakSet();
    onStreamProgress_fn = function(e) {
      if (!this.xhr)
        return;
      if (this.xhr.status !== 200) {
        __privateMethod(this, _onStreamFailure, onStreamFailure_fn).call(this, e);
        return;
      }
      if (this.readyState === this.CONNECTING) {
        this.dispatchEvent(new CustomEvent("open"));
        __privateMethod(this, _setReadyState, setReadyState_fn).call(this, this.OPEN);
      }
      const data = this.xhr.responseText.substring(this.progress);
      this.progress += data.length;
      data.split(/(\r\n|\r|\n)/g).forEach((part) => {
        if (part.trim().length === 0) {
          this.dispatchEvent(__privateMethod(this, _parseEventChunk, parseEventChunk_fn).call(this, this.chunk.trim()));
          this.chunk = "";
        } else {
          this.chunk += part;
        }
      });
    };
    _onStreamLoaded = new WeakSet();
    onStreamLoaded_fn = function(e) {
      __privateMethod(this, _onStreamProgress, onStreamProgress_fn).call(this, e);
      this.dispatchEvent(__privateMethod(this, _parseEventChunk, parseEventChunk_fn).call(this, this.chunk));
      this.chunk = "";
    };
    _parseEventChunk = new WeakSet();
    parseEventChunk_fn = function(chunk) {
      if (!chunk || chunk.length === 0)
        return null;
      const e = { id: null, retry: null, data: "", event: "message", text: "" };
      chunk.split(/(\r\n|\r|\n)/).forEach((line) => {
        line = line.trim();
        const index = line.indexOf(this.FIELD_SEPARATOR);
        if (index <= 0)
          return;
        const field = line.substring(0, index).replace(/^"|"$/g, "");
        if (!["id", "retry", "data", "event", "text"].includes(field))
          return;
        const value = line.substring(index + 1).trim().replace(/^"|"$/g, "");
        e.data += value;
      });
      if (e.id)
        this.last_event_id = e.id;
      const event = new CustomEvent(e.event || "message");
      event.id = e.id;
      event.data = e.data || "";
      event.last_event_id = this.last_event_id;
      return event;
    };
    _checkStreamClosed = new WeakSet();
    checkStreamClosed_fn = function() {
      if (!this.xhr)
        return;
      if (this.xhr.readyState === XMLHttpRequest.DONE)
        __privateMethod(this, _setReadyState, setReadyState_fn).call(this, this.CLOSED);
    };
    exports.SmartStreamer = SmartStreamer;
  }
});

// ../jsbrains/smart-chat-model/models/open_router.js
var require_open_router2 = __commonJS({
  "../jsbrains/smart-chat-model/models/open_router.js"(exports) {
    async function fetch_open_router_models(api_key, request_adapter = null) {
      try {
        let data;
        if (!request_adapter) {
          const response = await fetch("https://openrouter.ai/api/v1/models");
          if (!response.ok) {
            throw new Error("Network response was not ok");
          }
          data = await response.json();
          console.log("Model data retrieved:", data);
        } else {
          const resp = await request_adapter({
            url: "https://openrouter.ai/api/v1/models"
          });
          data = await resp.json;
        }
        return data.data.map((model) => ({
          model_name: model.id,
          key: model.id,
          max_input_tokens: model.context_length,
          description: model.name,
          actions: model.description.includes("tool use") || model.description.includes("function call"),
          multimodal: model.architecture.modality === "multimodal",
          raw: model
        }));
      } catch (error) {
        console.error("Failed to fetch model data:", error);
        return [];
      }
    }
    exports.fetch_open_router_models = fetch_open_router_models;
  }
});

// ../jsbrains/smart-chat-model/models/openai.js
var require_openai = __commonJS({
  "../jsbrains/smart-chat-model/models/openai.js"(exports) {
    var model_context = {
      "gpt-3.5-turbo-0125": {
        "context": 16385,
        "max_out": 4096
      },
      "gpt-3.5-turbo-0301": {
        "context": 4097,
        "max_out": 4097
      },
      "gpt-3.5-turbo-0613": {
        "context": 4097,
        "max_out": 4097
      },
      "gpt-3.5-turbo-1106": {
        "context": 16385,
        "max_out": 4096
      },
      "gpt-3.5-turbo-16k": {
        "context": 16385,
        "max_out": 16385
      },
      "gpt-3.5-turbo-16k-0613": {
        "context": 16385,
        "max_out": 16385
      },
      "gpt-4-0125-preview": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-0314": {
        "context": 8192,
        "max_out": 8192
      },
      "gpt-4-0613": {
        "context": 8192,
        "max_out": 8192
      },
      "gpt-4-1106-preview": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-1106-vision-preview": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-32k-0314": {
        "context": 32768,
        "max_out": 32768
      },
      "gpt-4-32k-0613": {
        "context": 32768,
        "max_out": 32768
      },
      "gpt-4-turbo-2024-04-09": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-turbo-preview": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-vision-preview": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-3.5-turbo": {
        "context": 16385,
        "max_out": 4096
      },
      "gpt-4-turbo": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-32k": {
        "context": 32768,
        "max_out": 32768
      },
      "gpt-4o": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4": {
        "context": 8192,
        "max_out": 8192
      }
    };
    async function fetch_openai_models(api_key, request_adapter = null) {
      if (!api_key) {
        console.error("No API key provided");
        return [];
      }
      try {
        let data;
        if (!request_adapter) {
          console.log("Using fetch");
          const response = await fetch("https://api.openai.com/v1/models", {
            headers: {
              "Authorization": `Bearer ${api_key}`
            }
          });
          if (!response.ok) {
            throw new Error("Network response was not ok");
          }
          data = await response.json();
          console.log("Model data retrieved:", data);
        } else {
          console.log("Using request adapter");
          const resp = await request_adapter({
            url: "https://api.openai.com/v1/models",
            headers: {
              "Authorization": `Bearer ${api_key}`
            }
          });
          data = await resp.json;
        }
        return data.data.filter((model) => model.id.startsWith("gpt-") && !model.id.includes("-instruct")).map((model) => {
          const out = {
            model_name: model.id,
            key: model.id,
            multimodal: model.id.includes("vision") || model.id.includes("gpt-4-turbo") || model.id.startsWith("gpt-4o")
          };
          const m = Object.entries(model_context).find((m2) => m2[0] === model.id || model.id.startsWith(m2[0] + "-"));
          if (m) {
            out.max_input_tokens = m[1].context;
            out.description = `context: ${m[1].context}, output: ${m[1].max_out}`;
          }
          return out;
        });
      } catch (error) {
        console.error("Failed to fetch model data:", error);
        return [];
      }
    }
    exports.fetch_openai_models = fetch_openai_models;
  }
});

// ../jsbrains/smart-chat-model/models/google_gemini.js
var require_google_gemini = __commonJS({
  "../jsbrains/smart-chat-model/models/google_gemini.js"(exports) {
    async function fetch_google_gemini_models(api_key, request_adapter = null) {
      if (!api_key) {
        console.error("No API key provided");
        return [];
      }
      try {
        let data;
        if (!request_adapter) {
          const response = await fetch("https://generativelanguage.googleapis.com/v1beta/models?key=" + api_key);
          if (!response.ok) {
            throw new Error("Network response was not ok");
          }
          data = await response.json();
          console.log("Model data retrieved:", data);
        } else {
          const resp = await request_adapter({
            url: "https://generativelanguage.googleapis.com/v1beta/models?key=" + api_key
          });
          console.log(JSON.stringify(resp));
          data = await resp.json;
        }
        return data.models.filter((model) => model.name.startsWith("models/gemini")).map((model) => {
          const out = {
            model_name: model.name.split("/").pop(),
            key: model.name.split("/").pop(),
            max_input_tokens: model.inputTokenLimit,
            max_output_tokens: model.maxOutputTokens,
            description: model.description,
            multimodal: model.name.includes("vision") || model.description.includes("multimodal"),
            raw: model
          };
          return out;
        });
      } catch (error) {
        console.error("Failed to fetch model data:", error);
        return [];
      }
    }
    exports.fetch_google_gemini_models = fetch_google_gemini_models;
  }
});

// ../jsbrains/smart-chat-model/models/cohere.js
var require_cohere2 = __commonJS({
  "../jsbrains/smart-chat-model/models/cohere.js"(exports) {
    async function fetch_cohere_models(api_key, request_adapter = null) {
      if (!api_key) {
        console.error("No API key provided");
        return [];
      }
      try {
        let data;
        if (!request_adapter) {
          const response = await fetch("https://api.cohere.ai/v1/models", {
            headers: {
              "Authorization": `Bearer ${api_key}`
            }
          });
          if (!response.ok) {
            throw new Error("Network response was not ok");
          }
          data = await response.json();
          console.log("Model data retrieved:", data);
        } else {
          const resp = await request_adapter({
            url: "https://api.cohere.ai/v1/models",
            headers: {
              "Authorization": `Bearer ${api_key}`
            }
          });
          data = await resp.json;
        }
        console.log("Model data retrieved:", data);
        return data.models.filter((model) => model.name.startsWith("command-")).map((model) => {
          const out = {
            model_name: model.name,
            key: model.name,
            max_input_tokens: model.context_length,
            tokenizer_url: model.tokenizer_url,
            finetuned: model.finetuned,
            description: `Max input tokens: ${model.context_length}, Finetuned: ${model.finetuned}`
          };
          return out;
        });
      } catch (error) {
        console.error("Failed to fetch model data:", error);
        return [];
      }
    }
    exports.fetch_cohere_models = fetch_cohere_models;
  }
});

// ../jsbrains/smart-chat-model/models/anthropic.js
var require_anthropic2 = __commonJS({
  "../jsbrains/smart-chat-model/models/anthropic.js"(exports) {
    async function fetch_anthropic_models() {
      return [
        {
          "key": "claude-3-opus-20240229",
          "model_name": "claude-3-opus-20240229",
          "description": "Anthropic's Claude Opus",
          "max_input_tokens": 2e5,
          "max_output_tokens": 4e3,
          "multimodal": true
        },
        {
          key: "claude-3-5-sonnet-20240620",
          "model_name": "claude-3.5-sonnet-20240620",
          "description": "Anthropic's Claude Sonnet",
          "max_input_tokens": 2e5,
          "max_output_tokens": 4e3,
          "multimodal": true
        },
        {
          key: "claude-3-haiku-20240307",
          "model_name": "claude-3-haiku-20240307",
          "description": "Anthropic's Claude Haiku",
          "max_input_tokens": 2e5,
          "max_output_tokens": 4e3,
          "multimodal": true
        },
        {
          key: "claude-3-sonnet-20240229",
          "model_name": "claude-3-sonnet-20240229",
          "description": "Anthropic's Claude Sonnet",
          "max_input_tokens": 2e5,
          "max_output_tokens": 4e3,
          "multimodal": true
        }
      ];
    }
    exports.fetch_anthropic_models = fetch_anthropic_models;
  }
});

// ../jsbrains/smart-chat-model/models/fetch.js
var require_fetch = __commonJS({
  "../jsbrains/smart-chat-model/models/fetch.js"(exports) {
    var { fetch_open_router_models } = require_open_router2();
    var { fetch_openai_models } = require_openai();
    var { fetch_google_gemini_models } = require_google_gemini();
    var { fetch_cohere_models } = require_cohere2();
    var { fetch_anthropic_models } = require_anthropic2();
    exports.open_router = fetch_open_router_models;
    exports.openai = fetch_openai_models;
    exports.google_gemini = fetch_google_gemini_models;
    exports.cohere = fetch_cohere_models;
    exports.anthropic = fetch_anthropic_models;
  }
});

// ../jsbrains/smart-chat-model/smart_chat_model.js
var require_smart_chat_model = __commonJS({
  "../jsbrains/smart-chat-model/smart_chat_model.js"(exports) {
    var adapters = require_adapters();
    var platforms = require_platforms();
    var { is_valid_tool_call } = require_is_valid_tool_call();
    var { SmartStreamer } = require_streamer();
    var fetch_models = require_fetch();
    var SmartChatModel2 = class {
      /**
       * Constructs an instance of SmartChatModel with specified environment, model key, and options.
       * @param {Object} main - The main environment context, typically containing configurations and state.
       * @param {string} platform_key - Key to select the specific model configuration from models.json.
       * @param {Object} model_config - Optional parameters to override model configurations.
       */
      constructor(main, platform_key, model_config = {}) {
        this.env = main;
        this.main = this.env;
        this.config = {
          ...platforms[platform_key] || {},
          ...model_config
          // override default platform config
        };
        console.log(JSON.stringify(this.config));
        this.platform_key = platform_key;
        this.active_stream = null;
        this._request_adapter = null;
        this.platforms = platforms;
        if (this.config.adapter)
          this.adapter = new adapters[this.config.adapter](this);
        if (this.adapter)
          console.log("has chat model adapter");
      }
      static get models() {
        return platforms;
      }
      // DEPRECATED (confusing name)
      // 
      static get platforms() {
        return Object.keys(platforms).map((key) => ({
          key,
          ...platforms[key]
        }));
      }
      get platform() {
        return platforms[this.platform_key];
      }
      get default_opts() {
        return {
          temperature: 0.3,
          top_p: 1,
          presence_penalty: 0,
          frequency_penalty: 0,
          n: 1,
          model: this.model_name,
          max_tokens: this.max_output_tokens
        };
      }
      async request_middlewares(opts) {
        return opts;
      }
      /**
       * Completes the chat interaction by processing the provided options, making an API request, and handling the response.
       * This method supports both streaming and non-streaming responses, and can handle tool calls if specified in the response.
       *
       * @param {Object} opts - The options for the chat completion which may include settings like temperature, max tokens, etc.
       * @param {boolean} render - Flag to determine if the response should be rendered in the UI.
       * @returns {Promise<string|void>} - Returns the chat response content or handles tool outputs recursively. In case of errors, it may return an error message.
       */
      async complete(opts = {}, render = true) {
        const prepared_opts = await this.prepare_options(opts);
        const request = this.create_request(prepared_opts);
        try {
          if (prepared_opts.stream) {
            return await this.handle_streaming_request(request, render);
          }
          return await this.handle_non_streaming_request(request, prepared_opts, render);
        } catch (err) {
          return this.handle_error(err, render);
        }
      }
      async prepare_options(opts) {
        var _a, _b, _c;
        if (!this.base_model_config) {
          this.base_model_config = await this.get_base_model_config();
          this.config = {
            ...this.base_model_config,
            ...this.config
          };
        }
        const prepared_opts = {
          ...this.default_opts,
          messages: ((_b = await ((_a = this.current) == null ? void 0 : _a.get_chat_ml())) == null ? void 0 : _b.messages) || [],
          ...opts
        };
        if (prepared_opts.stream !== false && this.config.streaming && !((_c = this.current) == null ? void 0 : _c.tool_choice)) {
          prepared_opts.stream = true;
        } else {
          prepared_opts.stream = false;
        }
        return this.request_middlewares(JSON.parse(JSON.stringify(prepared_opts)));
      }
      create_request(opts) {
        var _a, _b;
        const req = {
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${this.api_key}`
          },
          method: "POST"
        };
        if (this.config.headers) {
          req.headers = { ...req.headers, ...this.config.headers };
        }
        if (this.config.api_key_header) {
          if (this.config.api_key_header !== "none") {
            req.headers[this.config.api_key_header] = this.api_key;
          }
          delete req.headers.Authorization;
        }
        const body = typeof ((_a = this.env.actions) == null ? void 0 : _a.prepare_request_body) === "function" ? this.env.actions.prepare_request_body(opts) : { ...opts };
        req.body = JSON.stringify(typeof ((_b = this.adapter) == null ? void 0 : _b.prepare_request_body) === "function" ? this.adapter.prepare_request_body(body) : body);
        return req;
      }
      async handle_streaming_request(request, render) {
        return this.stream(request);
      }
      async handle_non_streaming_request(request, opts, render) {
        const resp_json = await this.request(request);
        if (resp_json.error) {
          return this.handle_api_error(resp_json.error, render);
        }
        const tool_call = this.get_tool_call(resp_json);
        if (tool_call) {
          return this.handle_tool_call(tool_call, opts, render);
        }
        const message_content = this.get_message_content(resp_json);
        if (render) {
          this.done_handler(message_content);
        }
        return message_content;
      }
      handle_api_error(error, render) {
        console.error(error);
        if (render) {
          this.done_handler("*API Error. See console logs for details.*");
        }
        return "*API Error. See console logs for details.*";
      }
      async handle_tool_call(tool_call, opts, render) {
        var _a, _b;
        if ((_b = (_a = this.env.chats) == null ? void 0 : _a.current) == null ? void 0 : _b.tool_choice) {
          this.env.chats.current.tool_choice = null;
        }
        const tool_name = this.get_tool_name(tool_call);
        const tool_call_content = this.get_tool_call_content(tool_call);
        const tools = opts.tools || [];
        const tool = tools.find((t) => t.function.name === tool_name);
        const tool_handler = this.get_tool_handler(tool_name);
        if (!tool_handler || !is_valid_tool_call(tool, tool_call_content)) {
          return this.handle_invalid_tool_call(tool_name, tool_call_content);
        }
        await this.add_tool_call_to_chat(tool_name, tool_call_content);
        const tool_output = await tool_handler(this.env, tool_call_content);
        if (tool_output) {
          await this.current.add_tool_output(tool_name, tool_output);
          this.current.tool_choice = "none";
          return this.complete({});
        }
      }
      handle_invalid_tool_call(tool_name, tool_call_content) {
        console.warn(`Tool ${tool_name} not found or invalid, returning tool_call_content`);
        console.log({ tool_call_content });
        return tool_call_content;
      }
      async add_tool_call_to_chat(tool_name, tool_call_content) {
        var _a;
        if (typeof ((_a = this.current) == null ? void 0 : _a.add_message) === "function") {
          await this.current.add_message({
            role: "assistant",
            tool_calls: [{
              function: {
                name: tool_name,
                arguments: JSON.stringify(tool_call_content)
              }
            }]
          });
        }
      }
      handle_error(err, render) {
        console.error(err);
        if (render) {
          this.done_handler("*An error occurred. See console logs for details.*");
        }
        return "*An error occurred. See console logs for details.*";
      }
      // HANDLE TOOLS
      /**
       * Retrieves the tool handler function based on the tool name from the environment's actions.
       * This method can be overridden to use custom logic for handling tools.
       * 
       * @param {string} tool_name - The name of the tool for which the handler is to be retrieved.
       * @returns {Function} The handler function for the specified tool.
       */
      get_tool_handler(tool_name) {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.env.actions) == null ? void 0 : _a.actions) == null ? void 0 : _b[tool_name]) == null ? void 0 : _c.handler;
      }
      /**
       * Extracts the tool call information from a JSON response. This method supports adapter-specific logic.
       * If no adapter method is provided, it defaults to the expected OpenAI JSON format.
       * 
       * @param {Object} json - The JSON response from which to extract the tool call.
       * @returns {Object} The first tool call found in the response.
       */
      get_tool_call(json) {
        var _a, _b, _c;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.get_tool_call) === "function")
          return this.adapter.get_tool_call(json);
        return (_c = (_b = json.choices) == null ? void 0 : _b[0].message.tool_calls) == null ? void 0 : _c[0];
      }
      /**
       * Determines the tool name from a tool call object. Supports adapter-specific implementations.
       * Defaults to extracting the name directly from the tool call structure.
       * 
       * @param {Object} tool_call - The tool call object from which to extract the tool name.
       * @returns {string} The name of the tool.
       */
      get_tool_name(tool_call) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.get_tool_name) === "function")
          return this.adapter.get_tool_name(tool_call);
        return tool_call.function.name;
      }
      /**
       * Extracts the tool call content from a tool call object. Supports adapter-specific logic.
       * Defaults to parsing the 'arguments' field of the tool call function as JSON.
       * 
       * @param {Object} tool_call - The tool call object from which to extract the content.
       * @returns {Object} The parsed arguments of the tool call.
       */
      get_tool_call_content(tool_call) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.get_tool_call_content) === "function")
          return this.adapter.get_tool_call_content(tool_call);
        return JSON.parse(tool_call.function.arguments);
      }
      // HANDLE MESSAGES
      /**
       * Retrieves the message object from a JSON response. Supports adapter-specific implementations.
       * Defaults to handling both OpenAI and Ollama formats by checking for message structures in 'choices'.
       * 
       * @param {Object} json - The JSON response from which to extract the message.
       * @returns {Object} The message object extracted from the response.
       */
      get_message(json) {
        var _a, _b;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.get_message) === "function")
          return this.adapter.get_message(json);
        return ((_b = json.choices) == null ? void 0 : _b[0].message) || json.message;
      }
      /**
       * Extracts the content of a message from a JSON response. Supports adapter-specific implementations.
       * This method relies on `get_message` to first retrieve the message object.
       * 
       * @param {Object} json - The JSON response from which to extract the message content.
       * @returns {string} The content of the message.
       */
      get_message_content(json) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.get_message_content) === "function")
          return this.adapter.get_message_content(json);
        return this.get_message(json).content;
      }
      async request(req) {
        req.url = this.endpoint;
        req.throw = false;
        const resp = this._request_adapter ? await this._request_adapter(req) : await fetch(this.endpoint, req);
        console.log(resp);
        const resp_json = await this.get_resp_json(resp);
        console.log(resp_json);
        return resp_json;
      }
      async get_resp_json(resp) {
        return typeof resp.json === "function" ? await resp.json() : await resp.json;
      }
      get request_adapter() {
        return this._request_adapter;
      }
      async stream(req) {
        console.log("Streaming Request: ");
        console.log(req);
        const full_text = await new Promise((resolve, reject) => {
          try {
            this.active_stream = new SmartStreamer(this.endpoint_streaming, req);
            let curr_text = "";
            this.active_stream.addEventListener("message", (e) => {
              if (this.is_end_of_stream(e)) {
                this.stop_stream();
                return resolve(curr_text);
              }
              let text_chunk = this.get_text_chunk_from_stream(e);
              if (!text_chunk)
                return;
              curr_text += text_chunk;
              this.chunk_handler(text_chunk);
            });
            this.active_stream.addEventListener("readystatechange", (e) => {
              if (e.readyState >= 2)
                console.log("ReadyState: " + e.readyState);
            });
            this.active_stream.addEventListener("error", (e) => {
              console.error(e);
              this.done_handler("*API Error. See console logs for details.*");
              this.stop_stream();
              reject(e);
            });
            this.active_stream.stream();
          } catch (err) {
            console.error(err);
            this.stop_stream();
            reject(err);
          }
        });
        this.done_handler(full_text);
        return full_text;
      }
      get_text_chunk_from_stream(event) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.get_text_chunk_from_stream) === "function")
          return this.adapter.get_text_chunk_from_stream(event);
        let resp = null;
        let text_chunk = "";
        try {
          resp = JSON.parse(event.data);
          text_chunk = resp.choices[0].delta.content;
        } catch (err) {
          console.log(err);
          console.log(event.data);
          if (event.data.indexOf("}{") > -1)
            event.data = event.data.replace(/}{/g, "},{");
          resp = JSON.parse(`[${event.data}]`);
          resp.forEach((r) => {
            if (r.choices)
              text_chunk += r.choices[0].delta.content;
          });
        }
        return text_chunk;
      }
      is_end_of_stream(event) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.is_end_of_stream) === "function")
          return this.adapter.is_end_of_stream(event);
        return event.data === "[DONE]";
      }
      stop_stream() {
        if (this.active_stream) {
          this.active_stream.end();
          this.active_stream = null;
        }
      }
      done_handler(full_str) {
        if (typeof this.main.done_handler === "function")
          this.main.done_handler(full_str);
      }
      chunk_handler(text_chunk) {
        if (typeof this.main.chunk_handler === "function")
          this.main.chunk_handler(text_chunk);
      }
      async count_tokens(input) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.count_tokens) === "function")
          return await this.adapter.count_tokens(input);
        return this.estimate_tokens(input);
      }
      estimate_tokens(input) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.estimate_tokens) === "function")
          return this.adapter.estimate_tokens(input);
        if (typeof input === "object")
          input = JSON.stringify(input);
        return input.length / 4;
      }
      async test_api_key() {
        console.log(this.api_key);
        try {
          const request = {
            messages: [
              { role: "user", content: "Hello" }
            ],
            temperature: 0,
            max_tokens: 100,
            stream: false,
            n: 1
          };
          if (this.config.fetch_models) {
            request.model = this.config.default_model;
          }
          const resp = await this.complete(request, false);
          console.log(resp);
          if (!resp)
            return false;
          return true;
        } catch (err) {
          console.error(err);
          return false;
        }
      }
      async get_models() {
        var _a;
        if (!this.api_key) {
          console.warn(`No API key found for ${this.platform_key}. Cannot retrieve models.`);
          return [];
        }
        if (((_a = this.platforms[this.platform_key]) == null ? void 0 : _a.fetch_models) && typeof fetch_models[this.platform_key] === "function") {
          const models = await fetch_models[this.platform_key](this.api_key, this._request_adapter);
          if (models) {
            models.sort((a, b) => a.model_name.localeCompare(b.model_name));
            return models;
          } else
            console.error(`No models found for ${this.platform_key}`, models);
        }
        return [];
      }
      async get_base_model_config() {
        const models = await this.get_models();
        return models.find((m) => m.key === this.model_name);
      }
      // getters
      get api_key() {
        return this.config.api_key;
      }
      get current() {
        var _a;
        return (_a = this.env.chats) == null ? void 0 : _a.current;
      }
      // use endpoint of combine protocol, hostname, port, and path
      get endpoint() {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.endpoint) !== "undefined")
          return this.adapter.endpoint.replace("MODEL_NAME", this.model_name);
        return this.config.endpoint || this.config.protocol + "://" + this.config.hostname + (this.config.port ? ":" + this.config.port : "") + this.endpoint_path;
      }
      get endpoint_streaming() {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.endpoint_streaming) !== "undefined")
          return this.adapter.endpoint_streaming.replace("MODEL_NAME", this.model_name);
        return this.config.endpoint_streaming || this.endpoint;
      }
      get endpoint_path() {
        return this.config.path.startsWith("/") ? this.config.path : "/" + this.config.path;
      }
      get max_input_tokens() {
        return this.config.max_input_tokens;
      }
      get max_output_tokens() {
        return this.config.max_output_tokens;
      }
      get model_name() {
        return this.config.model_name || this.config.default_model;
      }
      get multimodal() {
        var _a;
        return typeof ((_a = this.adapter) == null ? void 0 : _a.multimodal) !== "undefined" ? this.adapter.multimodal : this.config.multimodal;
      }
    };
    exports.SmartChatModel = SmartChatModel2;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SmartMemosPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// SmartMemosAudioRecordModal.ts
var import_obsidian = require("obsidian");
var SmartMemosAudioRecordModal = class extends import_obsidian.Modal {
  constructor(app, handleAudioRecording, settings) {
    super(app);
    this.mediaRecorder = null;
    this.chunks = [];
    this.isRecording = false;
    this.intervalId = null;
    this.startTime = 0;
    this.elapsedTime = 0;
    this.isResetting = false;
    this.handleAudioRecording = handleAudioRecording;
    this.settings = settings;
  }
  onOpen() {
    const { contentEl, modalEl } = this;
    if (!contentEl || !modalEl) {
      console.error("contentEl or modalEl is null");
      return;
    }
    modalEl.addClass("smart-memo-recording");
    const headerTimerContainer = contentEl.createDiv({ cls: "smart-memo-header-timer-container" });
    const header = headerTimerContainer.createEl("h2", { text: "Recording...", cls: "smart-memo-recording-header" });
    this.timer = headerTimerContainer.createEl("div", { cls: "smart-memo-timer", text: "00:00" });
    contentEl.addClass("smart-memo-audio-record-modal-content");
    const redDotContainer = contentEl.createDiv({ cls: "smart-memo-red-dot-container" });
    this.redDot = redDotContainer.createDiv({ cls: "smart-memo-red-dot" });
    const controlGroupWrapper = contentEl.createDiv({ cls: "smart-memo-control-group-wrapper" });
    const controlGroup = controlGroupWrapper.createDiv({ cls: "smart-memo-modal-button-group" });
    const playPauseButton = controlGroup.createEl("button", { cls: "smart-memo-modal-button smart-memo-flex" });
    const stopButton = controlGroup.createEl("button", { cls: "smart-memo-modal-button smart-memo-flex" });
    (0, import_obsidian.setIcon)(playPauseButton, "pause");
    (0, import_obsidian.setIcon)(stopButton, "square");
    stopButton.addEventListener("click", async () => {
      const audioFile = await this.stopRecording();
      this.handleAudioRecording(audioFile, false, this.keepAudioCheckbox.checked, this.includeAudioFileLinkCheckbox.checked);
    });
    playPauseButton.addEventListener("click", () => {
      if (this.isRecording) {
        this.pauseRecording();
        (0, import_obsidian.setIcon)(playPauseButton, "circle");
        header.textContent = "Paused";
        modalEl.addClass("smart-memo-paused");
        modalEl.removeClass("smart-memo-recording");
      } else {
        this.resumeOrStartRecording();
        (0, import_obsidian.setIcon)(playPauseButton, "pause");
        header.textContent = "Recording...";
        modalEl.removeClass("smart-memo-paused");
        modalEl.addClass("smart-memo-recording");
      }
      this.isRecording = !this.isRecording;
    });
    const transcribeButton = controlGroupWrapper.createEl("button", { cls: "smart-memo-modal-button smart-memo-full-width-button smart-memo-transcribe-button" });
    transcribeButton.addEventListener("click", async () => {
      const audioFile = await this.stopRecording();
      this.handleAudioRecording(audioFile, true, this.keepAudioCheckbox.checked, this.includeAudioFileLinkCheckbox.checked);
    });
    (0, import_obsidian.setIcon)(transcribeButton, "file-text");
    const buttonText = document.createTextNode(" Smart Transcribe");
    transcribeButton.appendChild(buttonText);
    const svgElement = transcribeButton.querySelector("svg");
    if (svgElement) {
      svgElement.style.marginRight = "10px";
    }
    const resetButton = contentEl.createEl("button", { cls: "smart-memo-modal-button smart-memo-full-width-button smart-memo-reset-button", text: "Restart" });
    resetButton.addEventListener("click", () => {
      this.hardReset();
      (0, import_obsidian.setIcon)(playPauseButton, "circle");
      header.textContent = "Ready to Record";
      this.isRecording = false;
      modalEl.addClass("smart-memo-paused");
      modalEl.removeClass("smart-memo-recording");
      this.redDot.classList.remove("smart-memo-pulse-animation");
    });
    const keepAudioContainer = contentEl.createDiv({ cls: "smart-memo-keep-audio-container" });
    this.keepAudioCheckbox = keepAudioContainer.createEl("input", { type: "checkbox", cls: "smart-memo-keep-audio-checkbox" });
    this.keepAudioCheckbox.checked = this.settings.keepAudio;
    const keepAudioLabel = keepAudioContainer.createEl("label", { text: "Keep Audio File", cls: "smart-memo-keep-audio-label" });
    keepAudioLabel.htmlFor = this.keepAudioCheckbox.id;
    const includeAudioFileLinkContainer = contentEl.createDiv({ cls: "smart-memo-include-audio-file-link-container" });
    this.includeAudioFileLinkCheckbox = includeAudioFileLinkContainer.createEl("input", { type: "checkbox", cls: "smart-memo-include-audio-file-link-checkbox" });
    this.includeAudioFileLinkCheckbox.checked = this.settings.includeAudioFileLink;
    const includeAudioFileLinkLabel = includeAudioFileLinkContainer.createEl("label", { text: "Include Audio File Player", cls: "smart-memo-include-audio-file-link-label" });
    includeAudioFileLinkLabel.htmlFor = this.includeAudioFileLinkCheckbox.id;
    this.startRecording();
    this.isRecording = true;
    this.redDot.classList.add("smart-memo-pulse-animation");
    const activeElement = document.activeElement;
    if (activeElement) {
      activeElement.blur();
    }
  }
  startRecording() {
    navigator.mediaDevices.getUserMedia({ audio: true }).then((stream) => {
      this.mediaRecorder = new MediaRecorder(stream);
      this.setupMediaRecorder();
      this.mediaRecorder.start(1e3);
      this.startTime = Date.now();
      this.startTimer();
      this.mediaRecorder.addEventListener("dataavailable", this.onDataAvailable.bind(this));
    }).catch((error) => {
      console.error("Error accessing microphone:", error);
      this.reject(error);
    });
  }
  setupMediaRecorder() {
    if (this.mediaRecorder) {
      this.mediaRecorder.addEventListener("stop", this.onStop.bind(this));
    }
  }
  onDataAvailable(event) {
    if (this.isResetting) {
      return;
    }
    this.chunks.push(event.data);
  }
  onStop() {
    if (this.isResetting) {
      this.isResetting = false;
      return;
    }
    const blob = new Blob(this.chunks, { type: "audio/wav" });
    if (this.resolve) {
      this.resolve(blob);
      this.close();
    } else {
      console.error("Resolve function is not defined");
    }
  }
  pauseRecording() {
    if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
      this.mediaRecorder.pause();
      this.stopTimer();
      this.elapsedTime += Date.now() - this.startTime;
      this.redDot.classList.remove("smart-memo-pulse-animation");
    }
  }
  resumeOrStartRecording() {
    if (this.mediaRecorder && this.mediaRecorder.state === "paused") {
      this.mediaRecorder.resume();
    } else {
      this.startRecording();
    }
    this.startTime = Date.now();
    this.startTimer();
    this.redDot.classList.add("smart-memo-pulse-animation");
  }
  hardReset() {
    if (this.mediaRecorder) {
      this.mediaRecorder.stop();
      this.mediaRecorder.onstop = null;
      this.mediaRecorder.ondataavailable = null;
      this.mediaRecorder = null;
    }
    this.isResetting = true;
    this.chunks = [];
    this.elapsedTime = 0;
    this.stopTimer();
    this.timer.textContent = "00:00";
    this.redDot.classList.remove("smart-memo-pulse-animation");
  }
  stopRecording() {
    return new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
      if (this.mediaRecorder) {
        this.mediaRecorder.addEventListener("stop", this.onStop.bind(this));
        this.mediaRecorder.stop();
        this.stopTimer();
      } else {
        resolve(null);
      }
    });
  }
  startTimer() {
    this.stopTimer();
    this.intervalId = window.setInterval(() => {
      const elapsedTimeInSeconds = Math.floor(this.elapsedTime / 1e3) + Math.floor((Date.now() - this.startTime) / 1e3);
      const minutes = Math.floor(elapsedTimeInSeconds / 60);
      const seconds = elapsedTimeInSeconds % 60;
      this.timer.textContent = `${this.padNumber(minutes)}:${this.padNumber(seconds)}`;
    }, 1e3);
  }
  stopTimer() {
    if (this.intervalId !== null) {
      window.clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }
  padNumber(num) {
    return num.toString().padStart(2, "0");
  }
  open() {
    super.open();
    return new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
};

// Utils.ts
var import_obsidian2 = require("obsidian");
async function saveFile(app, audioBlob, fileName, path) {
  try {
    const normalizedPath = (0, import_obsidian2.normalizePath)(path);
    const filePath = `${normalizedPath}/${fileName}`;
    await ensureDirectoryExists(app, normalizedPath);
    const arrayBuffer = await audioBlob.arrayBuffer();
    const uint8Array = new Uint8Array(arrayBuffer);
    const file = await app.vault.createBinary(filePath, uint8Array);
    if (!file) {
      throw new Error("File creation failed and returned null");
    }
    return file;
  } catch (error) {
    console.error("Error saving audio file:", error);
    throw error;
  }
}
async function ensureDirectoryExists(app, folderPath) {
  const parts = folderPath.split("/");
  let currentPath = "";
  for (const part of parts) {
    currentPath = currentPath ? `${currentPath}/${part}` : part;
    try {
      const folder = app.vault.getAbstractFileByPath(currentPath);
      if (!folder) {
        await app.vault.createFolder(currentPath);
      } else if (folder instanceof import_obsidian2.TFolder) {
        console.log(`Folder already exists: ${currentPath}`);
      } else {
        throw new Error(`${currentPath} is not a folder`);
      }
    } catch (error) {
      if (error.message.includes("Folder already exists")) {
        console.log(`Handled existing folder: ${currentPath}`);
      } else {
        console.error(`Error ensuring directory exists: ${error.message}`);
        throw error;
      }
    }
  }
}

// main.ts
var { SmartChatModel } = require_smart_chat_model();
var DEFAULT_SETTINGS = {
  model: "gpt-4-0613",
  apiKey: "",
  prompt: `You are an expert note-making AI for obsidian who specializes in the Linking Your Thinking (LYK) strategy.  The following is a transcription of recording of someone talking aloud or people in a conversation. There may be a lot of random things said given fluidity of conversation or thought process and the microphone's ability to pick up all audio.  Give me detailed notes in markdown language on what was said in the most easy-to-understand, detailed, and conceptual format.  Include any helpful information that can conceptualize the notes further or enhance the ideas, and then summarize what was said.  Do not mention "the speaker" anywhere in your response.  The notes your write should be written as if I were writting them. Finally, ensure to end with code for a mermaid chart that shows an enlightening concept map combining both the transcription and the information you added to it.  The following is the transcribed audio:

`,
  includeTranscript: true,
  recordingFilePath: "",
  keepAudio: true,
  includeAudioFileLink: false
};
var MODELS = [
  "gpt-3.5-turbo-16k",
  "gpt-3.5-turbo-0613",
  "text-davinci-003",
  "text-davinci-002",
  "code-davinci-002",
  "code-davinci-001",
  "gpt-4-0613",
  "gpt-4-32k-0613",
  "gpt-4o",
  "gpt-4o-mini"
];
var SmartMemosPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.apiKey = "sk-as123mkqwenjasdasdj12...";
    this.model = "gpt-4-0613";
  }
  async onload() {
    await this.loadSettings();
    const app_json = await this.app.vault.adapter.read(".obsidian/app.json");
    this.appJsonObj = JSON.parse(app_json);
    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
    this.addCommand({
      id: "open-transcript-modal",
      name: "Smart transcribe",
      editorCallback: (editor, view) => {
        this.commandGenerateTranscript(editor);
      }
    });
    this.addCommand({
      id: "record-smart-memo",
      name: "Record smart memo",
      editorCallback: async (editor, view) => {
        this.audioFile = await new SmartMemosAudioRecordModal(this.app, this.handleAudioRecording.bind(this), this.settings).open();
      }
    });
    this.registerMarkdownPostProcessor((el, ctx) => {
      const audioLinks = el.querySelectorAll('a.internal-link[data-href$=".wav"]');
      audioLinks.forEach((link) => {
        const href = link.getAttribute("data-href");
        if (href === null) {
          console.error("Failed to get the href attribute from the link element.");
          return;
        }
        const abstractFile = this.app.vault.getAbstractFileByPath(href);
        if (!(abstractFile instanceof import_obsidian3.TFile)) {
          console.error("The path does not point to a valid file in the vault.");
          return;
        }
        const audio = document.createElement("audio");
        audio.src = this.app.vault.getResourcePath(abstractFile);
        audio.controls = true;
        audio.addEventListener("loadedmetadata", () => {
          if (audio.parentNode) {
            const durationDisplay = document.createElement("span");
            durationDisplay.textContent = `Duration: ${audio.duration.toFixed(2)} seconds`;
            audio.parentNode.insertBefore(durationDisplay, audio.nextSibling);
          }
        });
        audio.load();
        link.replaceWith(audio);
      });
    });
    this.addRibbonIcon("microphone", "Record smart memo", async (evt) => {
      this.audioFile = await new SmartMemosAudioRecordModal(this.app, this.handleAudioRecording.bind(this), this.settings).open();
    });
    this.addSettingTab(new SmartMemosSettingTab(this.app, this));
  }
  // Add a new method to handle the audio recording and processing
  async handleAudioRecording(audioFile, transcribe, keepAudio, includeAudioFileLink) {
    try {
      console.log("Handling audio recording:", audioFile);
      if (!audioFile) {
        console.log("No audio was recorded.");
        return;
      }
      this.audioFile = audioFile;
      const fileName = `recording-${Date.now()}.wav`;
      const file = await saveFile(this.app, this.audioFile, fileName, this.settings.recordingFilePath);
      this.settings.keepAudio = keepAudio;
      this.settings.includeAudioFileLink = includeAudioFileLink;
      this.saveSettings();
      if (includeAudioFileLink && keepAudio) {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (activeView) {
          const editor = activeView.editor;
          const cursor = editor.getCursor();
          const link = `![[${file.path}]]`;
          editor.replaceRange(link, cursor);
          editor.replaceRange("", { line: cursor.line, ch: cursor.ch }, { line: cursor.line, ch: cursor.ch });
        }
      }
      if (transcribe) {
        this.transcribeRecording(file);
      }
    } catch (error) {
      console.error("Error handling audio recording:", error);
      new import_obsidian3.Notice("Failed to handle audio recording");
    }
  }
  // Add a new method to transcribe the audio file and generate text
  async transcribeRecording(audioFile) {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (!activeView) {
      console.error("No active Markdown view found.");
      return;
    }
    const editor = activeView.editor;
    this.app.vault.readBinary(audioFile).then((audioBuffer) => {
      if (this.writing) {
        new import_obsidian3.Notice("Generator is already in progress.");
        return;
      }
      this.writing = true;
      new import_obsidian3.Notice("Generating transcript...");
      const fileType = audioFile.extension;
      this.generateTranscript(audioBuffer, fileType).then((result) => {
        this.transcript = result;
        const prompt = this.settings.prompt + result;
        new import_obsidian3.Notice("Transcript generated...");
        this.generateText(prompt, editor, editor.getCursor("to").line);
        if (!this.settings.keepAudio) {
          this.app.vault.delete(audioFile);
        }
      }).catch((error) => {
        console.warn(error.message);
        new import_obsidian3.Notice(error.message);
        this.writing = false;
      });
    });
  }
  writeText(editor, LnToWrite, text) {
    const newLine = this.getNextNewLine(editor, LnToWrite);
    editor.setLine(newLine, "\n" + text.trim() + "\n");
    return newLine;
  }
  getNextNewLine(editor, Ln) {
    let newLine = Ln;
    while (editor.getLine(newLine).trim().length > 0) {
      if (newLine == editor.lastLine())
        editor.setLine(newLine, editor.getLine(newLine) + "\n");
      newLine++;
    }
    return newLine;
  }
  commandGenerateTranscript(editor) {
    const position = editor.getCursor();
    const text = editor.getRange({ line: 0, ch: 0 }, position);
    const regex = [
      /(?<=\[\[)(([^[\]])+)\.(mp3|mp4|mpeg|mpga|m4a|wav|webm)(?=]])/g,
      /(?<=\[(.*)]\()(([^[\]])+)\.(mp3|mp4|mpeg|mpga|m4a|wav|webm)(?=\))/g
    ];
    this.findFilePath(text, regex).then((path) => {
      const fileType = path.split(".").pop();
      if (fileType == void 0 || fileType == null || fileType == "") {
        new import_obsidian3.Notice("No audio file found");
      } else {
        this.app.vault.adapter.exists(path).then((exists) => {
          if (!exists)
            throw new Error(path + " does not exist");
          this.app.vault.adapter.readBinary(path).then((audioBuffer) => {
            if (this.writing) {
              new import_obsidian3.Notice("Generator is already in progress.");
              return;
            }
            this.writing = true;
            new import_obsidian3.Notice("Generating transcript...");
            this.generateTranscript(audioBuffer, fileType).then((result) => {
              this.transcript = result;
              const prompt = this.settings.prompt + result;
              new import_obsidian3.Notice("Transcript generated...");
              this.generateText(prompt, editor, editor.getCursor("to").line);
            }).catch((error) => {
              console.warn(error.message);
              new import_obsidian3.Notice(error.message);
              this.writing = false;
            });
          });
        });
      }
    }).catch((error) => {
      console.warn(error.message);
      new import_obsidian3.Notice(error.message);
    });
  }
  async findFilePath(text, regex) {
    console.log("dir text: ", text);
    let filename = "";
    let result;
    for (const reg of regex) {
      while ((result = reg.exec(text)) !== null) {
        filename = (0, import_obsidian3.normalizePath)(decodeURI(result[0])).trim();
      }
    }
    if (filename === "")
      throw new Error("No file found in the text.");
    console.log("file name: ", filename);
    const fullPath = filename;
    console.log("full path: ", fullPath);
    const fileExists = this.app.vault.getAbstractFileByPath(fullPath) instanceof import_obsidian3.TAbstractFile;
    if (fileExists)
      return fullPath;
    const allFiles = this.app.vault.getFiles();
    const foundFile = allFiles.find((file) => file.name === filename.split("/").pop());
    if (foundFile)
      return foundFile.path;
    throw new Error("File not found");
  }
  async generateTranscript(audioBuffer, filetype) {
    if (this.settings.apiKey.length <= 1)
      throw new Error("OpenAI API Key is not provided.");
    try {
      const decodedAudioData = await this.audioContext.decodeAudioData(audioBuffer);
      const targetSampleRate = 16e3;
      const downsampledAudioBuffer = await this.downsampleAudioBuffer(decodedAudioData, targetSampleRate);
      const chunkDuration = 600;
      const audioChunks = this.splitAudioBuffer(downsampledAudioBuffer, chunkDuration);
      let results = [];
      for (let i = 0; i < audioChunks.length; i++) {
        new import_obsidian3.Notice(`Transcribing chunk #${i + 1} of ${audioChunks.length}...`);
        const wavArrayBuffer = this.encodeAudioBufferToWav(audioChunks[i]);
        const sizeInMB = wavArrayBuffer.byteLength / (1024 * 1024);
        if (sizeInMB > 24) {
          throw new Error("Chunk size exceeds 25 MB limit.");
        }
        const formData = new FormData();
        const blob = new Blob([wavArrayBuffer], { type: "audio/wav" });
        formData.append("file", blob, "audio.wav");
        formData.append("model", "whisper-1");
        const response = await fetch("https://api.openai.com/v1/audio/transcriptions", {
          method: "POST",
          headers: {
            "Authorization": "Bearer " + this.settings.apiKey
          },
          body: formData
        });
        const result = await response.json();
        if (response.ok && result.text) {
          results.push(result.text);
        } else {
          throw new Error(`Error: ${result.error.message}`);
        }
        await new Promise((resolve) => setTimeout(resolve, 1e3));
      }
      return results.join(" ");
    } catch (error) {
      console.error("Transcription failed:", error);
      if (error.message.includes("401")) {
        throw new Error("OpenAI API Key is not valid.");
      } else if (error.message.includes("400")) {
        throw new Error("Bad Request. Please check the format of the request.");
      } else {
        throw error;
      }
    }
  }
  async downsampleAudioBuffer(audioBuffer, targetSampleRate) {
    const numberOfChannels = audioBuffer.numberOfChannels;
    const duration = audioBuffer.duration;
    const offlineContext = new OfflineAudioContext(numberOfChannels, targetSampleRate * duration, targetSampleRate);
    const bufferSource = offlineContext.createBufferSource();
    bufferSource.buffer = audioBuffer;
    bufferSource.connect(offlineContext.destination);
    bufferSource.start(0);
    const renderedBuffer = await offlineContext.startRendering();
    return renderedBuffer;
  }
  splitAudioBuffer(audioBuffer, chunkDuration) {
    const numberOfChannels = audioBuffer.numberOfChannels;
    const sampleRate = audioBuffer.sampleRate;
    const totalSamples = audioBuffer.length;
    const chunks = [];
    let offset = 0;
    const samplesPerChunk = Math.floor(chunkDuration * sampleRate);
    while (offset < totalSamples) {
      const chunkSamples = Math.min(samplesPerChunk, totalSamples - offset);
      const chunkBuffer = new AudioBuffer({
        length: chunkSamples,
        numberOfChannels,
        sampleRate
      });
      for (let channel = 0; channel < numberOfChannels; channel++) {
        const channelData = audioBuffer.getChannelData(channel).subarray(offset, offset + chunkSamples);
        chunkBuffer.copyToChannel(channelData, channel, 0);
      }
      chunks.push(chunkBuffer);
      offset += chunkSamples;
    }
    return chunks;
  }
  encodeAudioBufferToWav(audioBuffer) {
    const numChannels = audioBuffer.numberOfChannels;
    const sampleRate = audioBuffer.sampleRate;
    const format = 1;
    const bitDepth = 16;
    const numSamples = audioBuffer.length * numChannels;
    const buffer = new ArrayBuffer(44 + numSamples * 2);
    const view = new DataView(buffer);
    this.writeString(view, 0, "RIFF");
    view.setUint32(4, 36 + numSamples * 2, true);
    this.writeString(view, 8, "WAVE");
    this.writeString(view, 12, "fmt ");
    view.setUint32(16, 16, true);
    view.setUint16(20, format, true);
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * numChannels * bitDepth / 8, true);
    view.setUint16(32, numChannels * bitDepth / 8, true);
    view.setUint16(34, bitDepth, true);
    this.writeString(view, 36, "data");
    view.setUint32(40, numSamples * 2, true);
    let offset = 44;
    for (let i = 0; i < audioBuffer.length; i++) {
      for (let channel = 0; channel < numChannels; channel++) {
        let sample = audioBuffer.getChannelData(channel)[i];
        sample = Math.max(-1, Math.min(1, sample));
        sample = sample < 0 ? sample * 32768 : sample * 32767;
        view.setInt16(offset, sample, true);
        offset += 2;
      }
    }
    return buffer;
  }
  writeString(view, offset, string) {
    for (let i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  }
  async generateText(prompt, editor, currentLn, contextPrompt) {
    if (prompt.length < 1)
      throw new Error("Cannot find prompt.");
    if (this.settings.apiKey.length <= 1)
      throw new Error("OpenAI API Key is not provided.");
    prompt = prompt + ".";
    let newPrompt = prompt;
    const messages = [];
    messages.push({
      role: "user",
      content: newPrompt
    });
    new import_obsidian3.Notice(`Performing customized superhuman analysis...`);
    let LnToWrite = this.getNextNewLine(editor, currentLn);
    let lastLine = LnToWrite;
    const mock_env = {
      chunk_handler: (chunk) => {
        editor.setLine(LnToWrite, editor.getLine(LnToWrite) + chunk);
        if (chunk.includes("\n")) {
          LnToWrite = this.getNextNewLine(editor, LnToWrite);
        }
      },
      done_handler: (final_resp) => {
        LnToWrite = this.getNextNewLine(editor, lastLine);
        if (this.settings.includeTranscript) {
          editor.setLine(LnToWrite, editor.getLine(LnToWrite) + "\n# Transcript\n" + this.transcript);
        }
      }
    };
    const smart_chat_model = new SmartChatModel(
      mock_env,
      "openai",
      {
        api_key: this.settings.apiKey,
        model: this.settings.model
      }
    );
    const resp = await smart_chat_model.complete({ messages });
    this.writing = false;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var SmartMemosSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    new import_obsidian3.Setting(containerEl).setName("OpenAI api key").setDesc("Ex: sk-as123mkqwenjasdasdj12...").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.apiKey).setValue(this.plugin.settings.apiKey).onChange(async (value) => {
      this.plugin.settings.apiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Model").setDesc("Select the model to use for note-generation").addDropdown((dropdown) => {
      dropdown.addOptions(MODELS.reduce((models, model) => {
        models[model] = model;
        return models;
      }, {}));
      dropdown.setValue(this.plugin.settings.model);
      dropdown.onChange(async (value) => {
        this.plugin.settings.model = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Custom transcription-to-notes prompt").setDesc("Prompt that will be sent to Chatpgt right before adding your transcribed audio").addTextArea((text) => {
      if (text.inputEl) {
        text.inputEl.classList.add("smart-memo-text-box");
      }
      text.setPlaceholder(
        "Act as my personal secretary and worlds greatest entreprenuer and know I will put these notes in my personal obsidian where I have all my notes linked by categories, tags, etc. The following is a transcription of recording of someone talking aloud or people in a conversation. May be a lot of random things that are said given fluidity of conversation and the microphone ability to pick up all audio. Make outline of all topics and points within a structured hierarchy. Make sure to include any quantifiable information said such as the cost of headphones being $400.  Then go into to detail with summaries that explain things more eloquently. Finally, Create a mermaid chart code that complements the outline.\n\n"
      ).setValue(this.plugin.settings.prompt).onChange(async (value) => {
        this.plugin.settings.prompt = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Include Transcript").setDesc("Toggle this setting if you want to include the raw transcript on top of custom notes.").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeTranscript).onChange(async (value) => {
      this.plugin.settings.includeTranscript = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Recording File Path").setDesc('Specify the file path where recordings will be saved. Ex. If you want to put recordings in Resources folder then path is "Resources" (Defaults to root)').addText((text) => text.setPlaceholder("Ex. Resources (if in Resources)").setValue(this.plugin.settings.recordingFilePath || "").onChange(async (value) => {
      this.plugin.settings.recordingFilePath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Save Audio File").setDesc("Toggle this setting if you want to save/remove the audio file after it has been transcribed.").addToggle((toggle) => toggle.setValue(this.plugin.settings.keepAudio).onChange(async (value) => {
      this.plugin.settings.keepAudio = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Include Audio Player").setDesc("Toggle this setting if you want the audio file player to be displayed along with the transcription.").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeAudioFileLink).onChange(async (value) => {
      this.plugin.settings.includeAudioFileLink = value;
      await this.plugin.saveSettings();
    }));
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vanNicmFpbnMvc21hcnQtY2hhdC1tb2RlbC9hZGFwdGVycy9hbnRocm9waWMuanMiLCAiLi4vanNicmFpbnMvc21hcnQtY2hhdC1tb2RlbC9hZGFwdGVycy9jb2hlcmUuanMiLCAiLi4vanNicmFpbnMvc21hcnQtY2hhdC1tb2RlbC9hZGFwdGVycy9nZW1pbmkuanMiLCAiLi4vanNicmFpbnMvc21hcnQtY2hhdC1tb2RlbC9hZGFwdGVycy9vcGVuX3JvdXRlci5qcyIsICIuLi9qc2JyYWlucy9zbWFydC1jaGF0LW1vZGVsL2FkYXB0ZXJzLmpzIiwgIi4uL2pzYnJhaW5zL3NtYXJ0LWNoYXQtbW9kZWwvcGxhdGZvcm1zLmpzb24iLCAiLi4vanNicmFpbnMvc21hcnQtY2hhdC1tb2RlbC91dGlscy9pc192YWxpZF90b29sX2NhbGwuanMiLCAiLi4vanNicmFpbnMvc21hcnQtY2hhdC1tb2RlbC9zdHJlYW1lci5qcyIsICIuLi9qc2JyYWlucy9zbWFydC1jaGF0LW1vZGVsL21vZGVscy9vcGVuX3JvdXRlci5qcyIsICIuLi9qc2JyYWlucy9zbWFydC1jaGF0LW1vZGVsL21vZGVscy9vcGVuYWkuanMiLCAiLi4vanNicmFpbnMvc21hcnQtY2hhdC1tb2RlbC9tb2RlbHMvZ29vZ2xlX2dlbWluaS5qcyIsICIuLi9qc2JyYWlucy9zbWFydC1jaGF0LW1vZGVsL21vZGVscy9jb2hlcmUuanMiLCAiLi4vanNicmFpbnMvc21hcnQtY2hhdC1tb2RlbC9tb2RlbHMvYW50aHJvcGljLmpzIiwgIi4uL2pzYnJhaW5zL3NtYXJ0LWNoYXQtbW9kZWwvbW9kZWxzL2ZldGNoLmpzIiwgIi4uL2pzYnJhaW5zL3NtYXJ0LWNoYXQtbW9kZWwvc21hcnRfY2hhdF9tb2RlbC5qcyIsICJtYWluLnRzIiwgIlNtYXJ0TWVtb3NBdWRpb1JlY29yZE1vZGFsLnRzIiwgIlV0aWxzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKipcbiAqIEFudGhyb3BpY0FkYXB0ZXIgY2xhc3MgcHJvdmlkZXMgbWV0aG9kcyB0byBhZGFwdCB0aGUgY2hhdCBtb2RlbCBpbnRlcmFjdGlvbnMgc3BlY2lmaWNhbGx5IGZvciB0aGUgQW50aHJvcGljIG1vZGVsLlxuICogSXQgaW5jbHVkZXMgbWV0aG9kcyB0byBwcmVwYXJlIHJlcXVlc3QgYm9kaWVzLCBjb3VudCBhbmQgZXN0aW1hdGUgdG9rZW5zLCBhbmQgaGFuZGxlIHRvb2wgY2FsbHMgYW5kIG1lc3NhZ2VzLlxuICovXG5jbGFzcyBBbnRocm9waWNBZGFwdGVyIHtcbiAgLyoqXG4gICAqIFByZXBhcmVzIHRoZSByZXF1ZXN0IGJvZHkgZm9yIHRoZSBBbnRocm9waWMgQVBJIGJ5IGNvbnZlcnRpbmcgQ2hhdE1MIGZvcm1hdCB0byBhIGZvcm1hdCBjb21wYXRpYmxlIHdpdGggQW50aHJvcGljLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBvcHRpb25zIG9iamVjdCBjb250YWluaW5nIG1lc3NhZ2VzIGFuZCBvdGhlciBwYXJhbWV0ZXJzIGluIENoYXRNTCBmb3JtYXQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXF1ZXN0IGJvZHkgZm9ybWF0dGVkIGZvciB0aGUgQW50aHJvcGljIEFQSS5cbiAgICovXG4gIHByZXBhcmVfcmVxdWVzdF9ib2R5KG9wdHMpIHsgcmV0dXJuIGNoYXRtbF90b19hbnRocm9waWMob3B0cyk7IH1cbiAgLyoqXG4gICAqIENvdW50cyB0aGUgdG9rZW5zIGluIHRoZSBpbnB1dCBieSBlc3RpbWF0aW5nIHRoZW0sIGFzIHRoZSBBbnRocm9waWMgbW9kZWwgZG9lcyBub3QgcHJvdmlkZSBhIGRpcmVjdCBtZXRob2QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gaW5wdXQgLSBUaGUgaW5wdXQgdGV4dCBvciBvYmplY3QgdG8gY291bnQgdG9rZW5zIGluLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fSBUaGUgZXN0aW1hdGVkIG51bWJlciBvZiB0b2tlbnMgaW4gdGhlIGlucHV0LlxuICAgKi9cbiAgYXN5bmMgY291bnRfdG9rZW5zKGlucHV0KSB7XG4gICAgLy8gQ3VycmVudGx5LCB0aGUgQW50aHJvcGljIG1vZGVsIGRvZXMgbm90IHByb3ZpZGUgYSB3YXkgdG8gY291bnQgdG9rZW5zXG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVfdG9rZW5zKGlucHV0KTtcbiAgfVxuICAvKipcbiAgICogRXN0aW1hdGVzIHRoZSBudW1iZXIgb2YgdG9rZW5zIGluIHRoZSBpbnB1dCBiYXNlZCBvbiBhIHJvdWdoIGF2ZXJhZ2UgdG9rZW4gc2l6ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBpbnB1dCAtIFRoZSBpbnB1dCB0ZXh0IG9yIG9iamVjdCB0byBlc3RpbWF0ZSB0b2tlbnMgaW4uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBlc3RpbWF0ZWQgbnVtYmVyIG9mIHRva2Vucy5cbiAgICovXG4gIGVzdGltYXRlX3Rva2VucyhpbnB1dCl7XG4gICAgaWYodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JykgaW5wdXQgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgLy8gTm90ZTogVGhlIGRpdmlzaW9uIGJ5IDYgaXMgYSByb3VnaCBlc3RpbWF0ZSBiYXNlZCBvbiBvYnNlcnZlZCBhdmVyYWdlIHRva2VuIHNpemUuXG4gICAgcmV0dXJuIE1hdGguY2VpbChpbnB1dC5sZW5ndGggLyA2KTsgLy8gVXNlIE1hdGguY2VpbCBmb3IgYSBtb3JlIGFjY3VyYXRlIGNvdW50XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSBmaXJzdCB0b29sIGNhbGwgZnJvbSB0aGUgSlNPTiByZXNwb25zZSBjb250ZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiAtIFRoZSBKU09OIHJlc3BvbnNlIGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgdG9vbCBjYWxsLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IFRoZSBmaXJzdCB0b29sIGNhbGwgZm91bmQsIG9yIG51bGwgaWYgbm9uZSBleGlzdC5cbiAgICovXG4gIGdldF90b29sX2NhbGwoanNvbil7XG4gICAgcmV0dXJuIGpzb24uY29udGVudC5maW5kKG1zZyA9PiBtc2cudHlwZSA9PT0gJ3Rvb2xfdXNlJyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgaW5wdXQgY29udGVudCBvZiBhIHRvb2wgY2FsbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHRvb2xfY2FsbCAtIFRoZSB0b29sIGNhbGwgb2JqZWN0IGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgaW5wdXQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBpbnB1dCBvZiB0aGUgdG9vbCBjYWxsLlxuICAgKi9cbiAgZ2V0X3Rvb2xfY2FsbF9jb250ZW50KHRvb2xfY2FsbCl7XG4gICAgcmV0dXJuIHRvb2xfY2FsbC5pbnB1dDtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBuYW1lIG9mIHRoZSB0b29sIGZyb20gYSB0b29sIGNhbGwgb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gdG9vbF9jYWxsIC0gVGhlIHRvb2wgY2FsbCBvYmplY3QgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSBuYW1lLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgdG9vbC5cbiAgICovXG4gIGdldF90b29sX25hbWUodG9vbF9jYWxsKXtcbiAgICByZXR1cm4gdG9vbF9jYWxsLm5hbWU7XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSBmaXJzdCBtZXNzYWdlIGZyb20gdGhlIEpTT04gcmVzcG9uc2UgY29udGVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGpzb24gLSBUaGUgSlNPTiByZXNwb25zZSBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgdGhlIG1lc3NhZ2UuXG4gICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH0gVGhlIGZpcnN0IG1lc3NhZ2UgZm91bmQsIG9yIG51bGwgaWYgbm9uZSBleGlzdC5cbiAgICovXG4gIGdldF9tZXNzYWdlKGpzb24peyByZXR1cm4ganNvbi5jb250ZW50Py5bMF07IH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY29udGVudCBvZiB0aGUgZmlyc3QgbWVzc2FnZSBmcm9tIHRoZSBKU09OIHJlc3BvbnNlLlxuICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiAtIFRoZSBKU09OIHJlc3BvbnNlIGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgbWVzc2FnZSBjb250ZW50LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IFRoZSBjb250ZW50IG9mIHRoZSBmaXJzdCBtZXNzYWdlLCBvciBudWxsIGlmIG5vIG1lc3NhZ2UgaXMgZm91bmQuXG4gICAqL1xuICBnZXRfbWVzc2FnZV9jb250ZW50KGpzb24pIHsgcmV0dXJuIHRoaXMuZ2V0X21lc3NhZ2UoanNvbik/Llt0aGlzLmdldF9tZXNzYWdlKGpzb24pPy50eXBlXTsgfVxufVxuZXhwb3J0cy5BbnRocm9waWNBZGFwdGVyID0gQW50aHJvcGljQWRhcHRlcjtcbi8vIGh0dHBzOi8vZG9jcy5hbnRocm9waWMuY29tL2NsYXVkZS9yZWZlcmVuY2UvbWVzc2FnZXNfcG9zdFxuLyoqXG4gKiBDb252ZXJ0IGEgQ2hhdE1MIG9iamVjdCB0byBhbiBBbnRocm9waWMgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBDaGF0TUwgb2JqZWN0XG4gKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBjb252ZXJ0cyBhIENoYXRNTCBvYmplY3QgdG8gYW4gQW50aHJvcGljIG9iamVjdC4gSXQgZmlsdGVycyBvdXQgc3lzdGVtIG1lc3NhZ2VzIGFuZCBhZGRzIGEgc3lzdGVtIG1lc3NhZ2UgcHJpb3IgdG8gdGhlIGxhc3QgdXNlciBtZXNzYWdlLlxuICogQHJldHVybnMge09iamVjdH0gLSBUaGUgQW50aHJvcGljIG9iamVjdFxuICovXG5mdW5jdGlvbiBjaGF0bWxfdG9fYW50aHJvcGljKG9wdHMpIHtcbiAgbGV0IHRvb2xfY291bnRlciA9IDA7XG4gIGNvbnN0IG1lc3NhZ2VzID0gb3B0cy5tZXNzYWdlc1xuICAgIC5maWx0ZXIobXNnID0+IG1zZy5yb2xlICE9PSAnc3lzdGVtJylcbiAgICAubWFwKG0gPT4ge1xuICAgICAgaWYobS5yb2xlID09PSAndG9vbCcpe1xuICAgICAgICByZXR1cm4geyByb2xlOiAndXNlcicsIGNvbnRlbnQ6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAndG9vbF9yZXN1bHQnLFxuICAgICAgICAgICAgdG9vbF91c2VfaWQ6IGB0b29sLSR7dG9vbF9jb3VudGVyfWAsXG4gICAgICAgICAgICBjb250ZW50OiBtLmNvbnRlbnRcbiAgICAgICAgICB9XG4gICAgICAgIF19O1xuICAgICAgfVxuICAgICAgaWYobS5yb2xlID09PSAnYXNzaXN0YW50JyAmJiBtLnRvb2xfY2FsbHMpe1xuICAgICAgICB0b29sX2NvdW50ZXIrKztcbiAgICAgICAgY29uc3Qgb3V0ID0ge1xuICAgICAgICAgIHJvbGU6IG0ucm9sZSwgXG4gICAgICAgICAgY29udGVudDogbS50b29sX2NhbGxzLm1hcChjID0+ICh7XG4gICAgICAgICAgICB0eXBlOiAndG9vbF91c2UnLFxuICAgICAgICAgICAgaWQ6IGB0b29sLSR7dG9vbF9jb3VudGVyfWAsXG4gICAgICAgICAgICBuYW1lOiBjLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICBpbnB1dDogKHR5cGVvZiBjLmZ1bmN0aW9uLmFyZ3VtZW50cyA9PT0gJ3N0cmluZycpID8gSlNPTi5wYXJzZShjLmZ1bmN0aW9uLmFyZ3VtZW50cykgOiBjLmZ1bmN0aW9uLmFyZ3VtZW50c1xuICAgICAgICAgIH0pKVxuICAgICAgICB9O1xuICAgICAgICBpZihtLmNvbnRlbnQpe1xuICAgICAgICAgIGlmKHR5cGVvZiBtLmNvbnRlbnQgPT09ICdzdHJpbmcnKSBvdXQuY29udGVudC5wdXNoKHt0eXBlOiAndGV4dCcsIHRleHQ6IG0uY29udGVudH0pO1xuICAgICAgICAgIGVsc2UgbS5jb250ZW50LmZvckVhY2goYyA9PiBvdXQuY29udGVudC5wdXNoKGMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfVxuICAgICAgaWYodHlwZW9mIG0uY29udGVudCA9PT0gJ3N0cmluZycpIHJldHVybiB7IHJvbGU6IG0ucm9sZSwgY29udGVudDogbS5jb250ZW50IH07XG4gICAgICBpZihBcnJheS5pc0FycmF5KG0uY29udGVudCkpe1xuICAgICAgICBjb25zdCBjb250ZW50ID0gbS5jb250ZW50Lm1hcChjID0+IHtcbiAgICAgICAgICBpZihjLnR5cGUgPT09ICd0ZXh0JykgcmV0dXJuIHt0eXBlOiAndGV4dCcsIHRleHQ6IGMudGV4dH07XG4gICAgICAgICAgaWYoYy50eXBlID09PSAnaW1hZ2VfdXJsJyl7XG4gICAgICAgICAgICBjb25zdCBpbWFnZV91cmwgPSBjLmltYWdlX3VybC51cmw7XG4gICAgICAgICAgICBsZXQgbWVkaWFfdHlwZSA9IGltYWdlX3VybC5zcGxpdChcIjpcIilbMV0uc3BsaXQoXCI7XCIpWzBdO1xuICAgICAgICAgICAgaWYobWVkaWFfdHlwZSA9PT0gJ2ltYWdlL2pwZycpIG1lZGlhX3R5cGUgPSAnaW1hZ2UvanBlZyc7XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6ICdpbWFnZScsIHNvdXJjZToge3R5cGU6ICdiYXNlNjQnLCBtZWRpYV90eXBlOiBtZWRpYV90eXBlLCBkYXRhOiBpbWFnZV91cmwuc3BsaXQoXCIsXCIpWzFdfX07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgcm9sZTogbS5yb2xlLCBjb250ZW50IH07XG4gICAgICB9XG4gICAgICByZXR1cm4gbTtcbiAgICB9KVxuICA7XG4gIGNvbnN0IHsgbW9kZWwsIG1heF90b2tlbnMsIHRlbXBlcmF0dXJlLCB0b29scywgdG9vbF9jaG9pY2UgfSA9IG9wdHM7XG4gIC8vIERPOiBoYW5kbGVkIGJldHRlciAoU21hcnQgQ29ubmVjdGlvbnMgc3BlY2lmaWMpXG4gIC8vIGdldCBpbmRleCBvZiBsYXN0IHN5c3RlbSBtZXNzYWdlXG4gIGNvbnN0IGxhc3Rfc3lzdGVtX2lkeCA9IG9wdHMubWVzc2FnZXMuZmluZExhc3RJbmRleChtc2cgPT4gbXNnLnJvbGUgPT09ICdzeXN0ZW0nICYmIG1zZy5jb250ZW50LmluY2x1ZGVzKCctLS1CRUdJTicpKTtcbiAgaWYgKGxhc3Rfc3lzdGVtX2lkeCA+IC0xKSB7XG4gICAgY29uc3Qgc3lzdGVtX3Byb21wdCA9ICc8Y29udGV4dD5cXG4nICsgb3B0cy5tZXNzYWdlc1tsYXN0X3N5c3RlbV9pZHhdLmNvbnRlbnQgKyAnXFxuPC9jb250ZXh0Plxcbic7XG4gICAgbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV0uY29udGVudCA9IHN5c3RlbV9wcm9tcHQgKyBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXS5jb250ZW50O1xuICB9XG4gIGNvbnNvbGUubG9nKG1lc3NhZ2VzKTtcbiAgY29uc3Qgb3V0ID0ge1xuICAgIG1lc3NhZ2VzLFxuICAgIG1vZGVsLFxuICAgIG1heF90b2tlbnMsXG4gICAgdGVtcGVyYXR1cmUsXG4gIH1cbiAgaWYodG9vbHMpe1xuICAgIG91dC50b29scyA9IHRvb2xzLm1hcCh0b29sID0+ICh7XG4gICAgICBuYW1lOiB0b29sLmZ1bmN0aW9uLm5hbWUsXG4gICAgICBkZXNjcmlwdGlvbjogdG9vbC5mdW5jdGlvbi5kZXNjcmlwdGlvbixcbiAgICAgIGlucHV0X3NjaGVtYTogdG9vbC5mdW5jdGlvbi5wYXJhbWV0ZXJzLFxuICAgIH0pKTtcbiAgICBpZih0b29sX2Nob2ljZT8udHlwZSA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAvLyBhZGQgXCJVc2UgdGhlICR7dG9vbC5uYW1lfSB0b29sXCIgdG8gdGhlIGxhc3QgdXNlciBtZXNzYWdlXG4gICAgICBjb25zdCB0b29sX3Byb21wdCA9IGBVc2UgdGhlIFwiJHt0b29sX2Nob2ljZS5mdW5jdGlvbi5uYW1lfVwiIHRvb2whYDtcbiAgICAgIGNvbnN0IGxhc3RfdXNlcl9pZHggPSBvdXQubWVzc2FnZXMuZmluZExhc3RJbmRleChtc2cgPT4gbXNnLnJvbGUgPT09ICd1c2VyJyk7XG4gICAgICBvdXQubWVzc2FnZXNbbGFzdF91c2VyX2lkeF0uY29udGVudCArPSAnXFxuJyArIHRvb2xfcHJvbXB0O1xuICAgICAgb3V0LnN5c3RlbSA9IGBSZXF1aXJlZDogdXNlIHRoZSBcIiR7dG9vbF9jaG9pY2UuZnVuY3Rpb24ubmFtZX1cIiB0b29sIWA7XG4gICAgfVxuICB9XG4gIC8vIERPOiBoYW5kbGVkIGJldHRlciAoU21hcnQgQ29ubmVjdGlvbnMgc3BlY2lmaWMpXG4gIC8vIGlmIHN5c3RlbSBtZXNzYWdlIGV4aXN0cyBwcmlvciB0byBsYXN0X3N5c3RlbV9pZHggQU5EIGRvZXMgbm90IGluY2x1ZGUgXCItLS1CRUdJTlwiIHRoZW4gYWRkIHRvIGJvZHkuc3lzdGVtXG4gIGNvbnN0IGxhc3Rfbm9uX2NvbnRleHRfc3lzdGVtX2lkeCA9IG9wdHMubWVzc2FnZXMuZmluZExhc3RJbmRleChtc2cgPT4gbXNnLnJvbGUgPT09ICdzeXN0ZW0nICYmICFtc2cuY29udGVudC5pbmNsdWRlcygnLS0tQkVHSU4nKSk7XG4gIGlmKGxhc3Rfbm9uX2NvbnRleHRfc3lzdGVtX2lkeCA+IC0xKSBvdXQuc3lzdGVtID0gb3B0cy5tZXNzYWdlc1tsYXN0X25vbl9jb250ZXh0X3N5c3RlbV9pZHhdLmNvbnRlbnQ7XG4gIHJldHVybiBvdXQ7XG59XG5leHBvcnRzLmNoYXRtbF90b19hbnRocm9waWMgPSBjaGF0bWxfdG9fYW50aHJvcGljO1xuXG4iLCAiLyoqXG4gKiBDb2hlcmVBZGFwdGVyIGNsYXNzIGlzIGRlc2lnbmVkIHRvIGFkYXB0IHRoZSBTbWFydENoYXRNb2RlbCdzIGludGVyYWN0aW9uIHdpdGggdGhlIENvaGVyZSBBUEkuXG4gKiBJdCBwcm92aWRlcyBtZXRob2RzIHRvIHByZXBhcmUgcmVxdWVzdCBib2RpZXMsIGhhbmRsZSBzdHJlYW1pbmcgZGF0YSwgYW5kIGV4dHJhY3QgbWVzc2FnZSBjb250ZW50IGZyb20gcmVzcG9uc2VzLlxuICovXG5jbGFzcyBDb2hlcmVBZGFwdGVyIHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgQ2hhdE1MIG9iamVjdCB0byBhIGZvcm1hdCBzdWl0YWJsZSBmb3IgYSByZXF1ZXN0IHRvIHRoZSBDb2hlcmUgQVBJLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2hhdG1sIC0gVGhlIENoYXRNTCBvYmplY3QgY29udGFpbmluZyB0aGUgY2hhdCBoaXN0b3J5IGFuZCBvdGhlciBwYXJhbWV0ZXJzLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVxdWVzdCBib2R5IGZvcm1hdHRlZCBmb3IgdGhlIENvaGVyZSBBUEkuXG4gICAqL1xuICBwcmVwYXJlX3JlcXVlc3RfYm9keShjaGF0bWwpIHsgcmV0dXJuIGNoYXRtbF90b19jb2hlcmUoY2hhdG1sKTsgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyB0aGUgbWVzc2FnZSBjb250ZW50IGZyb20gYSBKU09OIHJlc3BvbnNlIGZyb20gdGhlIENvaGVyZSBBUEkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBqc29uIC0gVGhlIEpTT04gcmVzcG9uc2Ugb2JqZWN0IGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgdGV4dCBjb250ZW50LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZXh0cmFjdGVkIHRleHQgY29udGVudCBmcm9tIHRoZSByZXNwb25zZS5cbiAgICovXG4gIGdldF9tZXNzYWdlX2NvbnRlbnQoanNvbikgeyByZXR1cm4ganNvbi50ZXh0OyB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBzdHJlYW1pbmcgZGF0YSByZWNlaXZlZCBmcm9tIHRoZSBDb2hlcmUgQVBJIGFuZCBleHRyYWN0cyB0ZXh0IGNodW5rcy5cbiAgICogVGhpcyBtZXRob2QgaGFuZGxlcyB0aGUgYWNjdW11bGF0aW9uIG9mIHRleHQgZGF0YSBvdmVyIG11bHRpcGxlIGV2ZW50cyBhbmQgbWFuYWdlcyB0aGUgc3RhdGUgb2YgdGhlIHN0cmVhbS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdCBjb250YWluaW5nIHN0cmVhbWluZyBkYXRhLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgYWNjdW11bGF0ZWQgdGV4dCBjaHVuayBleHRyYWN0ZWQgZnJvbSB0aGUgc3RyZWFtLlxuICAgKi9cbiAgZ2V0X3RleHRfY2h1bmtfZnJvbV9zdHJlYW0oZXZlbnQpIHtcbiAgICBpZighdGhpcy5sYXN0X2xpbmVfaW5kZXgpIHRoaXMubGFzdF9saW5lX2luZGV4ID0gMDtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5sYXN0X2xpbmVfdGltZW91dCk7XG4gICAgdGhpcy5sYXN0X2xpbmVfdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmxhc3RfbGluZV9pbmRleCA9IDA7XG4gICAgfSwgMTAwMDApO1xuICAgIGNvbnN0IGRhdGEgPSBldmVudC5zb3VyY2UueGhyLnJlc3BvbnNlVGV4dDtcbiAgICAvLyBzcGxpdCBieSBuZXdsaW5lIGFuZCBnZXQgbGFzdFxuICAgIGNvbnN0IGxpbmVzID0gZGF0YS5zcGxpdCgnXFxuJykuc2xpY2UodGhpcy5sYXN0X2xpbmVfaW5kZXgpO1xuICAgIGNvbnNvbGUubG9nKGxpbmVzKTtcbiAgICB0aGlzLmxhc3RfbGluZV9pbmRleCArPSBsaW5lcy5sZW5ndGg7XG4gICAgY29uc3QgdGV4dF9jaHVuayA9IGxpbmVzXG4gICAgICAgIC5maWx0ZXIoKGxpbmUpID0+IGxpbmUudHJpbSgpICE9PSAnJylcbiAgICAgICAgLm1hcCgobGluZSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobGluZSk7XG4gICAgICAgICAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShsaW5lKTtcbiAgICAgICAgICAgIGlmKGpzb24uZXZlbnRfdHlwZSA9PT0gJ3N0cmVhbS1lbmQnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3N0cmVhbS1lbmQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZF9vZl9zdHJlYW0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZF9vZl9zdHJlYW0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ganNvbi50ZXh0O1xuICAgICAgICB9KVxuICAgICAgICAuam9pbignJyk7XG4gICAgY29uc29sZS5sb2codGV4dF9jaHVuayk7XG4gICAgcmV0dXJuIHRleHRfY2h1bms7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgZW5kIG9mIHRoZSBzdHJlYW0gaGFzIGJlZW4gcmVhY2hlZCBiYXNlZCBvbiB0aGUgZXZlbnQgZGF0YS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdCB0aGF0IG1heSBpbmRpY2F0ZSB0aGUgZW5kIG9mIHRoZSBzdHJlYW0uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBlbmQgb2YgdGhlIHN0cmVhbSBpcyBpbmRpY2F0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzX2VuZF9vZl9zdHJlYW0oZXZlbnQpIHsgcmV0dXJuIHRoaXMuZW5kX29mX3N0cmVhbTsgfVxufVxuZXhwb3J0cy5Db2hlcmVBZGFwdGVyID0gQ29oZXJlQWRhcHRlcjtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIENoYXRNTCBvYmplY3QgaW50byBhIGZvcm1hdCBzdWl0YWJsZSBmb3IgdGhlIENvaGVyZSBBUEkuXG4gKiBUaGlzIGZ1bmN0aW9uIHByZXBhcmVzIHRoZSBkYXRhIGJ5IHN0cnVjdHVyaW5nIGl0IGFjY29yZGluZyB0byB0aGUgcmVxdWlyZW1lbnRzIG9mIHRoZSBDb2hlcmUgQVBJLFxuICogaW5jbHVkaW5nIHRoZSBtb2RlbCB0byB1c2UsIHRoZSBjaGF0IGhpc3RvcnkgZXhjbHVkaW5nIHRoZSBsYXN0IHVzZXIgbWVzc2FnZSwgYW5kIHRoZSBsYXN0IG1lc3NhZ2Ugc2VwYXJhdGVseS5cbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IGNoYXRtbCAtIFRoZSBDaGF0TUwgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1vZGVsLCBtZXNzYWdlcywgYW5kIG90aGVyIHBhcmFtZXRlcnMgbGlrZSB0ZW1wZXJhdHVyZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBmb3JtYXR0ZWQgb2JqZWN0IGZvciB0aGUgQ29oZXJlIEFQSSByZXF1ZXN0LCBjb250YWluaW5nIHRoZSBtb2RlbCwgY2hhdCBoaXN0b3J5LCBsYXN0IG1lc3NhZ2UsIGFuZCB0ZW1wZXJhdHVyZS5cbiAqL1xuZnVuY3Rpb24gY2hhdG1sX3RvX2NvaGVyZShjaGF0bWwpIHtcbiAgICBjb25zdCBjb2hlcmUgPSB7XG4gICAgICAgIG1vZGVsOiBjaGF0bWwubW9kZWwsXG4gICAgICAgIC8vIHNraXAgbGFzdCB1c2VyIG1lc3NhZ2VcbiAgICAgICAgY2hhdF9oaXN0b3J5OiBjaGF0bWwubWVzc2FnZXNcbiAgICAgICAgICAgIC5zbGljZSgwLCAtMSlcbiAgICAgICAgICAgIC5tYXAoKG1lc3NhZ2UpID0+ICh7XG4gICAgICAgICAgICAgICAgcm9sZTogbWVzc2FnZS5yb2xlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHBhcnNlX21lc3NhZ2VfY29udGVudF90b19zdHJpbmcobWVzc2FnZSksXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgLFxuICAgICAgICBtZXNzYWdlOiBwYXJzZV9tZXNzYWdlX2NvbnRlbnRfdG9fc3RyaW5nKGNoYXRtbC5tZXNzYWdlc1tjaGF0bWwubWVzc2FnZXMubGVuZ3RoIC0gMV0pLFxuICAgICAgICB0ZW1wZXJhdHVyZTogY2hhdG1sLnRlbXBlcmF0dXJlLFxuICAgICAgICAvLyBzdHJlYW06IGNoYXRtbC5zdHJlYW0gLy8gY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcbiAgICB9O1xuICAgIHJldHVybiBjb2hlcmU7XG59XG5leHBvcnRzLmNoYXRtbF90b19jb2hlcmUgPSBjaGF0bWxfdG9fY29oZXJlO1xuXG5mdW5jdGlvbiBwYXJzZV9tZXNzYWdlX2NvbnRlbnRfdG9fc3RyaW5nKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShtZXNzYWdlLmNvbnRlbnQpID8gbWVzc2FnZS5jb250ZW50LmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ3RleHQnKS5tYXAoYyA9PiBjLnRleHQpLmpvaW4oJ1xcbicpIDogbWVzc2FnZS5jb250ZW50O1xufVxuXG4iLCAiLyoqXG4gKiBHZW1pbmlBZGFwdGVyIGNsYXNzIHByb3ZpZGVzIG1ldGhvZHMgdG8gYWRhcHQgdGhlIGNoYXQgbW9kZWwgaW50ZXJhY3Rpb25zIHNwZWNpZmljYWxseSBmb3IgdGhlIEdlbWluaSBtb2RlbC5cbiAqIEl0IGluY2x1ZGVzIG1ldGhvZHMgdG8gcHJlcGFyZSByZXF1ZXN0IGJvZGllcywgaGFuZGxlIHRvb2wgY2FsbHMgYW5kIG1lc3NhZ2VzLCBhbmQgbWFuYWdlIHN0cmVhbWluZyByZXNwb25zZXMuXG4gKi9cbmNsYXNzIEdlbWluaUFkYXB0ZXIge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIEdlbWluaUFkYXB0ZXIgaW5zdGFuY2Ugd2l0aCBhIHNwZWNpZmllZCBtb2RlbCBjb25maWd1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWwgLSBUaGUgbW9kZWwgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihtb2RlbCkgeyB0aGlzLm1vZGVsID0gbW9kZWw7IH1cblxuICAvKipcbiAgICogUHJlcGFyZXMgdGhlIHJlcXVlc3QgYm9keSBmb3IgdGhlIEdlbWluaSBBUEkgYnkgY29udmVydGluZyBDaGF0TUwgZm9ybWF0IHRvIGEgZm9ybWF0IGNvbXBhdGlibGUgd2l0aCBHZW1pbmkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5IC0gVGhlIG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5pbmcgbWVzc2FnZXMgYW5kIG90aGVyIHBhcmFtZXRlcnMgaW4gQ2hhdE1MIGZvcm1hdC5cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIHJlcXVlc3QgYm9keSBmb3JtYXR0ZWQgZm9yIHRoZSBHZW1pbmkgQVBJLlxuICAgKi9cbiAgcHJlcGFyZV9yZXF1ZXN0X2JvZHkoYm9keSkgeyByZXR1cm4gY2hhdG1sX3RvX2dlbWluaShib2R5KTsgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyB0aGUgZmlyc3QgdG9vbCBjYWxsIGZyb20gdGhlIEpTT04gcmVzcG9uc2UgY29udGVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGpzb24gLSBUaGUgSlNPTiByZXNwb25zZSBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgdGhlIHRvb2wgY2FsbC5cbiAgICogQHJldHVybnMge09iamVjdHxudWxsfSBUaGUgZmlyc3QgdG9vbCBjYWxsIGZvdW5kLCBvciBudWxsIGlmIG5vbmUgZXhpc3QuXG4gICAqL1xuICBnZXRfdG9vbF9jYWxsKGpzb24pIHsgcmV0dXJuIGpzb24uY2FuZGlkYXRlcz8uWzBdPy5jb250ZW50Py5wYXJ0cz8uWzBdPy5mdW5jdGlvbkNhbGw7IH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBuYW1lIG9mIHRoZSB0b29sIGZyb20gYSB0b29sIGNhbGwgb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gdG9vbF9jYWxsIC0gVGhlIHRvb2wgY2FsbCBvYmplY3QgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSBuYW1lLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IFRoZSBuYW1lIG9mIHRoZSB0b29sLCBvciBudWxsIGlmIG5vdCBhdmFpbGFibGUuXG4gICAqL1xuICBnZXRfdG9vbF9uYW1lKHRvb2xfY2FsbCkgeyByZXR1cm4gdG9vbF9jYWxsPy5uYW1lOyB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgaW5wdXQgY29udGVudCBvZiBhIHRvb2wgY2FsbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHRvb2xfY2FsbCAtIFRoZSB0b29sIGNhbGwgb2JqZWN0IGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgaW5wdXQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH0gVGhlIGlucHV0IG9mIHRoZSB0b29sIGNhbGwsIG9yIG51bGwgaWYgbm90IGF2YWlsYWJsZS5cbiAgICovXG4gIGdldF90b29sX2NhbGxfY29udGVudCh0b29sX2NhbGwpIHsgcmV0dXJuIHRvb2xfY2FsbD8uYXJnczsgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyB0aGUgZmlyc3QgbWVzc2FnZSBmcm9tIHRoZSBKU09OIHJlc3BvbnNlIGNvbnRlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBqc29uIC0gVGhlIEpTT04gcmVzcG9uc2UgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSBtZXNzYWdlLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IFRoZSBmaXJzdCBtZXNzYWdlIGZvdW5kLCBvciBudWxsIGlmIG5vbmUgZXhpc3QuXG4gICAqL1xuICBnZXRfbWVzc2FnZShqc29uKSB7IHJldHVybiBqc29uLmNhbmRpZGF0ZXM/LlswXTsgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGNvbnRlbnQgb2YgdGhlIGZpcnN0IG1lc3NhZ2UgZnJvbSB0aGUgSlNPTiByZXNwb25zZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGpzb24gLSBUaGUgSlNPTiByZXNwb25zZSBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgdGhlIG1lc3NhZ2UgY29udGVudC5cbiAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBUaGUgY29udGVudCBvZiB0aGUgZmlyc3QgbWVzc2FnZSwgb3IgbnVsbCBpZiBubyBtZXNzYWdlIGlzIGZvdW5kLlxuICAgKi9cbiAgZ2V0X21lc3NhZ2VfY29udGVudChqc29uKSB7IHJldHVybiB0aGlzLmdldF9tZXNzYWdlKGpzb24pPy5jb250ZW50Py5wYXJ0cy5tYXAocGFydCA9PiBwYXJ0LnRleHQpLmpvaW4oJycpOyB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgZXNjYXBlZCBuZXdsaW5lcyBpbiBhIHN0cmVhbWluZyB0ZXh0IGNodW5rLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgc3RyZWFtaW5nIGV2ZW50IGNvbnRhaW5pbmcgdGhlIGRhdGEuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0ZXh0IGNodW5rIHdpdGggZXNjYXBlZCBuZXdsaW5lcyByZXBsYWNlZC5cbiAgICovXG4gIGdldF90ZXh0X2NodW5rX2Zyb21fc3RyZWFtKGV2ZW50KSB7IHJldHVybiBldmVudC5kYXRhLnJlcGxhY2UoL1xcXFxuL2csICdcXG4nKTsgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBzdHJlYW1pbmcgcmVzcG9uc2UgaGFzIGVuZGVkIGJhc2VkIG9uIHRoZSByZWFkeVN0YXRlIG9mIHRoZSBYTUxIdHRwUmVxdWVzdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gVGhlIHN0cmVhbWluZyBldmVudC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHN0cmVhbSBoYXMgZW5kZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzX2VuZF9vZl9zdHJlYW0oZXZlbnQpIHsgcmV0dXJuIGV2ZW50LnNvdXJjZS54aHIucmVhZHlTdGF0ZSA9PT0gNDsgfVxuXG4gIC8qKlxuICAgKiBDb3VudHMgdGhlIHRva2VucyBpbiB0aGUgaW5wdXQgYnkgbWFraW5nIGFuIEFQSSByZXF1ZXN0IHRvIHRoZSBHZW1pbmkgdG9rZW4gY291bnRpbmcgZW5kcG9pbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gaW5wdXQgLSBUaGUgaW5wdXQgdGV4dCBvciBvYmplY3QgdG8gY291bnQgdG9rZW5zIGluLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fSBUaGUgdG90YWwgbnVtYmVyIG9mIHRva2VucyBpbiB0aGUgaW5wdXQuXG4gICAqL1xuICBhc3luYyBjb3VudF90b2tlbnMoaW5wdXQpIHtcbiAgICBjb25zdCByZXEgPSB7XG4gICAgICB1cmw6IGBodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS92MWJldGEvbW9kZWxzL2dlbWluaS1wcm86Y291bnRUb2tlbnM/a2V5PSR7dGhpcy5tb2RlbC5hcGlfa2V5fWAsXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgIH07XG4gICAgbGV0IGJvZHk7XG4gICAgaWYodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykgYm9keSA9IGNoYXRtbF90b19nZW1pbmkoeyBtZXNzYWdlczogW3sgcm9sZTogJ3VzZXInLCBjb250ZW50OiBpbnB1dCB9XSB9KTtcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkgYm9keSA9IGNoYXRtbF90b19nZW1pbmkoeyBtZXNzYWdlczogaW5wdXQgfSk7XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JykgYm9keSA9IGNoYXRtbF90b19nZW1pbmkoaW5wdXQpO1xuICAgIGVsc2UgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBjb3VudF90b2tlbnNcIiwgaW5wdXQpO1xuICAgIGRlbGV0ZSBib2R5LmdlbmVyYXRpb25Db25maWc7XG4gICAgZGVsZXRlIGJvZHkuc2FmZXR5U2V0dGluZ3M7XG4gICAgcmVxLmJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5tb2RlbC5yZXF1ZXN0X2FkYXB0ZXIocmVxKTtcbiAgICByZXR1cm4gcmVzcD8uanNvbj8udG90YWxUb2tlbnM7XG4gIH1cblxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgc3RhbmRhcmQgQVBJIGVuZHBvaW50IHdpdGggdGhlIEFQSSBrZXkgYXBwZW5kZWQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgZW5kcG9pbnQgVVJMIGZvciBub24tc3RyZWFtaW5nIHJlcXVlc3RzLlxuICAgKi9cbiAgZ2V0IGVuZHBvaW50KCkgeyByZXR1cm4gdGhpcy5tb2RlbC5jb25maWcuZW5kcG9pbnQucmVwbGFjZSgnTU9ERUxfTkFNRScsIHRoaXMubW9kZWwubW9kZWxfbmFtZSkgKyBcIj9rZXk9XCIgKyB0aGlzLm1vZGVsLmFwaV9rZXk7IH1cblxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgc3RyZWFtaW5nIEFQSSBlbmRwb2ludCB3aXRoIHRoZSBBUEkga2V5IGFwcGVuZGVkLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIGVuZHBvaW50IFVSTCBmb3Igc3RyZWFtaW5nIHJlcXVlc3RzLlxuICAgKi9cbiAgZ2V0IGVuZHBvaW50X3N0cmVhbWluZygpIHsgcmV0dXJuIHRoaXMubW9kZWwuY29uZmlnLmVuZHBvaW50X3N0cmVhbWluZy5yZXBsYWNlKCdNT0RFTF9OQU1FJywgdGhpcy5tb2RlbC5tb2RlbF9uYW1lKSArIFwiP2tleT1cIiArIHRoaXMubW9kZWwuYXBpX2tleTsgfVxufVxuZXhwb3J0cy5HZW1pbmlBZGFwdGVyID0gR2VtaW5pQWRhcHRlcjtcblxuLyoqXG4gKiBDb252ZXJ0IGEgQ2hhdE1MIG9iamVjdCB0byBhIEdlbWluaSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIENoYXRNTCBvYmplY3RcbiAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGNvbnZlcnRzIGEgQ2hhdE1MIG9iamVjdCB0byBhIEdlbWluaSBvYmplY3QuIEl0IGZpbHRlcnMgb3V0IHN5c3RlbSBtZXNzYWdlcyBhbmQgYWRkcyBhIHN5c3RlbSBtZXNzYWdlIHByaW9yIHRvIHRoZSBsYXN0IHVzZXIgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gVGhlIEdlbWluaSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gY2hhdG1sX3RvX2dlbWluaShvcHRzKSB7XG4gIC8vIC8vIGRlZXAgY29weSBtZXNzYWdlc1xuICAvLyBjb25zdCBtZXNzYWdlcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob3B0cy5tZXNzYWdlcykpLmZpbHRlcihtc2cgPT4gbXNnLnJvbGUgIT09ICdzeXN0ZW0nKTtcbiAgLy8gLy8gbWVyZ2Ugc3lzdGVtIHJvbGVzIGludG9tIHN1YnNlcXVlbnQgdXNlciByb2xlc1xuICAvLyBvcHRzLm1lc3NhZ2VzLmZvckVhY2goKG1zZywgaSkgPT4ge1xuICAvLyAgIGlmIChtc2cucm9sZSA9PT0gJ3N5c3RlbScpIHtcbiAgLy8gICAgIGlmICghbWVzc2FnZXNbaSArIDFdKSByZXR1cm4gY29uc29sZS5lcnJvcihcIlN5c3RlbSBtZXNzYWdlIHdpdGhvdXQgc3Vic2VxdWVudCB1c2VyIG1lc3NhZ2VcIik7XG4gIC8vICAgICBjb25zdCBzeXN0ZW1fcHJvbXB0ID0gJy0tLUJFR0lOIElNUE9SVEFOVCBDT05URVhULS0tXFxuJyArIG1zZy5jb250ZW50ICsgJ1xcbi0tLUVORCBJTVBPUlRBTlQgQ09OVEVYVC0tLVxcblxcbic7XG4gIC8vICAgICBtZXNzYWdlc1tpICsgMV0uY29udGVudCA9IHN5c3RlbV9wcm9tcHQgKyAobWVzc2FnZXNbaSArIDFdLmNvbnRlbnQgfHwgJycpO1xuICAvLyAgIH1cbiAgLy8gfSk7XG4gIGNvbnN0IG1lc3NhZ2VzID0gb3B0cy5tZXNzYWdlcy5maWx0ZXIobXNnID0+IG1zZy5yb2xlICE9PSAnc3lzdGVtJyk7XG4gIC8vIERPOiBoYW5kbGVkIGJldHRlciAoU21hcnQgQ29ubmVjdGlvbnMgc3BlY2lmaWMpXG4gIC8vIGdldCBpbmRleCBvZiBsYXN0IHN5c3RlbSBtZXNzYWdlXG4gIGNvbnN0IGxhc3Rfc3lzdGVtX2lkeCA9IG9wdHMubWVzc2FnZXMuZmluZExhc3RJbmRleChtc2cgPT4gbXNnLnJvbGUgPT09ICdzeXN0ZW0nICYmIG1zZy5jb250ZW50LmluY2x1ZGVzKCctLS1CRUdJTicpKTtcbiAgaWYgKGxhc3Rfc3lzdGVtX2lkeCA+IC0xKSB7XG4gICAgY29uc3Qgc3lzdGVtX3Byb21wdCA9ICctLS1CRUdJTiBJTVBPUlRBTlQgQ09OVEVYVC0tLVxcbicgKyBvcHRzLm1lc3NhZ2VzW2xhc3Rfc3lzdGVtX2lkeF0uY29udGVudCArICdcXG4tLS1FTkQgSU1QT1JUQU5UIENPTlRFWFQtLS1cXG5cXG4nO1xuICAgIG1lc3NhZ2VzW21lc3NhZ2VzLmxlbmd0aCAtIDFdLmNvbnRlbnQgPSBzeXN0ZW1fcHJvbXB0ICsgbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV0uY29udGVudDtcbiAgfVxuICBjb25zdCBib2R5ID0ge1xuICAgIGNvbnRlbnRzOiBtZXNzYWdlc1xuICAgICAgLmZpbHRlcihtc2cgPT4gbXNnLnJvbGUgIT09ICdzeXN0ZW0nKSAvLyBmaWx0ZXIgb3V0IHN5c3RlbSBtZXNzYWdlc1xuICAgICAgLm1hcChtc2cgPT4ge1xuICAgICAgICBjb25zdCBjb250ZW50ID0ge307XG4gICAgICAgIGNvbnRlbnQucm9sZSA9IG1zZy5yb2xlID09PSAnYXNzaXN0YW50JyA/ICdtb2RlbCcgOiBtc2cucm9sZTtcbiAgICAgICAgY29udGVudC5wYXJ0cyA9ICFBcnJheS5pc0FycmF5KG1zZy5jb250ZW50KSA/IFt7dGV4dDogbXNnLmNvbnRlbnR9XSA6IG1zZy5jb250ZW50Lm1hcChjID0+IHtcbiAgICAgICAgICBpZihjLnR5cGUgPT09ICd0ZXh0Jyl7XG4gICAgICAgICAgICByZXR1cm4ge3RleHQ6IGMudGV4dH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGMudHlwZSA9PT0gJ2ltYWdlX3VybCcpe1xuICAgICAgICAgICAgY29uc3QgaW1hZ2VfdXJsID0gYy5pbWFnZV91cmwudXJsO1xuICAgICAgICAgICAgbGV0IG1pbWVfdHlwZSA9IGltYWdlX3VybC5zcGxpdChcIjpcIilbMV0uc3BsaXQoXCI7XCIpWzBdO1xuICAgICAgICAgICAgaWYobWltZV90eXBlID09PSAnaW1hZ2UvanBnJykgbWltZV90eXBlID0gJ2ltYWdlL2pwZWcnO1xuICAgICAgICAgICAgcmV0dXJuIHtpbmxpbmVfZGF0YToge21pbWVfdHlwZTogbWltZV90eXBlLCBkYXRhOiBpbWFnZV91cmwuc3BsaXQoXCIsXCIpWzFdfX07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgICh7XG4gICAgICAgICAgcm9sZTogbXNnLnJvbGUgPT09ICdhc3Npc3RhbnQnID8gJ21vZGVsJyA6IG1zZy5yb2xlLFxuICAgICAgICAgIHBhcnRzOiBBcnJheS5pc0FycmF5KG1zZy5jb250ZW50KSA/IFt7dGV4dDogbXNnLmNvbnRlbnQuZmlsdGVyKGMgPT4gYy50eXBlID09PSAndGV4dCcpLm1hcChjID0+IGMudGV4dCkuam9pbignXFxuJyl9XSA6IFt7IHRleHQ6IG1zZy5jb250ZW50IH1dXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICxcbiAgICBnZW5lcmF0aW9uQ29uZmlnOiB7XG4gICAgICB0ZW1wZXJhdHVyZTogb3B0cy50ZW1wZXJhdHVyZSB8fCAwLjksXG4gICAgICB0b3BLOiBvcHRzLnRvcEsgfHwgMSxcbiAgICAgIHRvcFA6IG9wdHMudG9wUCB8fCAxLFxuICAgICAgbWF4T3V0cHV0VG9rZW5zOiBvcHRzLm1heF90b2tlbnMgfHwgMjA0OCxcbiAgICAgIHN0b3BTZXF1ZW5jZXM6IG9wdHMuc3RvcFNlcXVlbmNlcyB8fCBbXSxcbiAgICAgIGNhbmRpZGF0ZV9jb3VudDogb3B0cy5uIHx8IDEsXG4gICAgfSxcbiAgICBzYWZldHlTZXR0aW5nczogW1xuICAgICAge1xuICAgICAgICBjYXRlZ29yeTogXCJIQVJNX0NBVEVHT1JZX0hBUkFTU01FTlRcIixcbiAgICAgICAgdGhyZXNob2xkOiBcIkJMT0NLX05PTkVcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2F0ZWdvcnk6IFwiSEFSTV9DQVRFR09SWV9IQVRFX1NQRUVDSFwiLFxuICAgICAgICB0aHJlc2hvbGQ6IFwiQkxPQ0tfTk9ORVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjYXRlZ29yeTogXCJIQVJNX0NBVEVHT1JZX1NFWFVBTExZX0VYUExJQ0lUXCIsXG4gICAgICAgIHRocmVzaG9sZDogXCJCTE9DS19OT05FXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNhdGVnb3J5OiBcIkhBUk1fQ0FURUdPUllfREFOR0VST1VTX0NPTlRFTlRcIixcbiAgICAgICAgdGhyZXNob2xkOiBcIkJMT0NLX05PTkVcIlxuICAgICAgfVxuICAgIF1cbiAgfTtcbiAgY29uc3Qgc3lzdGVtX2luc3RydWN0aW9ucyA9IG9wdHMubWVzc2FnZXMuZmlsdGVyKG1zZyA9PiBtc2cucm9sZSA9PT0gJ3N5c3RlbScgJiYgIW1zZy5jb250ZW50LmluY2x1ZGVzKCctLS1CRUdJTicpKTtcbiAgaWYoc3lzdGVtX2luc3RydWN0aW9ucy5sZW5ndGggPiAwKSBib2R5LnN5c3RlbUluc3RydWN0aW9uID0geyBwYXJ0czogc3lzdGVtX2luc3RydWN0aW9ucy5tYXAobXNnID0+ICh7IHRleHQ6IG1zZy5jb250ZW50IH0pKSB9O1xuICBpZihvcHRzLnRvb2xzKXtcbiAgICBib2R5LnRvb2xzID0gW3tcbiAgICAgIGZ1bmN0aW9uX2RlY2xhcmF0aW9uczogb3B0cy50b29scy5tYXAodG9vbCA9PiAoe1xuICAgICAgICBuYW1lOiB0b29sLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiB0b29sLmZ1bmN0aW9uLmRlc2NyaXB0aW9uLFxuICAgICAgICBwYXJhbWV0ZXJzOiB0b29sLmZ1bmN0aW9uLnBhcmFtZXRlcnMsXG4gICAgICB9KSlcbiAgICB9XTtcbiAgICBpZihvcHRzLnRvb2xfY2hvaWNlKXtcbiAgICAgIGlmKG9wdHMudG9vbF9jaG9pY2UgIT09ICdhdXRvJyl7XG4gICAgICAgIGlmKG9wdHMubW9kZWwuaW5jbHVkZXMoJzEuNScpIHx8IG9wdHMubW9kZWwuaW5jbHVkZXMoJ2ZsYXNoJykpeyAvLyBtb2RlPUFOWSBhbmQgc3lzdGVtIGluc3RydWN0aW9ucyBhdmFpbGFibGUgaW4gMS41LXBybyBhbmQgMS41LWZsYXNoXG4gICAgICAgICAgYm9keS50b29sX2NvbmZpZyA9IHtcbiAgICAgICAgICAgIGZ1bmN0aW9uX2NhbGxpbmdfY29uZmlnOiB7XG4gICAgICAgICAgICAgIG1vZGU6IFwiQU5ZXCIsXG4gICAgICAgICAgICAgIGFsbG93ZWRfZnVuY3Rpb25fbmFtZXM6IG9wdHMudG9vbHMubWFwKHRvb2wgPT4gdG9vbC5mdW5jdGlvbi5uYW1lKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGJvZHkuc3lzdGVtSW5zdHJ1Y3Rpb24gPSB7XG4gICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICBwYXJ0czogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGV4dDogYElNUE9SVEFOVDogWW91IG11c3QgdXNlIHRoZSBcIiR7Ym9keS50b29sc1swXS5mdW5jdGlvbl9kZWNsYXJhdGlvbnNbMF0ubmFtZX1cIiBmdW5jdGlvbiB0b29sIWBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3lzdGVtIGluc3RydWN0aW9ucyBhbmQgZnVuY3Rpb24gY29uZmlnIG5vdCBhdmFpbGFibGUgaW4gMS4wXG4gICAgICAgIGNvbnN0IHRvb2xfcHJvbXB0ID0gYElNUE9SVEFOVDogWW91IG11c3QgdXNlIHRoZSBcIiR7Ym9keS50b29sc1swXS5mdW5jdGlvbl9kZWNsYXJhdGlvbnNbMF0ubmFtZX1cIiBmdW5jdGlvbiB0b29sIWA7XG4gICAgICAgIGNvbnN0IGxhc3RfdXNlcl9pZHggPSBib2R5LmNvbnRlbnRzLmZpbmRMYXN0SW5kZXgobXNnID0+IG1zZy5yb2xlID09PSAndXNlcicpO1xuICAgICAgICBib2R5LmNvbnRlbnRzW2xhc3RfdXNlcl9pZHhdLnBhcnRzWzBdLnRleHQgKz0gJ1xcblxcbicgKyB0b29sX3Byb21wdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvZHk7XG59XG5leHBvcnRzLmNoYXRtbF90b19nZW1pbmkgPSBjaGF0bWxfdG9fZ2VtaW5pOyIsICJjbGFzcyBPcGVuUm91dGVyQWRhcHRlciB7XG4gIGNvbnN0cnVjdG9yKG1vZGVsKSB7IHRoaXMubW9kZWwgPSBtb2RlbDsgfVxuICBnZXRfdG9vbF9jYWxsKGpzb24pIHtcbiAgICAvLyBoYW5kbGVzIEdlbWluaSBmb3JtYXRcbiAgICBpZihqc29uLmNob2ljZXNbMF0ubWVzc2FnZS50b29sX2NhbGxzKXtcbiAgICAgIHJldHVybiBqc29uLmNob2ljZXNbMF0ubWVzc2FnZS50b29sX2NhbGxzWzBdLmZ1bmN0aW9uO1xuICAgIH1cbiAgICAvLyBoYW5kbGVzIG1pc3RyYWwgZm9ybWF0XG4gICAgaWYoanNvbi5jaG9pY2VzWzBdLm1lc3NhZ2UuY29udGVudC5pbmNsdWRlcyhcImZ1bmN0aW9uXCIpKXtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBKU09OLnBhcnNlKGpzb24uY2hvaWNlc1swXS5tZXNzYWdlLmNvbnRlbnQpO1xuICAgICAgaWYoIWNvbnRlbnQuZnVuY3Rpb24pIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldF90b29sX25hbWUodG9vbF9jYWxsKSB7XG4gICAgaWYodG9vbF9jYWxsLmZ1bmN0aW9uKSByZXR1cm4gdG9vbF9jYWxsLmZ1bmN0aW9uOyAvLyBtaXN0cmFsIGZvcm1hdFxuICAgIGlmKHRvb2xfY2FsbC5uYW1lKSByZXR1cm4gdG9vbF9jYWxsLm5hbWU7IC8vIGdlbWluaSBmb3JtYXRcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXRfdG9vbF9jYWxsX2NvbnRlbnQodG9vbF9jYWxsKSB7XG4gICAgaWYodG9vbF9jYWxsLnBhcmFtZXRlcnMpIHJldHVybiB0b29sX2NhbGwucGFyYW1ldGVyczsgLy8gbWlzdHJhbCBmb3JtYXRcbiAgICAvLyBoYW5kbGUgZ2VtaW5pIGZvcm1hdFxuICAgIGlmKHRvb2xfY2FsbC5hcmd1bWVudHMpe1xuICAgICAgY29uc3QgYXJncyA9IEpTT04ucGFyc2UodG9vbF9jYWxsLmFyZ3VtZW50cyk7XG4gICAgICAvLyBwcmV2ZW50IGVzY2FwZSBjaGFyYWN0ZXIgaXNzdWVzXG4gICAgICBPYmplY3QuZW50cmllcyhhcmdzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgYXJnc1trZXldID0gdmFsdWUucmVwbGFjZSgvXFxcXG4vZywgXCJcXG5cIilcbiAgICAgICAgICAucmVwbGFjZSgvXFxcXHQvZywgXCJcXHRcIilcbiAgICAgICAgICAucmVwbGFjZSgvXFxcXHIvZywgXCJcXHJcIilcbiAgICAgICAgICAucmVwbGFjZSgvXFxcXCcvZywgXCInXCIpXG4gICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXJncztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmV4cG9ydHMuT3BlblJvdXRlckFkYXB0ZXIgPSBPcGVuUm91dGVyQWRhcHRlcjsiLCAiY29uc3QgeyBBbnRocm9waWNBZGFwdGVyIH0gPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2FudGhyb3BpYycpO1xuY29uc3QgeyBDb2hlcmVBZGFwdGVyIH0gPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2NvaGVyZScpO1xuY29uc3QgeyBHZW1pbmlBZGFwdGVyIH0gPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2dlbWluaScpO1xuY29uc3QgeyBPcGVuUm91dGVyQWRhcHRlciB9ID0gcmVxdWlyZSgnLi9hZGFwdGVycy9vcGVuX3JvdXRlcicpO1xuZXhwb3J0cy5BbnRocm9waWMgPSBBbnRocm9waWNBZGFwdGVyO1xuZXhwb3J0cy5Db2hlcmUgPSBDb2hlcmVBZGFwdGVyO1xuZXhwb3J0cy5HZW1pbmkgPSBHZW1pbmlBZGFwdGVyO1xuZXhwb3J0cy5PcGVuUm91dGVyID0gT3BlblJvdXRlckFkYXB0ZXI7XG5cbiIsICJ7XG4gIFwib3BlbmFpXCI6IHtcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiT3BlbkFJXCIsXG4gICAgXCJ0eXBlXCI6IFwiQVBJXCIsXG4gICAgXCJlbmRwb2ludFwiOiBcImh0dHBzOi8vYXBpLm9wZW5haS5jb20vdjEvY2hhdC9jb21wbGV0aW9uc1wiLFxuICAgIFwic3RyZWFtaW5nXCI6IHRydWUsXG4gICAgXCJhY3Rpb25zXCI6IHRydWUsXG4gICAgXCJmZXRjaF9tb2RlbHNcIjogdHJ1ZSxcbiAgICBcImRlZmF1bHRfbW9kZWxcIjogXCJncHQtMy41LXR1cmJvXCIsXG4gICAgXCJzaWdudXBfdXJsXCI6IFwiaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2FwaS1rZXlzXCJcbiAgfSxcbiAgXCJnb29nbGVfZ2VtaW5pXCI6IHtcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiR29vZ2xlIEdlbWluaVwiLFxuICAgIFwidHlwZVwiOiBcIkFQSVwiLFxuICAgIFwiYXBpX2tleV9oZWFkZXJcIjogXCJub25lXCIsXG4gICAgXCJlbmRwb2ludFwiOiBcImh0dHBzOi8vZ2VuZXJhdGl2ZWxhbmd1YWdlLmdvb2dsZWFwaXMuY29tL3YxYmV0YS9tb2RlbHMvTU9ERUxfTkFNRTpnZW5lcmF0ZUNvbnRlbnRcIixcbiAgICBcImVuZHBvaW50X3N0cmVhbWluZ1wiOiBcImh0dHBzOi8vZ2VuZXJhdGl2ZWxhbmd1YWdlLmdvb2dsZWFwaXMuY29tL3YxYmV0YS9tb2RlbHMvTU9ERUxfTkFNRTpzdHJlYW1HZW5lcmF0ZUNvbnRlbnRcIixcbiAgICBcInN0cmVhbWluZ1wiOiB0cnVlLFxuICAgIFwiYWN0aW9uc1wiOiB0cnVlLFxuICAgIFwiYWRhcHRlclwiOiBcIkdlbWluaVwiLFxuICAgIFwiZmV0Y2hfbW9kZWxzXCI6IHRydWUsXG4gICAgXCJkZWZhdWx0X21vZGVsXCI6IFwiZ2VtaW5pLTEuNS1wcm9cIixcbiAgICBcInNpZ251cF91cmxcIjogXCJodHRwczovL2FpLmdvb2dsZS5kZXYvXCJcbiAgfSxcbiAgXCJvcGVuX3JvdXRlclwiOiB7XG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIk9wZW4gUm91dGVyXCIsXG4gICAgXCJ0eXBlXCI6IFwiQVBJXCIsXG4gICAgXCJlbmRwb2ludFwiOiBcImh0dHBzOi8vb3BlbnJvdXRlci5haS9hcGkvdjEvY2hhdC9jb21wbGV0aW9uc1wiLFxuICAgIFwic3RyZWFtaW5nXCI6IHRydWUsXG4gICAgXCJhZGFwdGVyXCI6IFwiT3BlblJvdXRlclwiLFxuICAgIFwiZmV0Y2hfbW9kZWxzXCI6IHRydWUsXG4gICAgXCJkZWZhdWx0X21vZGVsXCI6IFwibWlzdHJhbGFpL21pc3RyYWwtN2ItaW5zdHJ1Y3Q6ZnJlZVwiLFxuICAgIFwic2lnbnVwX3VybFwiOiBcImh0dHBzOi8vYWNjb3VudHMub3BlbnJvdXRlci5haS9zaWduLXVwP3JlZGlyZWN0X3VybD1odHRwcyUzQSUyRiUyRm9wZW5yb3V0ZXIuYWklMkZrZXlzXCJcbiAgfSxcbiAgXCJjb2hlcmVcIjoge1xuICAgIFwiZGVzY3JpcHRpb25cIjogXCJDb2hlcmUgQ29tbWFuZC1SXCIsXG4gICAgXCJ0eXBlXCI6IFwiQVBJXCIsXG4gICAgXCJlbmRwb2ludFwiOiBcImh0dHBzOi8vYXBpLmNvaGVyZS5haS92MS9jaGF0XCIsXG4gICAgXCJzdHJlYW1pbmdcIjogZmFsc2UsXG4gICAgXCJhZGFwdGVyXCI6IFwiQ29oZXJlXCIsXG4gICAgXCJmZXRjaF9tb2RlbHNcIjogdHJ1ZSxcbiAgICBcImRlZmF1bHRfbW9kZWxcIjogXCJjb21tYW5kLXJcIixcbiAgICBcInNpZ251cF91cmxcIjogXCJodHRwczovL2Rhc2hib2FyZC5jb2hlcmUuY29tL3dlbGNvbWUvcmVnaXN0ZXI/cmVkaXJlY3RfdXJpPSUyRmFwaS1rZXlzXCJcbiAgfSxcbiAgXCJhbnRocm9waWNcIjoge1xuICAgIFwiZGVzY3JpcHRpb25cIjogXCJBbnRocm9waWMgQ2xhdWRlXCIsXG4gICAgXCJ0eXBlXCI6IFwiQVBJXCIsXG4gICAgXCJlbmRwb2ludFwiOiBcImh0dHBzOi8vYXBpLmFudGhyb3BpYy5jb20vdjEvbWVzc2FnZXNcIixcbiAgICBcInN0cmVhbWluZ1wiOiBmYWxzZSxcbiAgICBcImFwaV9rZXlfaGVhZGVyXCI6IFwieC1hcGkta2V5XCIsXG4gICAgXCJoZWFkZXJzXCI6IHtcbiAgICAgIFwiYW50aHJvcGljLXZlcnNpb25cIjogXCIyMDIzLTA2LTAxXCIsXG4gICAgICBcImFudGhyb3BpYy1iZXRhXCI6IFwidG9vbHMtMjAyNC0wNC0wNFwiXG4gICAgfSxcbiAgICBcImFkYXB0ZXJcIjogXCJBbnRocm9waWNcIixcbiAgICBcImFjdGlvbnNcIjogdHJ1ZSxcbiAgICBcImZldGNoX21vZGVsc1wiOiB0cnVlLFxuICAgIFwiZGVmYXVsdF9tb2RlbFwiOiBcImNsYXVkZS0zLXNvbm5ldC0yMDI0MDIyOVwiLFxuICAgIFwic2lnbnVwX3VybFwiOiBcImh0dHBzOi8vY29uc29sZS5hbnRocm9waWMuY29tL2xvZ2luP3JldHVyblRvPSUyRnNldHRpbmdzJTJGa2V5c1wiXG4gIH0sXG4gIFwiY3VzdG9tX2xvY2FsXCI6IHtcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQ3VzdG9tIExvY2FsIChPcGVuQUkgZm9ybWF0KVwiLFxuICAgIFwidHlwZVwiOiBcIkFQSVwiXG4gIH0sXG4gIFwiY3VzdG9tX2FwaVwiOiB7XG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkN1c3RvbSBBUEkgKE9wZW5BSSBmb3JtYXQpXCIsXG4gICAgXCJ0eXBlXCI6IFwiQVBJXCJcbiAgfVxufVxuXG4iLCAiLyoqXG4gICBjb25zdCB0b29sc19leGFtcGxlID0gW1xuICAgIHtcbiAgICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZ2V0X2N1cnJlbnRfd2VhdGhlclwiLFxuICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiR2V0IHRoZSBjdXJyZW50IHdlYXRoZXIgaW4gYSBnaXZlbiBsb2NhdGlvblwiLFxuICAgICAgICBcInBhcmFtZXRlcnNcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IHtcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgY2l0eSBhbmQgc3RhdGUsIGUuZy4gU2FuIEZyYW5jaXNjbywgQ0FcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInVuaXRcIjoge1widHlwZVwiOiBcInN0cmluZ1wiLCBcImVudW1cIjogW1wiY2Vsc2l1c1wiLCBcImZhaHJlbmhlaXRcIl19LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXCJsb2NhdGlvblwiXSxcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiLFxuICAgIFwiZnVuY3Rpb25cIjoge1xuICAgICAgXCJuYW1lXCI6IFwibG9va3VwXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiU2VtYW50aWMgc2VhcmNoXCIsXG4gICAgICBcInBhcmFtZXRlcnNcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgICBcImh5cG90aGV0aWNhbHNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIFwiaXRlbXNcIjoge1widHlwZVwiOiBcInN0cmluZ1wifVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXTtcbiAqL1xuLyoqXG4gKiBWYWxpZGF0ZXMgYSB0b29sIGNhbGwgYWdhaW5zdCBpdHMgc3BlY2lmaWNhdGlvbiB0byBlbnN1cmUgYWxsIHBhcmFtZXRlcnMgYXJlIGNvcnJlY3QuXG4gKiBUaGlzIGZ1bmN0aW9uIGNoZWNrcyBpZiBhbGwgcHJvdmlkZWQga2V5cyBpbiB0aGUgdG9vbCBjYWxsIGNvbnRlbnQgbWF0Y2ggdGhlIGV4cGVjdGVkIHR5cGVzLFxuICogaGFuZGxlcyB0eXBlIGNvZXJjaW9uIGZvciBudW1lcmljIHZhbHVlcywgdmFsaWRhdGVzIGFnYWluc3QgZW51bXMsIGFuZCBlbnN1cmVzIGFsbCByZXF1aXJlZFxuICogcGFyYW1ldGVycyBhcmUgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9vbCAtIFRoZSB0b29sIG9iamVjdCBjb250YWluaW5nIHRoZSBmdW5jdGlvbiBzcGVjaWZpY2F0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IHRvb2xfY2FsbF9jb250ZW50IC0gVGhlIGFjdHVhbCBwYXJhbWV0ZXJzIHBhc3NlZCB0byB0aGUgdG9vbCBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBpZiB0aGUgdG9vbCBjYWxsIGlzIHZhbGlkLlxuICogQHRocm93cyB7RXJyb3J9IC0gVGhyb3dzIGFuIGVycm9yIGlmIGFueSB2YWxpZGF0aW9uIGZhaWxzLlxuICovXG5mdW5jdGlvbiBpc192YWxpZF90b29sX2NhbGwodG9vbCwgdG9vbF9jYWxsX2NvbnRlbnQpIHtcbiAgY29uc3QgcHJvcHMgPSB0b29sLmZ1bmN0aW9uLnBhcmFtZXRlcnMucHJvcGVydGllcztcbiAgaWYgKHR5cGVvZiBwcm9wcyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LmtleXModG9vbF9jYWxsX2NvbnRlbnQpLmxlbmd0aCA9PT0gMCl7XG4gICAgY29uc29sZS53YXJuKGBJbnZhbGlkIHRvb2wgY2FsbDogb2JqZWN0IGlzIGVtcHR5YCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGNoZWNrIGlmIGFsbCBrZXlzIGFyZSBpbiB0b29sIHNwZWNcbiAgT2JqZWN0LmVudHJpZXModG9vbF9jYWxsX2NvbnRlbnQpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICghcHJvcHNba2V5XSl7XG4gICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgdG9vbCBjYWxsOiBtaXNzaW5nIGtleSAke2tleX0gaW4gdG9vbCBzcGVjYCwgcHJvcHMpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgcHJvcHNba2V5XS50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAvLyBjaGVjayBpZiBhbGwgaXRlbXMgaW4gdGhlIGFycmF5IGFyZSBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICBjb25zdCBpdGVtVHlwZSA9IHR5cGVvZiB2YWx1ZVswXTtcbiAgICAgIGlmICghdmFsdWUuZXZlcnkoaXRlbSA9PiB0eXBlb2YgaXRlbSA9PT0gaXRlbVR5cGUpKXtcbiAgICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIHRvb2wgY2FsbDogYXJyYXkgaXRlbXMgYXJlIG5vdCBvZiB0aGUgc2FtZSB0eXBlYCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBhcnJheSBpdGVtcyBhcmUgb2YgdGhlIHNhbWUgdHlwZSBhcyB0aGUgc3BlY1xuICAgICAgLy8gaWYgKHByb3BzW2tleV0uaXRlbXMudHlwZSAhPT0gaXRlbVR5cGUpIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0b29sIGNhbGw6IGFycmF5IGl0ZW1zIGFyZSBub3Qgb2YgdGhlIHNhbWUgdHlwZSBhcyB0aGUgc3BlY2ApO1xuICAgICAgaWYgKHByb3BzW2tleV0uaXRlbXMudHlwZSAhPT0gaXRlbVR5cGUpe1xuICAgICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgdG9vbCBjYWxsOiBhcnJheSBpdGVtcyBhcmUgbm90IG9mIHRoZSBzYW1lIHR5cGUgYXMgdGhlIHNwZWNgKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcHNba2V5XS50eXBlICE9PSB0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGlmIChwcm9wc1trZXldLnR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdmFsdWUgaXMgYSB2YWxpZCBudW1iZXJcbiAgICAgICAgaWYgKGlzTmFOKE51bWJlcih2YWx1ZSkpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIHRvb2wgY2FsbDogdmFsdWUgJHt2YWx1ZX0gaXMgbm90IGEgdmFsaWQgbnVtYmVyYCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRvb2xfY2FsbF9jb250ZW50W2tleV0gPSBOdW1iZXIodmFsdWUpOyAvLyBjb2VyY2UgdG8gbnVtYmVyIChzaG91bGQgbXV0YXRlIHRvb2xfY2FsbF9jb250ZW50KVxuICAgICAgLy8gfSBlbHNlIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0b29sIGNhbGw6IHZhbHVlICR7dmFsdWV9IGlzIG5vdCBvZiB0eXBlICR7cHJvcHNba2V5XS50eXBlfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIHRvb2wgY2FsbDogdmFsdWUgJHt2YWx1ZX0gaXMgbm90IG9mIHR5cGUgJHtwcm9wc1trZXldLnR5cGV9YCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgKHByb3BzW2tleV0uZW51bSAmJiAhcHJvcHNba2V5XS5lbnVtLmluY2x1ZGVzKHZhbHVlKSkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRvb2wgY2FsbDogdmFsdWUgJHt2YWx1ZX0gaXMgbm90IGluIGVudW0gJHtwcm9wc1trZXldLmVudW19YCk7XG4gICAgaWYgKHByb3BzW2tleV0uZW51bSAmJiAhcHJvcHNba2V5XS5lbnVtLmluY2x1ZGVzKHZhbHVlKSl7XG4gICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgdG9vbCBjYWxsOiB2YWx1ZSAke3ZhbHVlfSBpcyBub3QgaW4gZW51bSAke3Byb3BzW2tleV0uZW51bX1gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICAvLyBjaGVjayBpZiBhbGwgcmVxdWlyZWQga2V5cyBhcmUgcHJlc2VudFxuICB0b29sLmZ1bmN0aW9uLnBhcmFtZXRlcnMucmVxdWlyZWQ/LmZvckVhY2goa2V5ID0+IHtcbiAgICAvLyBpZiAoIXRvb2xfY2FsbF9jb250ZW50W2tleV0pIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0b29sIGNhbGw6IG1pc3NpbmcgcmVxdWlyZWQga2V5ICR7a2V5fWApO1xuICAgIGlmICh0eXBlb2YgdG9vbF9jYWxsX2NvbnRlbnRba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCB0b29sIGNhbGw6IG1pc3NpbmcgcmVxdWlyZWQga2V5ICR7a2V5fWApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodG9vbF9jYWxsX2NvbnRlbnRba2V5XSA9PT0gJycpIHtcbiAgICAgIGNvbnNvbGUud2FybihgRW1wdHkgdmFsdWUgZm9yIHJlcXVpcmVkIGtleSAke2tleX1gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuaXNfdmFsaWRfdG9vbF9jYWxsID0gaXNfdmFsaWRfdG9vbF9jYWxsO1xuIiwgImNsYXNzIFNtYXJ0U3RyZWFtZXIge1xuICBjb25zdHJ1Y3Rvcih1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1ldGhvZCA9ICdHRVQnLFxuICAgICAgaGVhZGVycyA9IHt9LFxuICAgICAgYm9keSA9IG51bGwsXG4gICAgICB3aXRoQ3JlZGVudGlhbHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMud2l0aENyZWRlbnRpYWxzID0gd2l0aENyZWRlbnRpYWxzO1xuICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gdGhpcy5DT05ORUNUSU5HO1xuICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xuICAgIHRoaXMuY2h1bmsgPSAnJztcbiAgICB0aGlzLmxhc3RfZXZlbnRfaWQgPSAnJztcbiAgICB0aGlzLnhociA9IG51bGw7XG4gICAgdGhpcy5GSUVMRF9TRVBBUkFUT1IgPSAnOic7XG4gICAgdGhpcy5JTklUSUFMSVpJTkcgPSAtMTtcbiAgICB0aGlzLkNPTk5FQ1RJTkcgPSAwO1xuICAgIHRoaXMuT1BFTiA9IDE7XG4gICAgdGhpcy5DTE9TRUQgPSAyO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKCF0aGlzLmxpc3RlbmVyc1t0eXBlXSkgdGhpcy5saXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICBpZiAoIXRoaXMubGlzdGVuZXJzW3R5cGVdLmluY2x1ZGVzKGxpc3RlbmVyKSkgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lciBmcm9tIHRoZSBTbWFydFN0cmVhbWVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIGV2ZW50IHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIgZnJvbS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gcmVtb3ZlLlxuICAgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIGlmICghdGhpcy5saXN0ZW5lcnNbdHlwZV0pIHJldHVybjtcbiAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXSA9IHRoaXMubGlzdGVuZXJzW3R5cGVdLmZpbHRlcigoY2FsbGJhY2spID0+IGNhbGxiYWNrICE9PSBsaXN0ZW5lcik7XG4gICAgaWYgKHRoaXMubGlzdGVuZXJzW3R5cGVdLmxlbmd0aCA9PT0gMCkgZGVsZXRlIHRoaXMubGlzdGVuZXJzW3R5cGVdO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYW4gZXZlbnQgdG8gdGhlIGFwcHJvcHJpYXRlIGV2ZW50IGhhbmRsZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBSZXR1cm5zIHRydWUgaWYgdGhlIGV2ZW50IHdhcyBzdWNjZXNzZnVsbHkgZGlzcGF0Y2hlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgIGlmICghZXZlbnQpIHJldHVybiB0cnVlO1xuICAgIGV2ZW50LnNvdXJjZSA9IHRoaXM7XG4gICAgY29uc3Qgb25IYW5kbGVyID0gJ29uJyArIGV2ZW50LnR5cGU7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBvbkhhbmRsZXIpKSB7XG4gICAgICB0aGlzW29uSGFuZGxlcl0uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5saXN0ZW5lcnNbZXZlbnQudHlwZV0pIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50LnR5cGVdLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYXRlcyB0aGUgc3RyZWFtaW5nIHByb2Nlc3MuXG4gICAqL1xuICBzdHJlYW0oKSB7XG4gICAgdGhpcy4jc2V0UmVhZHlTdGF0ZSh0aGlzLkNPTk5FQ1RJTkcpO1xuICAgIHRoaXMueGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgdGhpcy54aHIuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB0aGlzLiNvblN0cmVhbVByb2dyZXNzLmJpbmQodGhpcykpO1xuICAgIHRoaXMueGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLiNvblN0cmVhbUxvYWRlZC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnhoci5hZGRFdmVudExpc3RlbmVyKCdyZWFkeXN0YXRlY2hhbmdlJywgdGhpcy4jY2hlY2tTdHJlYW1DbG9zZWQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy54aHIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLiNvblN0cmVhbUZhaWx1cmUuYmluZCh0aGlzKSk7XG4gICAgdGhpcy54aHIuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCB0aGlzLiNvblN0cmVhbUFib3J0LmJpbmQodGhpcykpO1xuICAgIHRoaXMueGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsKTtcbiAgICBmb3IgKGNvbnN0IGhlYWRlciBpbiB0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyLCB0aGlzLmhlYWRlcnNbaGVhZGVyXSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmxhc3RfZXZlbnRfaWQpIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoJ0xhc3QtRXZlbnQtSUQnLCB0aGlzLmxhc3RfZXZlbnRfaWQpO1xuICAgIHRoaXMueGhyLndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xuICAgIHRoaXMueGhyLnNlbmQodGhpcy5ib2R5KTtcbiAgfVxuICAvKipcbiAgICogRW5kcyB0aGUgc3RyZWFtZXIgY29ubmVjdGlvbi5cbiAgICogQWJvcnRzIHRoZSBjdXJyZW50IFhIUiByZXF1ZXN0IGFuZCBzZXRzIHRoZSByZWFkeSBzdGF0ZSB0byBDTE9TRUQuXG4gICAqL1xuICBlbmQoKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdGhpcy5DTE9TRUQpIHJldHVybjtcbiAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgIHRoaXMueGhyID0gbnVsbDtcbiAgICB0aGlzLiNzZXRSZWFkeVN0YXRlKHRoaXMuQ0xPU0VEKTtcbiAgfVxuXG4gIC8vIHByaXZhdGUgbWV0aG9kc1xuICAjc2V0UmVhZHlTdGF0ZShzdGF0ZSkge1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdyZWFkeVN0YXRlQ2hhbmdlJyk7XG4gICAgZXZlbnQucmVhZHlTdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cbiAgI29uU3RyZWFtRmFpbHVyZShlKSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Vycm9yJyk7XG4gICAgZXZlbnQuZGF0YSA9IGUuY3VycmVudFRhcmdldC5yZXNwb25zZTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIHRoaXMuZW5kKCk7XG4gIH1cbiAgI29uU3RyZWFtQWJvcnQoZSkge1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdhYm9ydCcpO1xuICAgIHRoaXMuZW5kKCk7XG4gIH1cbiAgI29uU3RyZWFtUHJvZ3Jlc3MoZSkge1xuICAgIGlmICghdGhpcy54aHIpIHJldHVybjtcbiAgICBpZiAodGhpcy54aHIuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIHRoaXMuI29uU3RyZWFtRmFpbHVyZShlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdGhpcy5DT05ORUNUSU5HKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdvcGVuJykpO1xuICAgICAgdGhpcy4jc2V0UmVhZHlTdGF0ZSh0aGlzLk9QRU4pO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gdGhpcy54aHIucmVzcG9uc2VUZXh0LnN1YnN0cmluZyh0aGlzLnByb2dyZXNzKTtcbiAgICB0aGlzLnByb2dyZXNzICs9IGRhdGEubGVuZ3RoO1xuICAgIC8vIGRhdGEuc3BsaXQoLyhcXHJcXG58XFxyfFxcbil7Mn0vZykuZm9yRWFjaCgocGFydCkgPT4ge1xuICAgIGRhdGEuc3BsaXQoLyhcXHJcXG58XFxyfFxcbikvZykuZm9yRWFjaCgocGFydCkgPT4ge1xuICAgICAgaWYgKHBhcnQudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy4jcGFyc2VFdmVudENodW5rKHRoaXMuY2h1bmsudHJpbSgpKSk7XG4gICAgICAgIHRoaXMuY2h1bmsgPSAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2h1bmsgKz0gcGFydDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAjb25TdHJlYW1Mb2FkZWQoZSkge1xuICAgIHRoaXMuI29uU3RyZWFtUHJvZ3Jlc3MoZSk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KHRoaXMuI3BhcnNlRXZlbnRDaHVuayh0aGlzLmNodW5rKSk7XG4gICAgdGhpcy5jaHVuayA9ICcnO1xuICB9XG4gICNwYXJzZUV2ZW50Q2h1bmsoY2h1bmspIHtcbiAgICBpZiAoIWNodW5rIHx8IGNodW5rLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgZSA9IHsgaWQ6IG51bGwsIHJldHJ5OiBudWxsLCBkYXRhOiAnJywgZXZlbnQ6ICdtZXNzYWdlJywgdGV4dDogJycgfTtcbiAgICBjaHVuay5zcGxpdCgvKFxcclxcbnxcXHJ8XFxuKS8pLmZvckVhY2goKGxpbmUpID0+IHtcbiAgICAgIC8vIGxpbmUgPSBsaW5lLnRyaW1SaWdodCgpO1xuICAgICAgbGluZSA9IGxpbmUudHJpbSgpO1xuICAgICAgY29uc3QgaW5kZXggPSBsaW5lLmluZGV4T2YodGhpcy5GSUVMRF9TRVBBUkFUT1IpO1xuICAgICAgaWYgKGluZGV4IDw9IDApIHJldHVybjtcbiAgICAgIC8vIGNvbnN0IGZpZWxkID0gbGluZS5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgLy8gYWxzbyByZW1vdmUgcXVvdGVzXG4gICAgICBjb25zdCBmaWVsZCA9IGxpbmUuc3Vic3RyaW5nKDAsIGluZGV4KS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKTtcbiAgICAgIGlmKCFbJ2lkJywgJ3JldHJ5JywgJ2RhdGEnLCAnZXZlbnQnLCAndGV4dCddLmluY2x1ZGVzKGZpZWxkKSkgcmV0dXJuO1xuICAgICAgLy8gaWYgKCEoZmllbGQgaW4gZSkpIHJldHVybjtcbiAgICAgIC8vIGNvbnN0IHZhbHVlID0gbGluZS5zdWJzdHJpbmcoaW5kZXggKyAxKS50cmltTGVmdCgpO1xuICAgICAgY29uc3QgdmFsdWUgPSBsaW5lLnN1YnN0cmluZyhpbmRleCArIDEpLnRyaW0oKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKTtcbiAgICAgIC8vIGlmIChmaWVsZCA9PT0gJ2RhdGEnKSBlW2ZpZWxkXSArPSB2YWx1ZTtcbiAgICAgIC8vIGVsc2UgZVtmaWVsZF0gPSB2YWx1ZTtcbiAgICAgIGUuZGF0YSArPSB2YWx1ZTtcbiAgICB9KTtcbiAgICBpZiAoZS5pZCkgdGhpcy5sYXN0X2V2ZW50X2lkID0gZS5pZDtcbiAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudChlLmV2ZW50IHx8ICdtZXNzYWdlJyk7XG4gICAgZXZlbnQuaWQgPSBlLmlkO1xuICAgIGV2ZW50LmRhdGEgPSBlLmRhdGEgfHwgJyc7XG4gICAgZXZlbnQubGFzdF9ldmVudF9pZCA9IHRoaXMubGFzdF9ldmVudF9pZDtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgI2NoZWNrU3RyZWFtQ2xvc2VkKCkge1xuICAgIGlmICghdGhpcy54aHIpIHJldHVybjtcbiAgICBpZiAodGhpcy54aHIucmVhZHlTdGF0ZSA9PT0gWE1MSHR0cFJlcXVlc3QuRE9ORSkgdGhpcy4jc2V0UmVhZHlTdGF0ZSh0aGlzLkNMT1NFRCk7XG4gIH1cblxufVxuXG5leHBvcnRzLlNtYXJ0U3RyZWFtZXIgPSBTbWFydFN0cmVhbWVyO1xuIiwgImFzeW5jIGZ1bmN0aW9uIGZldGNoX29wZW5fcm91dGVyX21vZGVscyhhcGlfa2V5LCByZXF1ZXN0X2FkYXB0ZXI9bnVsbCkge1xuICB0cnkge1xuICAgIGxldCBkYXRhO1xuICAgIGlmKCFyZXF1ZXN0X2FkYXB0ZXIpIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vb3BlbnJvdXRlci5haS9hcGkvdjEvbW9kZWxzJyk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTmV0d29yayByZXNwb25zZSB3YXMgbm90IG9rJyk7XG4gICAgICB9XG4gICAgICBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgY29uc29sZS5sb2coJ01vZGVsIGRhdGEgcmV0cmlldmVkOicsIGRhdGEpO1xuICAgIH1lbHNle1xuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHJlcXVlc3RfYWRhcHRlcih7XG4gICAgICAgIHVybDogJ2h0dHBzOi8vb3BlbnJvdXRlci5haS9hcGkvdjEvbW9kZWxzJyxcbiAgICAgIH0pO1xuICAgICAgZGF0YSA9IGF3YWl0IHJlc3AuanNvbjtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGEuZGF0YVxuICAgICAgLy8gLmZpbHRlcihtb2RlbCA9PiAhbW9kZWwuaWQuaW5jbHVkZXMoJ2luc3RydWN0JykpXG4gICAgICAubWFwKG1vZGVsID0+ICh7XG4gICAgICAgIG1vZGVsX25hbWU6IG1vZGVsLmlkLFxuICAgICAgICBrZXk6IG1vZGVsLmlkLFxuICAgICAgICBtYXhfaW5wdXRfdG9rZW5zOiBtb2RlbC5jb250ZXh0X2xlbmd0aCxcbiAgICAgICAgZGVzY3JpcHRpb246IG1vZGVsLm5hbWUsXG4gICAgICAgIGFjdGlvbnM6IG1vZGVsLmRlc2NyaXB0aW9uLmluY2x1ZGVzKCd0b29sIHVzZScpIHx8IG1vZGVsLmRlc2NyaXB0aW9uLmluY2x1ZGVzKCdmdW5jdGlvbiBjYWxsJyksXG4gICAgICAgIG11bHRpbW9kYWw6IG1vZGVsLmFyY2hpdGVjdHVyZS5tb2RhbGl0eSA9PT0gJ211bHRpbW9kYWwnLFxuICAgICAgICByYXc6IG1vZGVsXG4gICAgICB9KSlcbiAgICA7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGZldGNoIG1vZGVsIGRhdGE6JywgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuZXhwb3J0cy5mZXRjaF9vcGVuX3JvdXRlcl9tb2RlbHMgPSBmZXRjaF9vcGVuX3JvdXRlcl9tb2RlbHM7IiwgImNvbnN0IG1vZGVsX2NvbnRleHQgPSB7XG4gIFwiZ3B0LTMuNS10dXJiby0wMTI1XCI6IHtcbiAgICBcImNvbnRleHRcIjogMTYzODUsXG4gICAgXCJtYXhfb3V0XCI6IDQwOTZcbiAgfSxcbiAgXCJncHQtMy41LXR1cmJvLTAzMDFcIjoge1xuICAgIFwiY29udGV4dFwiOiA0MDk3LFxuICAgIFwibWF4X291dFwiOiA0MDk3XG4gIH0sXG4gIFwiZ3B0LTMuNS10dXJiby0wNjEzXCI6IHtcbiAgICBcImNvbnRleHRcIjogNDA5NyxcbiAgICBcIm1heF9vdXRcIjogNDA5N1xuICB9LFxuICBcImdwdC0zLjUtdHVyYm8tMTEwNlwiOiB7XG4gICAgXCJjb250ZXh0XCI6IDE2Mzg1LFxuICAgIFwibWF4X291dFwiOiA0MDk2XG4gIH0sXG4gIFwiZ3B0LTMuNS10dXJiby0xNmtcIjoge1xuICAgIFwiY29udGV4dFwiOiAxNjM4NSxcbiAgICBcIm1heF9vdXRcIjogMTYzODVcbiAgfSxcbiAgXCJncHQtMy41LXR1cmJvLTE2ay0wNjEzXCI6IHtcbiAgICBcImNvbnRleHRcIjogMTYzODUsXG4gICAgXCJtYXhfb3V0XCI6IDE2Mzg1XG4gIH0sXG4gIFwiZ3B0LTQtMDEyNS1wcmV2aWV3XCI6IHtcbiAgICBcImNvbnRleHRcIjogMTI4MDAwLFxuICAgIFwibWF4X291dFwiOiA0MDk2XG4gIH0sXG4gIFwiZ3B0LTQtMDMxNFwiOiB7XG4gICAgXCJjb250ZXh0XCI6IDgxOTIsXG4gICAgXCJtYXhfb3V0XCI6IDgxOTJcbiAgfSxcbiAgXCJncHQtNC0wNjEzXCI6IHtcbiAgICBcImNvbnRleHRcIjogODE5MixcbiAgICBcIm1heF9vdXRcIjogODE5MlxuICB9LFxuICBcImdwdC00LTExMDYtcHJldmlld1wiOiB7XG4gICAgXCJjb250ZXh0XCI6IDEyODAwMCxcbiAgICBcIm1heF9vdXRcIjogNDA5NlxuICB9LFxuICBcImdwdC00LTExMDYtdmlzaW9uLXByZXZpZXdcIjoge1xuICAgIFwiY29udGV4dFwiOiAxMjgwMDAsXG4gICAgXCJtYXhfb3V0XCI6IDQwOTZcbiAgfSxcbiAgXCJncHQtNC0zMmstMDMxNFwiOiB7XG4gICAgXCJjb250ZXh0XCI6IDMyNzY4LFxuICAgIFwibWF4X291dFwiOiAzMjc2OFxuICB9LFxuICBcImdwdC00LTMyay0wNjEzXCI6IHtcbiAgICBcImNvbnRleHRcIjogMzI3NjgsXG4gICAgXCJtYXhfb3V0XCI6IDMyNzY4XG4gIH0sXG4gIFwiZ3B0LTQtdHVyYm8tMjAyNC0wNC0wOVwiOiB7XG4gICAgXCJjb250ZXh0XCI6IDEyODAwMCxcbiAgICBcIm1heF9vdXRcIjogNDA5NlxuICB9LFxuICBcImdwdC00LXR1cmJvLXByZXZpZXdcIjoge1xuICAgIFwiY29udGV4dFwiOiAxMjgwMDAsXG4gICAgXCJtYXhfb3V0XCI6IDQwOTZcbiAgfSxcbiAgXCJncHQtNC12aXNpb24tcHJldmlld1wiOiB7XG4gICAgXCJjb250ZXh0XCI6IDEyODAwMCxcbiAgICBcIm1heF9vdXRcIjogNDA5NlxuICB9LFxuICBcImdwdC0zLjUtdHVyYm9cIjoge1xuICAgIFwiY29udGV4dFwiOiAxNjM4NSxcbiAgICBcIm1heF9vdXRcIjogNDA5NlxuICB9LFxuICBcImdwdC00LXR1cmJvXCI6IHtcbiAgICBcImNvbnRleHRcIjogMTI4MDAwLFxuICAgIFwibWF4X291dFwiOiA0MDk2XG4gIH0sXG4gIFwiZ3B0LTQtMzJrXCI6IHtcbiAgICBcImNvbnRleHRcIjogMzI3NjgsXG4gICAgXCJtYXhfb3V0XCI6IDMyNzY4XG4gIH0sXG4gIFwiZ3B0LTRvXCI6IHtcbiAgICBcImNvbnRleHRcIjogMTI4MDAwLFxuICAgIFwibWF4X291dFwiOiA0MDk2XG4gIH0sXG4gIFwiZ3B0LTRcIjoge1xuICAgIFwiY29udGV4dFwiOiA4MTkyLFxuICAgIFwibWF4X291dFwiOiA4MTkyXG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoX29wZW5haV9tb2RlbHMoYXBpX2tleSwgcmVxdWVzdF9hZGFwdGVyPW51bGwpIHtcbiAgaWYgKCFhcGlfa2V5KSB7XG4gICAgY29uc29sZS5lcnJvcignTm8gQVBJIGtleSBwcm92aWRlZCcpO1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB0cnkge1xuICAgIGxldCBkYXRhO1xuICAgIGlmKCFyZXF1ZXN0X2FkYXB0ZXIpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBmZXRjaCcpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MS9tb2RlbHMnLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHthcGlfa2V5fWAsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXR3b3JrIHJlc3BvbnNlIHdhcyBub3Qgb2snKTtcbiAgICAgIH1cbiAgICAgIGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZygnTW9kZWwgZGF0YSByZXRyaWV2ZWQ6JywgZGF0YSk7XG4gICAgfWVsc2V7XG4gICAgICBjb25zb2xlLmxvZygnVXNpbmcgcmVxdWVzdCBhZGFwdGVyJyk7XG4gICAgICBjb25zdCByZXNwID0gYXdhaXQgcmVxdWVzdF9hZGFwdGVyKHtcbiAgICAgICAgdXJsOiAnaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MS9tb2RlbHMnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7YXBpX2tleX1gLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICBkYXRhID0gYXdhaXQgcmVzcC5qc29uO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YS5kYXRhXG4gICAgICAuZmlsdGVyKG1vZGVsID0+IG1vZGVsLmlkLnN0YXJ0c1dpdGgoJ2dwdC0nKSAmJiAhbW9kZWwuaWQuaW5jbHVkZXMoJy1pbnN0cnVjdCcpKVxuICAgICAgLm1hcChtb2RlbCA9PiB7XG4gICAgICAgIGNvbnN0IG91dCA9IHtcbiAgICAgICAgICBtb2RlbF9uYW1lOiBtb2RlbC5pZCwgXG4gICAgICAgICAga2V5OiBtb2RlbC5pZCxcbiAgICAgICAgICBtdWx0aW1vZGFsOiBtb2RlbC5pZC5pbmNsdWRlcygndmlzaW9uJykgfHwgbW9kZWwuaWQuaW5jbHVkZXMoJ2dwdC00LXR1cmJvJykgfHwgbW9kZWwuaWQuc3RhcnRzV2l0aCgnZ3B0LTRvJylcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbSA9IE9iamVjdC5lbnRyaWVzKG1vZGVsX2NvbnRleHQpLmZpbmQobSA9PiBtWzBdID09PSBtb2RlbC5pZCB8fCBtb2RlbC5pZC5zdGFydHNXaXRoKG1bMF0gKyAnLScpKTtcbiAgICAgICAgaWYobSkge1xuICAgICAgICAgIG91dC5tYXhfaW5wdXRfdG9rZW5zID0gbVsxXS5jb250ZXh0O1xuICAgICAgICAgIG91dC5kZXNjcmlwdGlvbiA9IGBjb250ZXh0OiAke21bMV0uY29udGV4dH0sIG91dHB1dDogJHttWzFdLm1heF9vdXR9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfSlcbiAgICA7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGZldGNoIG1vZGVsIGRhdGE6JywgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuZXhwb3J0cy5mZXRjaF9vcGVuYWlfbW9kZWxzID0gZmV0Y2hfb3BlbmFpX21vZGVsczsiLCAiYXN5bmMgZnVuY3Rpb24gZmV0Y2hfZ29vZ2xlX2dlbWluaV9tb2RlbHMoYXBpX2tleSwgcmVxdWVzdF9hZGFwdGVyPW51bGwpIHtcbiAgaWYgKCFhcGlfa2V5KSB7XG4gICAgY29uc29sZS5lcnJvcignTm8gQVBJIGtleSBwcm92aWRlZCcpO1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB0cnkge1xuICAgIGxldCBkYXRhO1xuICAgIGlmKCFyZXF1ZXN0X2FkYXB0ZXIpIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vZ2VuZXJhdGl2ZWxhbmd1YWdlLmdvb2dsZWFwaXMuY29tL3YxYmV0YS9tb2RlbHM/a2V5PScgKyBhcGlfa2V5KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXR3b3JrIHJlc3BvbnNlIHdhcyBub3Qgb2snKTtcbiAgICAgIH1cbiAgICAgIGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZygnTW9kZWwgZGF0YSByZXRyaWV2ZWQ6JywgZGF0YSk7XG4gICAgfWVsc2V7XG4gICAgICBjb25zdCByZXNwID0gYXdhaXQgcmVxdWVzdF9hZGFwdGVyKHtcbiAgICAgICAgdXJsOiAnaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb20vdjFiZXRhL21vZGVscz9rZXk9JyArIGFwaV9rZXksXG4gICAgICB9KTtcbiAgICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHJlc3ApKTtcbiAgICAgIGRhdGEgPSBhd2FpdCByZXNwLmpzb247XG4gICAgfVxuICAgIHJldHVybiBkYXRhLm1vZGVsc1xuICAgICAgLmZpbHRlcihtb2RlbCA9PiBtb2RlbC5uYW1lLnN0YXJ0c1dpdGgoJ21vZGVscy9nZW1pbmknKSlcbiAgICAgIC5tYXAobW9kZWwgPT4ge1xuICAgICAgICBjb25zdCBvdXQgPSB7XG4gICAgICAgICAgbW9kZWxfbmFtZTogbW9kZWwubmFtZS5zcGxpdCgnLycpLnBvcCgpLCBcbiAgICAgICAgICBrZXk6IG1vZGVsLm5hbWUuc3BsaXQoJy8nKS5wb3AoKSxcbiAgICAgICAgICBtYXhfaW5wdXRfdG9rZW5zOiBtb2RlbC5pbnB1dFRva2VuTGltaXQsXG4gICAgICAgICAgbWF4X291dHB1dF90b2tlbnM6IG1vZGVsLm1heE91dHB1dFRva2VucyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogbW9kZWwuZGVzY3JpcHRpb24sXG4gICAgICAgICAgbXVsdGltb2RhbDogbW9kZWwubmFtZS5pbmNsdWRlcygndmlzaW9uJykgfHwgbW9kZWwuZGVzY3JpcHRpb24uaW5jbHVkZXMoJ211bHRpbW9kYWwnKSxcbiAgICAgICAgICByYXc6IG1vZGVsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggbW9kZWwgZGF0YTonLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5leHBvcnRzLmZldGNoX2dvb2dsZV9nZW1pbmlfbW9kZWxzID0gZmV0Y2hfZ29vZ2xlX2dlbWluaV9tb2RlbHM7IiwgIi8vIGN1cmwgLS1yZXF1ZXN0IEdFVCBcXFxuLy8gICAtLXVybCBodHRwczovL2FwaS5jb2hlcmUuYWkvdjEvbW9kZWxzIFxcXG4vLyAgIC0taGVhZGVyICdhY2NlcHQ6IGFwcGxpY2F0aW9uL2pzb24nIFxcXG4vLyAgIC0taGVhZGVyIFwiQXV0aG9yaXphdGlvbjogYmVhcmVyICRDT19BUElfS0VZXCJcblxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hfY29oZXJlX21vZGVscyhhcGlfa2V5LCByZXF1ZXN0X2FkYXB0ZXI9bnVsbCkge1xuICBpZiAoIWFwaV9rZXkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdObyBBUEkga2V5IHByb3ZpZGVkJyk7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHRyeSB7XG4gICAgbGV0IGRhdGE7XG4gICAgaWYoIXJlcXVlc3RfYWRhcHRlcikge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9hcGkuY29oZXJlLmFpL3YxL21vZGVscycsIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke2FwaV9rZXl9YCxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05ldHdvcmsgcmVzcG9uc2Ugd2FzIG5vdCBvaycpO1xuICAgICAgfVxuICAgICAgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnNvbGUubG9nKCdNb2RlbCBkYXRhIHJldHJpZXZlZDonLCBkYXRhKTtcbiAgICB9ZWxzZXtcbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCByZXF1ZXN0X2FkYXB0ZXIoe1xuICAgICAgICB1cmw6ICdodHRwczovL2FwaS5jb2hlcmUuYWkvdjEvbW9kZWxzJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke2FwaV9rZXl9YCxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgZGF0YSA9IGF3YWl0IHJlc3AuanNvbjtcbiAgICB9XG4gICAgY29uc29sZS5sb2coJ01vZGVsIGRhdGEgcmV0cmlldmVkOicsIGRhdGEpO1xuICAgIHJldHVybiBkYXRhLm1vZGVsc1xuICAgICAgLmZpbHRlcihtb2RlbCA9PiBtb2RlbC5uYW1lLnN0YXJ0c1dpdGgoJ2NvbW1hbmQtJykpXG4gICAgICAubWFwKG1vZGVsID0+IHtcbiAgICAgICAgY29uc3Qgb3V0ID0ge1xuICAgICAgICAgIG1vZGVsX25hbWU6IG1vZGVsLm5hbWUsXG4gICAgICAgICAga2V5OiBtb2RlbC5uYW1lLFxuICAgICAgICAgIG1heF9pbnB1dF90b2tlbnM6IG1vZGVsLmNvbnRleHRfbGVuZ3RoLFxuICAgICAgICAgIHRva2VuaXplcl91cmw6IG1vZGVsLnRva2VuaXplcl91cmwsXG4gICAgICAgICAgZmluZXR1bmVkOiBtb2RlbC5maW5ldHVuZWQsXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBNYXggaW5wdXQgdG9rZW5zOiAke21vZGVsLmNvbnRleHRfbGVuZ3RofSwgRmluZXR1bmVkOiAke21vZGVsLmZpbmV0dW5lZH1gXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggbW9kZWwgZGF0YTonLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5leHBvcnRzLmZldGNoX2NvaGVyZV9tb2RlbHMgPSBmZXRjaF9jb2hlcmVfbW9kZWxzO1xuXG4iLCAiLy8gZmFrZSBpdCBiZWNhdXNlIGFudGhyb3BpYyBkb2Vzbid0IGhhdmUgbW9kZWwgbGlzdCBBUEkgZW5kcG9pbnRcbmFzeW5jIGZ1bmN0aW9uIGZldGNoX2FudGhyb3BpY19tb2RlbHMoKSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgXCJrZXlcIjogXCJjbGF1ZGUtMy1vcHVzLTIwMjQwMjI5XCIsXG4gICAgICBcIm1vZGVsX25hbWVcIjogXCJjbGF1ZGUtMy1vcHVzLTIwMjQwMjI5XCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiQW50aHJvcGljJ3MgQ2xhdWRlIE9wdXNcIixcbiAgICAgIFwibWF4X2lucHV0X3Rva2Vuc1wiOiAyMDAwMDAsXG4gICAgICBcIm1heF9vdXRwdXRfdG9rZW5zXCI6IDQwMDAsXG4gICAgICBcIm11bHRpbW9kYWxcIjogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAga2V5OiBcImNsYXVkZS0zLTUtc29ubmV0LTIwMjQwNjIwXCIsXG4gICAgICBcIm1vZGVsX25hbWVcIjogXCJjbGF1ZGUtMy41LXNvbm5ldC0yMDI0MDYyMFwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkFudGhyb3BpYydzIENsYXVkZSBTb25uZXRcIixcbiAgICAgIFwibWF4X2lucHV0X3Rva2Vuc1wiOiAyMDAwMDAsXG4gICAgICBcIm1heF9vdXRwdXRfdG9rZW5zXCI6IDQwMDAsXG4gICAgICBcIm11bHRpbW9kYWxcIjogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAga2V5OiBcImNsYXVkZS0zLWhhaWt1LTIwMjQwMzA3XCIsXG4gICAgICBcIm1vZGVsX25hbWVcIjogXCJjbGF1ZGUtMy1oYWlrdS0yMDI0MDMwN1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkFudGhyb3BpYydzIENsYXVkZSBIYWlrdVwiLFxuICAgICAgXCJtYXhfaW5wdXRfdG9rZW5zXCI6IDIwMDAwMCxcbiAgICAgICAgXCJtYXhfb3V0cHV0X3Rva2Vuc1wiOiA0MDAwLFxuICAgICAgICBcIm11bHRpbW9kYWxcIjogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAga2V5OiBcImNsYXVkZS0zLXNvbm5ldC0yMDI0MDIyOVwiLFxuICAgICAgXCJtb2RlbF9uYW1lXCI6IFwiY2xhdWRlLTMtc29ubmV0LTIwMjQwMjI5XCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiQW50aHJvcGljJ3MgQ2xhdWRlIFNvbm5ldFwiLFxuICAgICAgXCJtYXhfaW5wdXRfdG9rZW5zXCI6IDIwMDAwMCxcbiAgICAgIFwibWF4X291dHB1dF90b2tlbnNcIjogNDAwMCxcbiAgICAgIFwibXVsdGltb2RhbFwiOiB0cnVlXG4gICAgfSxcbiAgXTtcbn1cbmV4cG9ydHMuZmV0Y2hfYW50aHJvcGljX21vZGVscyA9IGZldGNoX2FudGhyb3BpY19tb2RlbHM7XG5cbiIsICJjb25zdCB7IGZldGNoX29wZW5fcm91dGVyX21vZGVscyB9ID0gcmVxdWlyZSgnLi9vcGVuX3JvdXRlcicpO1xuY29uc3QgeyBmZXRjaF9vcGVuYWlfbW9kZWxzIH0gPSByZXF1aXJlKCcuL29wZW5haScpO1xuY29uc3QgeyBmZXRjaF9nb29nbGVfZ2VtaW5pX21vZGVscyB9ID0gcmVxdWlyZSgnLi9nb29nbGVfZ2VtaW5pJyk7XG5jb25zdCB7IGZldGNoX2NvaGVyZV9tb2RlbHMgfSA9IHJlcXVpcmUoJy4vY29oZXJlJyk7XG5jb25zdCB7IGZldGNoX2FudGhyb3BpY19tb2RlbHMgfSA9IHJlcXVpcmUoJy4vYW50aHJvcGljJyk7XG5leHBvcnRzLm9wZW5fcm91dGVyID0gZmV0Y2hfb3Blbl9yb3V0ZXJfbW9kZWxzO1xuZXhwb3J0cy5vcGVuYWkgPSBmZXRjaF9vcGVuYWlfbW9kZWxzO1xuZXhwb3J0cy5nb29nbGVfZ2VtaW5pID0gZmV0Y2hfZ29vZ2xlX2dlbWluaV9tb2RlbHM7XG5leHBvcnRzLmNvaGVyZSA9IGZldGNoX2NvaGVyZV9tb2RlbHM7XG5leHBvcnRzLmFudGhyb3BpYyA9IGZldGNoX2FudGhyb3BpY19tb2RlbHM7XG5cbiIsICIvLyBDb3B5cmlnaHQgKGMpIEJyaWFuIEpvc2VwaCBQZXRyb1xuXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbi8vIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuLy8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuLy8gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4vLyBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4vLyBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXG4vLyBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OXG4vLyBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5jb25zdCBhZGFwdGVycyA9IHJlcXVpcmUoJy4vYWRhcHRlcnMnKTtcbmNvbnN0IHBsYXRmb3JtcyA9IHJlcXVpcmUoJy4vcGxhdGZvcm1zLmpzb24nKTtcbmNvbnN0IHsgaXNfdmFsaWRfdG9vbF9jYWxsIH0gPSByZXF1aXJlKCcuL3V0aWxzL2lzX3ZhbGlkX3Rvb2xfY2FsbCcpO1xuY29uc3QgeyBTbWFydFN0cmVhbWVyIH0gPSByZXF1aXJlKCcuL3N0cmVhbWVyJyk7XG5jb25zdCBmZXRjaF9tb2RlbHMgPSByZXF1aXJlKFwiLi9tb2RlbHMvZmV0Y2hcIik7XG4vKipcbiAqIFNtYXJ0Q2hhdE1vZGVsIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdGllcyB0byBoYW5kbGUgY2hhdCBpbnRlcmFjdGlvbnMgd2l0aCB2YXJpb3VzIG1vZGVscyBhbmQgYWRhcHRlcnMuXG4gKiBJdCBzdXBwb3J0cyBzdHJlYW1pbmcgYW5kIG5vbi1zdHJlYW1pbmcgcmVzcG9uc2VzLCB0b29sIGNhbGxzLCBhbmQgY3VzdG9taXphdGlvbnMgdGhyb3VnaCBvcHRpb25zLlxuICovXG5jbGFzcyBTbWFydENoYXRNb2RlbCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGFuIGluc3RhbmNlIG9mIFNtYXJ0Q2hhdE1vZGVsIHdpdGggc3BlY2lmaWVkIGVudmlyb25tZW50LCBtb2RlbCBrZXksIGFuZCBvcHRpb25zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFpbiAtIFRoZSBtYWluIGVudmlyb25tZW50IGNvbnRleHQsIHR5cGljYWxseSBjb250YWluaW5nIGNvbmZpZ3VyYXRpb25zIGFuZCBzdGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBsYXRmb3JtX2tleSAtIEtleSB0byBzZWxlY3QgdGhlIHNwZWNpZmljIG1vZGVsIGNvbmZpZ3VyYXRpb24gZnJvbSBtb2RlbHMuanNvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2NvbmZpZyAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgdG8gb3ZlcnJpZGUgbW9kZWwgY29uZmlndXJhdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtYWluLCBwbGF0Zm9ybV9rZXksIG1vZGVsX2NvbmZpZz17fSkge1xuICAgIHRoaXMuZW52ID0gbWFpbjtcbiAgICB0aGlzLm1haW4gPSB0aGlzLmVudjsgLy8gREVQUkVDQVRFRFxuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgLi4uKHBsYXRmb3Jtc1twbGF0Zm9ybV9rZXldIHx8IHt9KSxcbiAgICAgIC4uLm1vZGVsX2NvbmZpZywgLy8gb3ZlcnJpZGUgZGVmYXVsdCBwbGF0Zm9ybSBjb25maWdcbiAgICB9XG4gICAgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkodGhpcy5jb25maWcpKTtcbiAgICB0aGlzLnBsYXRmb3JtX2tleSA9IHBsYXRmb3JtX2tleTtcbiAgICB0aGlzLmFjdGl2ZV9zdHJlYW0gPSBudWxsO1xuICAgIHRoaXMuX3JlcXVlc3RfYWRhcHRlciA9IG51bGw7XG4gICAgdGhpcy5wbGF0Zm9ybXMgPSBwbGF0Zm9ybXM7XG4gICAgaWYodGhpcy5jb25maWcuYWRhcHRlcikgdGhpcy5hZGFwdGVyID0gbmV3IGFkYXB0ZXJzW3RoaXMuY29uZmlnLmFkYXB0ZXJdKHRoaXMpO1xuICAgIGlmKHRoaXMuYWRhcHRlcikgY29uc29sZS5sb2coXCJoYXMgY2hhdCBtb2RlbCBhZGFwdGVyXCIpO1xuICB9XG4gIHN0YXRpYyBnZXQgbW9kZWxzKCkgeyByZXR1cm4gcGxhdGZvcm1zOyB9IC8vIERFUFJFQ0FURUQgKGNvbmZ1c2luZyBuYW1lKVxuICAvLyBcbiAgc3RhdGljIGdldCBwbGF0Zm9ybXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHBsYXRmb3JtcykubWFwKGtleSA9PiAoe1xuICAgICAga2V5LFxuICAgICAgLi4ucGxhdGZvcm1zW2tleV0sXG4gICAgfSkpO1xuICB9XG4gIGdldCBwbGF0Zm9ybSgpIHsgcmV0dXJuIHBsYXRmb3Jtc1t0aGlzLnBsYXRmb3JtX2tleV07IH1cbiAgZ2V0IGRlZmF1bHRfb3B0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGVtcGVyYXR1cmU6IDAuMyxcbiAgICAgIHRvcF9wOiAxLFxuICAgICAgcHJlc2VuY2VfcGVuYWx0eTogMCxcbiAgICAgIGZyZXF1ZW5jeV9wZW5hbHR5OiAwLFxuICAgICAgbjogMSxcbiAgICAgIG1vZGVsOiB0aGlzLm1vZGVsX25hbWUsXG4gICAgICBtYXhfdG9rZW5zOiB0aGlzLm1heF9vdXRwdXRfdG9rZW5zLFxuICAgIH07XG4gIH1cbiAgYXN5bmMgcmVxdWVzdF9taWRkbGV3YXJlcyhvcHRzKSB7IHJldHVybiBvcHRzOyB9XG4gIC8qKlxuICAgKiBDb21wbGV0ZXMgdGhlIGNoYXQgaW50ZXJhY3Rpb24gYnkgcHJvY2Vzc2luZyB0aGUgcHJvdmlkZWQgb3B0aW9ucywgbWFraW5nIGFuIEFQSSByZXF1ZXN0LCBhbmQgaGFuZGxpbmcgdGhlIHJlc3BvbnNlLlxuICAgKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBib3RoIHN0cmVhbWluZyBhbmQgbm9uLXN0cmVhbWluZyByZXNwb25zZXMsIGFuZCBjYW4gaGFuZGxlIHRvb2wgY2FsbHMgaWYgc3BlY2lmaWVkIGluIHRoZSByZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGNoYXQgY29tcGxldGlvbiB3aGljaCBtYXkgaW5jbHVkZSBzZXR0aW5ncyBsaWtlIHRlbXBlcmF0dXJlLCBtYXggdG9rZW5zLCBldGMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVuZGVyIC0gRmxhZyB0byBkZXRlcm1pbmUgaWYgdGhlIHJlc3BvbnNlIHNob3VsZCBiZSByZW5kZXJlZCBpbiB0aGUgVUkuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ3x2b2lkPn0gLSBSZXR1cm5zIHRoZSBjaGF0IHJlc3BvbnNlIGNvbnRlbnQgb3IgaGFuZGxlcyB0b29sIG91dHB1dHMgcmVjdXJzaXZlbHkuIEluIGNhc2Ugb2YgZXJyb3JzLCBpdCBtYXkgcmV0dXJuIGFuIGVycm9yIG1lc3NhZ2UuXG4gICAqL1xuICBhc3luYyBjb21wbGV0ZShvcHRzID0ge30sIHJlbmRlciA9IHRydWUpIHtcbiAgICBjb25zdCBwcmVwYXJlZF9vcHRzID0gYXdhaXQgdGhpcy5wcmVwYXJlX29wdGlvbnMob3B0cyk7XG4gICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuY3JlYXRlX3JlcXVlc3QocHJlcGFyZWRfb3B0cyk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGlmIChwcmVwYXJlZF9vcHRzLnN0cmVhbSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5oYW5kbGVfc3RyZWFtaW5nX3JlcXVlc3QocmVxdWVzdCwgcmVuZGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmhhbmRsZV9ub25fc3RyZWFtaW5nX3JlcXVlc3QocmVxdWVzdCwgcHJlcGFyZWRfb3B0cywgcmVuZGVyKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZV9lcnJvcihlcnIsIHJlbmRlcik7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcHJlcGFyZV9vcHRpb25zKG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuYmFzZV9tb2RlbF9jb25maWcpIHtcbiAgICAgIHRoaXMuYmFzZV9tb2RlbF9jb25maWcgPSBhd2FpdCB0aGlzLmdldF9iYXNlX21vZGVsX2NvbmZpZygpO1xuICAgICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAgIC4uLnRoaXMuYmFzZV9tb2RlbF9jb25maWcsXG4gICAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBwcmVwYXJlZF9vcHRzID0ge1xuICAgICAgLi4udGhpcy5kZWZhdWx0X29wdHMsXG4gICAgICBtZXNzYWdlczogKGF3YWl0IHRoaXMuY3VycmVudD8uZ2V0X2NoYXRfbWwoKSk/Lm1lc3NhZ2VzIHx8IFtdLFxuICAgICAgLi4ub3B0cyxcbiAgICB9O1xuXG4gICAgaWYgKHByZXBhcmVkX29wdHMuc3RyZWFtICE9PSBmYWxzZSAmJiB0aGlzLmNvbmZpZy5zdHJlYW1pbmcgJiYgIXRoaXMuY3VycmVudD8udG9vbF9jaG9pY2UpIHtcbiAgICAgIHByZXBhcmVkX29wdHMuc3RyZWFtID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlcGFyZWRfb3B0cy5zdHJlYW0gPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0X21pZGRsZXdhcmVzKEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocHJlcGFyZWRfb3B0cykpKTtcbiAgfVxuXG4gIGNyZWF0ZV9yZXF1ZXN0KG9wdHMpIHtcbiAgICBjb25zdCByZXEgPSB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy5hcGlfa2V5fWBcbiAgICAgIH0sXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIH07XG5cbiAgICBpZiAodGhpcy5jb25maWcuaGVhZGVycykge1xuICAgICAgcmVxLmhlYWRlcnMgPSB7IC4uLnJlcS5oZWFkZXJzLCAuLi50aGlzLmNvbmZpZy5oZWFkZXJzIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29uZmlnLmFwaV9rZXlfaGVhZGVyKSB7XG4gICAgICBpZiAodGhpcy5jb25maWcuYXBpX2tleV9oZWFkZXIgIT09ICdub25lJykge1xuICAgICAgICByZXEuaGVhZGVyc1t0aGlzLmNvbmZpZy5hcGlfa2V5X2hlYWRlcl0gPSB0aGlzLmFwaV9rZXk7XG4gICAgICB9XG4gICAgICBkZWxldGUgcmVxLmhlYWRlcnMuQXV0aG9yaXphdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCBib2R5ID0gdHlwZW9mIHRoaXMuZW52LmFjdGlvbnM/LnByZXBhcmVfcmVxdWVzdF9ib2R5ID09PSAnZnVuY3Rpb24nIFxuICAgICAgPyB0aGlzLmVudi5hY3Rpb25zLnByZXBhcmVfcmVxdWVzdF9ib2R5KG9wdHMpIFxuICAgICAgOiB7IC4uLm9wdHMgfTtcblxuICAgIHJlcS5ib2R5ID0gSlNPTi5zdHJpbmdpZnkodHlwZW9mIHRoaXMuYWRhcHRlcj8ucHJlcGFyZV9yZXF1ZXN0X2JvZHkgPT09ICdmdW5jdGlvbicgXG4gICAgICA/IHRoaXMuYWRhcHRlci5wcmVwYXJlX3JlcXVlc3RfYm9keShib2R5KSBcbiAgICAgIDogYm9keSk7XG5cbiAgICByZXR1cm4gcmVxO1xuICB9XG5cbiAgYXN5bmMgaGFuZGxlX3N0cmVhbWluZ19yZXF1ZXN0KHJlcXVlc3QsIHJlbmRlcikge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbShyZXF1ZXN0KTtcbiAgfVxuXG4gIGFzeW5jIGhhbmRsZV9ub25fc3RyZWFtaW5nX3JlcXVlc3QocmVxdWVzdCwgb3B0cywgcmVuZGVyKSB7XG4gICAgY29uc3QgcmVzcF9qc29uID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHJlcXVlc3QpO1xuICAgIFxuICAgIGlmIChyZXNwX2pzb24uZXJyb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZV9hcGlfZXJyb3IocmVzcF9qc29uLmVycm9yLCByZW5kZXIpO1xuICAgIH1cblxuICAgIC8vIGlmIGlzIHRvb2xfY2FsbCwgaGFuZGxlIHRvb2xfY2FsbCBhbmQgcmV0dXJuXG4gICAgY29uc3QgdG9vbF9jYWxsID0gdGhpcy5nZXRfdG9vbF9jYWxsKHJlc3BfanNvbik7XG4gICAgaWYgKHRvb2xfY2FsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlX3Rvb2xfY2FsbCh0b29sX2NhbGwsIG9wdHMsIHJlbmRlcik7XG4gICAgfVxuXG4gICAgY29uc3QgbWVzc2FnZV9jb250ZW50ID0gdGhpcy5nZXRfbWVzc2FnZV9jb250ZW50KHJlc3BfanNvbik7XG4gICAgaWYgKHJlbmRlcikge1xuICAgICAgdGhpcy5kb25lX2hhbmRsZXIobWVzc2FnZV9jb250ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2VfY29udGVudDtcbiAgfVxuXG4gIGhhbmRsZV9hcGlfZXJyb3IoZXJyb3IsIHJlbmRlcikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIGlmIChyZW5kZXIpIHtcbiAgICAgIHRoaXMuZG9uZV9oYW5kbGVyKFwiKkFQSSBFcnJvci4gU2VlIGNvbnNvbGUgbG9ncyBmb3IgZGV0YWlscy4qXCIpO1xuICAgIH1cbiAgICByZXR1cm4gXCIqQVBJIEVycm9yLiBTZWUgY29uc29sZSBsb2dzIGZvciBkZXRhaWxzLipcIjtcbiAgfVxuXG4gIGFzeW5jIGhhbmRsZV90b29sX2NhbGwodG9vbF9jYWxsLCBvcHRzLCByZW5kZXIpIHtcbiAgICBpZiAodGhpcy5lbnYuY2hhdHM/LmN1cnJlbnQ/LnRvb2xfY2hvaWNlKSB7XG4gICAgICB0aGlzLmVudi5jaGF0cy5jdXJyZW50LnRvb2xfY2hvaWNlID0gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB0b29sX25hbWUgPSB0aGlzLmdldF90b29sX25hbWUodG9vbF9jYWxsKTtcbiAgICBjb25zdCB0b29sX2NhbGxfY29udGVudCA9IHRoaXMuZ2V0X3Rvb2xfY2FsbF9jb250ZW50KHRvb2xfY2FsbCk7XG4gICAgY29uc3QgdG9vbHMgPSBvcHRzLnRvb2xzIHx8IFtdO1xuICAgIGNvbnN0IHRvb2wgPSB0b29scy5maW5kKCh0KSA9PiB0LmZ1bmN0aW9uLm5hbWUgPT09IHRvb2xfbmFtZSk7XG4gICAgY29uc3QgdG9vbF9oYW5kbGVyID0gdGhpcy5nZXRfdG9vbF9oYW5kbGVyKHRvb2xfbmFtZSk7XG5cbiAgICBpZiAoIXRvb2xfaGFuZGxlciB8fCAhaXNfdmFsaWRfdG9vbF9jYWxsKHRvb2wsIHRvb2xfY2FsbF9jb250ZW50KSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlX2ludmFsaWRfdG9vbF9jYWxsKHRvb2xfbmFtZSwgdG9vbF9jYWxsX2NvbnRlbnQpO1xuICAgIH1cblxuICAgIGF3YWl0IHRoaXMuYWRkX3Rvb2xfY2FsbF90b19jaGF0KHRvb2xfbmFtZSwgdG9vbF9jYWxsX2NvbnRlbnQpO1xuICAgIGNvbnN0IHRvb2xfb3V0cHV0ID0gYXdhaXQgdG9vbF9oYW5kbGVyKHRoaXMuZW52LCB0b29sX2NhbGxfY29udGVudCk7XG5cbiAgICBpZiAodG9vbF9vdXRwdXQpIHtcbiAgICAgIGF3YWl0IHRoaXMuY3VycmVudC5hZGRfdG9vbF9vdXRwdXQodG9vbF9uYW1lLCB0b29sX291dHB1dCk7XG4gICAgICB0aGlzLmN1cnJlbnQudG9vbF9jaG9pY2UgPSAnbm9uZSc7IC8vIHByZXZlbnQgc3Vic2VxdWVudCB0b29sIGNhbGxzIGZyb20gcHJldmVudGluZyBjb21wbGV0aW9uXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZSh7fSk7IC8vIGVtcHR5IG9wdHNcbiAgICB9XG4gIH1cblxuICBoYW5kbGVfaW52YWxpZF90b29sX2NhbGwodG9vbF9uYW1lLCB0b29sX2NhbGxfY29udGVudCkge1xuICAgIGNvbnNvbGUud2FybihgVG9vbCAke3Rvb2xfbmFtZX0gbm90IGZvdW5kIG9yIGludmFsaWQsIHJldHVybmluZyB0b29sX2NhbGxfY29udGVudGApO1xuICAgIGNvbnNvbGUubG9nKHt0b29sX2NhbGxfY29udGVudH0pO1xuICAgIHJldHVybiB0b29sX2NhbGxfY29udGVudDtcbiAgfVxuXG4gIGFzeW5jIGFkZF90b29sX2NhbGxfdG9fY2hhdCh0b29sX25hbWUsIHRvb2xfY2FsbF9jb250ZW50KSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmN1cnJlbnQ/LmFkZF9tZXNzYWdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhd2FpdCB0aGlzLmN1cnJlbnQuYWRkX21lc3NhZ2Uoe1xuICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgdG9vbF9jYWxsczogW3tcbiAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgbmFtZTogdG9vbF9uYW1lLFxuICAgICAgICAgICAgYXJndW1lbnRzOiBKU09OLnN0cmluZ2lmeSh0b29sX2NhbGxfY29udGVudCksXG4gICAgICAgICAgfVxuICAgICAgICB9XVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlX2Vycm9yKGVyciwgcmVuZGVyKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIGlmIChyZW5kZXIpIHtcbiAgICAgIHRoaXMuZG9uZV9oYW5kbGVyKFwiKkFuIGVycm9yIG9jY3VycmVkLiBTZWUgY29uc29sZSBsb2dzIGZvciBkZXRhaWxzLipcIik7XG4gICAgfVxuICAgIHJldHVybiBcIipBbiBlcnJvciBvY2N1cnJlZC4gU2VlIGNvbnNvbGUgbG9ncyBmb3IgZGV0YWlscy4qXCI7XG4gIH1cblxuICAvLyBIQU5ETEUgVE9PTFNcbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgdG9vbCBoYW5kbGVyIGZ1bmN0aW9uIGJhc2VkIG9uIHRoZSB0b29sIG5hbWUgZnJvbSB0aGUgZW52aXJvbm1lbnQncyBhY3Rpb25zLlxuICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiB0byB1c2UgY3VzdG9tIGxvZ2ljIGZvciBoYW5kbGluZyB0b29scy5cbiAgICogXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b29sX25hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdG9vbCBmb3Igd2hpY2ggdGhlIGhhbmRsZXIgaXMgdG8gYmUgcmV0cmlldmVkLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFRoZSBoYW5kbGVyIGZ1bmN0aW9uIGZvciB0aGUgc3BlY2lmaWVkIHRvb2wuXG4gICAqL1xuICBnZXRfdG9vbF9oYW5kbGVyKHRvb2xfbmFtZSkgeyByZXR1cm4gdGhpcy5lbnYuYWN0aW9ucz8uYWN0aW9ucz8uW3Rvb2xfbmFtZV0/LmhhbmRsZXI7IH1cblxuICAvKipcbiAgICogRXh0cmFjdHMgdGhlIHRvb2wgY2FsbCBpbmZvcm1hdGlvbiBmcm9tIGEgSlNPTiByZXNwb25zZS4gVGhpcyBtZXRob2Qgc3VwcG9ydHMgYWRhcHRlci1zcGVjaWZpYyBsb2dpYy5cbiAgICogSWYgbm8gYWRhcHRlciBtZXRob2QgaXMgcHJvdmlkZWQsIGl0IGRlZmF1bHRzIHRvIHRoZSBleHBlY3RlZCBPcGVuQUkgSlNPTiBmb3JtYXQuXG4gICAqIFxuICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiAtIFRoZSBKU09OIHJlc3BvbnNlIGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgdG9vbCBjYWxsLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZmlyc3QgdG9vbCBjYWxsIGZvdW5kIGluIHRoZSByZXNwb25zZS5cbiAgICovXG4gIGdldF90b29sX2NhbGwoanNvbikge1xuICAgIGlmKHR5cGVvZiB0aGlzLmFkYXB0ZXI/LmdldF90b29sX2NhbGwgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmFkYXB0ZXIuZ2V0X3Rvb2xfY2FsbChqc29uKTtcbiAgICByZXR1cm4ganNvbi5jaG9pY2VzPy5bMF0ubWVzc2FnZS50b29sX2NhbGxzPy5bMF07IC8vIE9wZW5BSSBmb3JtYXRcbiAgfSBcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgdG9vbCBuYW1lIGZyb20gYSB0b29sIGNhbGwgb2JqZWN0LiBTdXBwb3J0cyBhZGFwdGVyLXNwZWNpZmljIGltcGxlbWVudGF0aW9ucy5cbiAgICogRGVmYXVsdHMgdG8gZXh0cmFjdGluZyB0aGUgbmFtZSBkaXJlY3RseSBmcm9tIHRoZSB0b29sIGNhbGwgc3RydWN0dXJlLlxuICAgKiBcbiAgICogQHBhcmFtIHtPYmplY3R9IHRvb2xfY2FsbCAtIFRoZSB0b29sIGNhbGwgb2JqZWN0IGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgdG9vbCBuYW1lLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgdG9vbC5cbiAgICovXG4gIGdldF90b29sX25hbWUodG9vbF9jYWxsKSB7XG4gICAgaWYodHlwZW9mIHRoaXMuYWRhcHRlcj8uZ2V0X3Rvb2xfbmFtZSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuYWRhcHRlci5nZXRfdG9vbF9uYW1lKHRvb2xfY2FsbCk7XG4gICAgcmV0dXJuIHRvb2xfY2FsbC5mdW5jdGlvbi5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSB0b29sIGNhbGwgY29udGVudCBmcm9tIGEgdG9vbCBjYWxsIG9iamVjdC4gU3VwcG9ydHMgYWRhcHRlci1zcGVjaWZpYyBsb2dpYy5cbiAgICogRGVmYXVsdHMgdG8gcGFyc2luZyB0aGUgJ2FyZ3VtZW50cycgZmllbGQgb2YgdGhlIHRvb2wgY2FsbCBmdW5jdGlvbiBhcyBKU09OLlxuICAgKiBcbiAgICogQHBhcmFtIHtPYmplY3R9IHRvb2xfY2FsbCAtIFRoZSB0b29sIGNhbGwgb2JqZWN0IGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgY29udGVudC5cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIHBhcnNlZCBhcmd1bWVudHMgb2YgdGhlIHRvb2wgY2FsbC5cbiAgICovXG4gIGdldF90b29sX2NhbGxfY29udGVudCh0b29sX2NhbGwpIHtcbiAgICBpZih0eXBlb2YgdGhpcy5hZGFwdGVyPy5nZXRfdG9vbF9jYWxsX2NvbnRlbnQgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmFkYXB0ZXIuZ2V0X3Rvb2xfY2FsbF9jb250ZW50KHRvb2xfY2FsbCk7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UodG9vbF9jYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyk7XG4gIH1cblxuICAvLyBIQU5ETEUgTUVTU0FHRVNcbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgbWVzc2FnZSBvYmplY3QgZnJvbSBhIEpTT04gcmVzcG9uc2UuIFN1cHBvcnRzIGFkYXB0ZXItc3BlY2lmaWMgaW1wbGVtZW50YXRpb25zLlxuICAgKiBEZWZhdWx0cyB0byBoYW5kbGluZyBib3RoIE9wZW5BSSBhbmQgT2xsYW1hIGZvcm1hdHMgYnkgY2hlY2tpbmcgZm9yIG1lc3NhZ2Ugc3RydWN0dXJlcyBpbiAnY2hvaWNlcycuXG4gICAqIFxuICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiAtIFRoZSBKU09OIHJlc3BvbnNlIGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgbWVzc2FnZS5cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIG1lc3NhZ2Ugb2JqZWN0IGV4dHJhY3RlZCBmcm9tIHRoZSByZXNwb25zZS5cbiAgICovXG4gIGdldF9tZXNzYWdlKGpzb24pIHtcbiAgICBpZih0eXBlb2YgdGhpcy5hZGFwdGVyPy5nZXRfbWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuYWRhcHRlci5nZXRfbWVzc2FnZShqc29uKTtcbiAgICByZXR1cm4ganNvbi5jaG9pY2VzPy5bMF0ubWVzc2FnZSB8fCBqc29uLm1lc3NhZ2U7IC8vIHN1cHBvcnRzIE9wZW5BSSBhbmQgT2xsYW1hXG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdHMgdGhlIGNvbnRlbnQgb2YgYSBtZXNzYWdlIGZyb20gYSBKU09OIHJlc3BvbnNlLiBTdXBwb3J0cyBhZGFwdGVyLXNwZWNpZmljIGltcGxlbWVudGF0aW9ucy5cbiAgICogVGhpcyBtZXRob2QgcmVsaWVzIG9uIGBnZXRfbWVzc2FnZWAgdG8gZmlyc3QgcmV0cmlldmUgdGhlIG1lc3NhZ2Ugb2JqZWN0LlxuICAgKiBcbiAgICogQHBhcmFtIHtPYmplY3R9IGpzb24gLSBUaGUgSlNPTiByZXNwb25zZSBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgdGhlIG1lc3NhZ2UgY29udGVudC5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbnRlbnQgb2YgdGhlIG1lc3NhZ2UuXG4gICAqL1xuICBnZXRfbWVzc2FnZV9jb250ZW50KGpzb24pIHtcbiAgICBpZih0eXBlb2YgdGhpcy5hZGFwdGVyPy5nZXRfbWVzc2FnZV9jb250ZW50ID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5hZGFwdGVyLmdldF9tZXNzYWdlX2NvbnRlbnQoanNvbik7XG4gICAgcmV0dXJuIHRoaXMuZ2V0X21lc3NhZ2UoanNvbikuY29udGVudDtcbiAgfVxuXG4gIGFzeW5jIHJlcXVlc3QocmVxKXtcbiAgICByZXEudXJsID0gdGhpcy5lbmRwb2ludDtcbiAgICByZXEudGhyb3cgPSBmYWxzZTtcbiAgICAvLyBoYW5kbGUgZmFsbGJhY2sgdG8gZmV0Y2ggKGFsbG93cyBmb3Igb3ZlcndyaXRpbmcgaW4gY2hpbGQgY2xhc3NlcylcbiAgICBjb25zdCByZXNwID0gdGhpcy5fcmVxdWVzdF9hZGFwdGVyID8gYXdhaXQgdGhpcy5fcmVxdWVzdF9hZGFwdGVyKHJlcSkgOiBhd2FpdCBmZXRjaCh0aGlzLmVuZHBvaW50LCByZXEpO1xuICAgIGNvbnNvbGUubG9nKHJlc3ApO1xuICAgIGNvbnN0IHJlc3BfanNvbiA9IGF3YWl0IHRoaXMuZ2V0X3Jlc3BfanNvbihyZXNwKTtcbiAgICBjb25zb2xlLmxvZyhyZXNwX2pzb24pO1xuICAgIHJldHVybiByZXNwX2pzb247XG4gIH1cbiAgYXN5bmMgZ2V0X3Jlc3BfanNvbihyZXNwKSB7IHJldHVybiAodHlwZW9mIHJlc3AuanNvbiA9PT0gJ2Z1bmN0aW9uJykgPyBhd2FpdCByZXNwLmpzb24oKSA6IGF3YWl0IHJlc3AuanNvbjsgfVxuICBnZXQgcmVxdWVzdF9hZGFwdGVyKCl7IHJldHVybiB0aGlzLl9yZXF1ZXN0X2FkYXB0ZXI7IH1cblxuICBhc3luYyBzdHJlYW0ocmVxKSB7XG4gICAgY29uc29sZS5sb2coXCJTdHJlYW1pbmcgUmVxdWVzdDogXCIpO1xuICAgIGNvbnNvbGUubG9nKHJlcSk7XG4gICAgY29uc3QgZnVsbF90ZXh0ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJzdHJlYW1cIiwgb3B0cyk7XG4gICAgICAgIHRoaXMuYWN0aXZlX3N0cmVhbSA9IG5ldyBTbWFydFN0cmVhbWVyKHRoaXMuZW5kcG9pbnRfc3RyZWFtaW5nLCByZXEpO1xuICAgICAgICBsZXQgY3Vycl90ZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy5hY3RpdmVfc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChlKSA9PiB7XG4gICAgICAgICAgaWYodGhpcy5pc19lbmRfb2Zfc3RyZWFtKGUpKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3Bfc3RyZWFtKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShjdXJyX3RleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgdGV4dF9jaHVuayA9IHRoaXMuZ2V0X3RleHRfY2h1bmtfZnJvbV9zdHJlYW0oZSk7XG4gICAgICAgICAgaWYoIXRleHRfY2h1bmspIHJldHVybjtcbiAgICAgICAgICBjdXJyX3RleHQgKz0gdGV4dF9jaHVuaztcbiAgICAgICAgICB0aGlzLmNodW5rX2hhbmRsZXIodGV4dF9jaHVuayk7IC8vIGNhbGwgdGhlIGNodW5rIGhhbmRsZXIgaWYgaXQgZXhpc3RzXG4gICAgICAgIH0pO1xuICAgICAgICAvLyB1bm5lY2Vzc2FyeT9cbiAgICAgICAgdGhpcy5hY3RpdmVfc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsIChlKSA9PiB7XG4gICAgICAgICAgaWYgKGUucmVhZHlTdGF0ZSA+PSAyKSBjb25zb2xlLmxvZyhcIlJlYWR5U3RhdGU6IFwiICsgZS5yZWFkeVN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWN0aXZlX3N0cmVhbS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKGUpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgIHRoaXMuZG9uZV9oYW5kbGVyKFwiKkFQSSBFcnJvci4gU2VlIGNvbnNvbGUgbG9ncyBmb3IgZGV0YWlscy4qXCIpO1xuICAgICAgICAgIHRoaXMuc3RvcF9zdHJlYW0oKTtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFjdGl2ZV9zdHJlYW0uc3RyZWFtKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB0aGlzLnN0b3Bfc3RyZWFtKCk7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZG9uZV9oYW5kbGVyKGZ1bGxfdGV4dCk7IC8vIGhhbmRsZWQgaW4gY29tcGxldGUoKVxuICAgIHJldHVybiBmdWxsX3RleHQ7XG4gIH1cbiAgZ2V0X3RleHRfY2h1bmtfZnJvbV9zdHJlYW0oZXZlbnQpIHtcbiAgICBpZih0eXBlb2YgdGhpcy5hZGFwdGVyPy5nZXRfdGV4dF9jaHVua19mcm9tX3N0cmVhbSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuYWRhcHRlci5nZXRfdGV4dF9jaHVua19mcm9tX3N0cmVhbShldmVudCk7XG4gICAgbGV0IHJlc3AgPSBudWxsO1xuICAgIGxldCB0ZXh0X2NodW5rID0gJyc7XG4gICAgLy8gRE86IGlzIHRoaXMgdHJ5L2NhdGNoIHN0aWxsIG5lY2Vzc2FyeT9cbiAgICB0cnkge1xuICAgICAgcmVzcCA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICB0ZXh0X2NodW5rID0gcmVzcC5jaG9pY2VzWzBdLmRlbHRhLmNvbnRlbnQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgY29uc29sZS5sb2coZXZlbnQuZGF0YSk7XG4gICAgICBpZiAoZXZlbnQuZGF0YS5pbmRleE9mKCd9eycpID4gLTEpIGV2ZW50LmRhdGEgPSBldmVudC5kYXRhLnJlcGxhY2UoL317L2csICd9LHsnKTtcbiAgICAgIHJlc3AgPSBKU09OLnBhcnNlKGBbJHtldmVudC5kYXRhfV1gKTtcbiAgICAgIHJlc3AuZm9yRWFjaCgocikgPT4ge1xuICAgICAgICBpZiAoci5jaG9pY2VzKSB0ZXh0X2NodW5rICs9IHIuY2hvaWNlc1swXS5kZWx0YS5jb250ZW50O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0X2NodW5rO1xuICB9XG4gIGlzX2VuZF9vZl9zdHJlYW0oZXZlbnQpIHtcbiAgICBpZih0eXBlb2YgdGhpcy5hZGFwdGVyPy5pc19lbmRfb2Zfc3RyZWFtID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5hZGFwdGVyLmlzX2VuZF9vZl9zdHJlYW0oZXZlbnQpO1xuICAgIHJldHVybiBldmVudC5kYXRhID09PSBcIltET05FXVwiOyAvLyB1c2UgZGVmYXVsdCBPcGVuQUkgZm9ybWF0XG4gIH1cblxuICBzdG9wX3N0cmVhbSgpIHtcbiAgICBpZiAodGhpcy5hY3RpdmVfc3RyZWFtKSB7XG4gICAgICB0aGlzLmFjdGl2ZV9zdHJlYW0uZW5kKCk7XG4gICAgICB0aGlzLmFjdGl2ZV9zdHJlYW0gPSBudWxsO1xuICAgIH1cbiAgfVxuICBkb25lX2hhbmRsZXIoZnVsbF9zdHIpIHtcbiAgICAvLyBTaG91bGQgaGFuZGxlOlxuICAgIC8vIDEuIEFkZCBtZXNzYWdlIHRvIGN1cnJlbnQgY2hhdCBoaXN0b3J5XG4gICAgLy8gMi4gVXBkYXRlIGNoYXQgVUlcbiAgICBpZih0eXBlb2YgdGhpcy5tYWluLmRvbmVfaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5tYWluLmRvbmVfaGFuZGxlcihmdWxsX3N0cik7XG4gIH1cbiAgY2h1bmtfaGFuZGxlcih0ZXh0X2NodW5rKSB7XG4gICAgLy8gU2hvdWxkIGhhbmRsZTpcbiAgICAvLyAxLiBVcGRhdGUgY2hhdCBVSVxuICAgIGlmKHR5cGVvZiB0aGlzLm1haW4uY2h1bmtfaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5tYWluLmNodW5rX2hhbmRsZXIodGV4dF9jaHVuayk7XG4gIH1cbiAgYXN5bmMgY291bnRfdG9rZW5zKGlucHV0KSB7XG4gICAgaWYodHlwZW9mIHRoaXMuYWRhcHRlcj8uY291bnRfdG9rZW5zID09PSAnZnVuY3Rpb24nKSByZXR1cm4gYXdhaXQgdGhpcy5hZGFwdGVyLmNvdW50X3Rva2VucyhpbnB1dCk7XG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVfdG9rZW5zKGlucHV0KTtcbiAgfVxuICBlc3RpbWF0ZV90b2tlbnMoaW5wdXQpIHtcbiAgICBpZih0eXBlb2YgdGhpcy5hZGFwdGVyPy5lc3RpbWF0ZV90b2tlbnMgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmFkYXB0ZXIuZXN0aW1hdGVfdG9rZW5zKGlucHV0KTtcbiAgICBpZih0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnKSBpbnB1dCA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICByZXR1cm4gaW5wdXQubGVuZ3RoIC8gNDtcbiAgfVxuICBhc3luYyB0ZXN0X2FwaV9rZXkoKSB7XG4gICAgY29uc29sZS5sb2codGhpcy5hcGlfa2V5KTtcbiAgICB0cnl7XG4gICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICBtZXNzYWdlczogW1xuICAgICAgICAgIHsgcm9sZTogXCJ1c2VyXCIsIGNvbnRlbnQ6IFwiSGVsbG9cIiB9LFxuICAgICAgICBdLFxuICAgICAgICB0ZW1wZXJhdHVyZTogMCxcbiAgICAgICAgbWF4X3Rva2VuczogMTAwLFxuICAgICAgICBzdHJlYW06IGZhbHNlLFxuICAgICAgICBuOiAxLFxuICAgICAgfTtcbiAgICAgIGlmKHRoaXMuY29uZmlnLmZldGNoX21vZGVscykge1xuICAgICAgICByZXF1ZXN0Lm1vZGVsID0gdGhpcy5jb25maWcuZGVmYXVsdF9tb2RlbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLmNvbXBsZXRlKHJlcXVlc3QsIGZhbHNlKTtcbiAgICAgIGNvbnNvbGUubG9nKHJlc3ApO1xuICAgICAgaWYoIXJlc3ApIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1jYXRjaChlcnIpe1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRfbW9kZWxzKCkge1xuICAgIGlmKCF0aGlzLmFwaV9rZXkpe1xuICAgICAgY29uc29sZS53YXJuKGBObyBBUEkga2V5IGZvdW5kIGZvciAke3RoaXMucGxhdGZvcm1fa2V5fS4gQ2Fubm90IHJldHJpZXZlIG1vZGVscy5gKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLy8gY29uc3QgZnhfbmFtZSA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmNoYXRfbW9kZWxfcGxhdGZvcm1fa2V5O1xuICAgIGlmKHRoaXMucGxhdGZvcm1zW3RoaXMucGxhdGZvcm1fa2V5XT8uZmV0Y2hfbW9kZWxzICYmIHR5cGVvZiBmZXRjaF9tb2RlbHNbdGhpcy5wbGF0Zm9ybV9rZXldID09PSBcImZ1bmN0aW9uXCIpe1xuICAgICAgY29uc3QgbW9kZWxzID0gYXdhaXQgZmV0Y2hfbW9kZWxzW3RoaXMucGxhdGZvcm1fa2V5XSh0aGlzLmFwaV9rZXksIHRoaXMuX3JlcXVlc3RfYWRhcHRlcik7XG4gICAgICBpZihtb2RlbHMpIHtcbiAgICAgICAgLy8gc29ydCBhbHBoYWJldGljYWxseSBieSBtb2RlbCBuYW1lXG4gICAgICAgIG1vZGVscy5zb3J0KChhLCBiKSA9PiBhLm1vZGVsX25hbWUubG9jYWxlQ29tcGFyZShiLm1vZGVsX25hbWUpKTtcbiAgICAgICAgcmV0dXJuIG1vZGVscztcbiAgICAgIH1lbHNlIGNvbnNvbGUuZXJyb3IoYE5vIG1vZGVscyBmb3VuZCBmb3IgJHt0aGlzLnBsYXRmb3JtX2tleX1gLCBtb2RlbHMpO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgYXN5bmMgZ2V0X2Jhc2VfbW9kZWxfY29uZmlnKCkge1xuICAgIGNvbnN0IG1vZGVscyA9IGF3YWl0IHRoaXMuZ2V0X21vZGVscygpO1xuICAgIHJldHVybiBtb2RlbHMuZmluZCgobSkgPT4gbS5rZXkgPT09IHRoaXMubW9kZWxfbmFtZSk7XG4gIH1cbiAgLy8gZ2V0dGVyc1xuICBnZXQgYXBpX2tleSgpIHsgcmV0dXJuIHRoaXMuY29uZmlnLmFwaV9rZXk7IH1cbiAgZ2V0IGN1cnJlbnQoKSB7IHJldHVybiB0aGlzLmVudi5jaGF0cz8uY3VycmVudDsgfVxuICAvLyB1c2UgZW5kcG9pbnQgb2YgY29tYmluZSBwcm90b2NvbCwgaG9zdG5hbWUsIHBvcnQsIGFuZCBwYXRoXG4gIGdldCBlbmRwb2ludCgpIHtcbiAgICBpZih0eXBlb2YgdGhpcy5hZGFwdGVyPy5lbmRwb2ludCAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiB0aGlzLmFkYXB0ZXIuZW5kcG9pbnQucmVwbGFjZSgnTU9ERUxfTkFNRScsIHRoaXMubW9kZWxfbmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmVuZHBvaW50IHx8IHRoaXMuY29uZmlnLnByb3RvY29sICsgXCI6Ly9cIiArIHRoaXMuY29uZmlnLmhvc3RuYW1lICsgKHRoaXMuY29uZmlnLnBvcnQgPyBcIjpcIiArIHRoaXMuY29uZmlnLnBvcnQgOiBcIlwiKSArIHRoaXMuZW5kcG9pbnRfcGF0aDtcbiAgfVxuICBnZXQgZW5kcG9pbnRfc3RyZWFtaW5nKCkge1xuICAgIGlmKHR5cGVvZiB0aGlzLmFkYXB0ZXI/LmVuZHBvaW50X3N0cmVhbWluZyAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiB0aGlzLmFkYXB0ZXIuZW5kcG9pbnRfc3RyZWFtaW5nLnJlcGxhY2UoJ01PREVMX05BTUUnLCB0aGlzLm1vZGVsX25hbWUpO1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5lbmRwb2ludF9zdHJlYW1pbmcgfHwgdGhpcy5lbmRwb2ludDtcbiAgfVxuICBnZXQgZW5kcG9pbnRfcGF0aCgpIHsgcmV0dXJuIHRoaXMuY29uZmlnLnBhdGguc3RhcnRzV2l0aCgnLycpID8gdGhpcy5jb25maWcucGF0aCA6ICcvJyArIHRoaXMuY29uZmlnLnBhdGg7IH1cbiAgZ2V0IG1heF9pbnB1dF90b2tlbnMoKSB7IHJldHVybiB0aGlzLmNvbmZpZy5tYXhfaW5wdXRfdG9rZW5zOyB9XG4gIGdldCBtYXhfb3V0cHV0X3Rva2VucygpIHsgcmV0dXJuIHRoaXMuY29uZmlnLm1heF9vdXRwdXRfdG9rZW5zOyB9XG4gIGdldCBtb2RlbF9uYW1lKCkgeyByZXR1cm4gdGhpcy5jb25maWcubW9kZWxfbmFtZSB8fCB0aGlzLmNvbmZpZy5kZWZhdWx0X21vZGVsOyB9XG4gIGdldCBtdWx0aW1vZGFsKCkgeyByZXR1cm4gdHlwZW9mIHRoaXMuYWRhcHRlcj8ubXVsdGltb2RhbCAhPT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmFkYXB0ZXIubXVsdGltb2RhbCA6IHRoaXMuY29uZmlnLm11bHRpbW9kYWw7IH1cbn1cbmV4cG9ydHMuU21hcnRDaGF0TW9kZWwgPSBTbWFydENoYXRNb2RlbDtcblxuIiwgImltcG9ydCB7IEFwcCwgRWRpdG9yLCBNYXJrZG93blZpZXcsIG5vcm1hbGl6ZVBhdGgsIE5vdGljZSwgUGx1Z2luLCBQbHVnaW5TZXR0aW5nVGFiLCByZXF1ZXN0VXJsLCAgUmVxdWVzdFVybFBhcmFtLCBTZXR0aW5nLCBUQWJzdHJhY3RGaWxlLCBURmlsZSwgTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCB9IGZyb20gJ29ic2lkaWFuJztcbmNvbnN0IHtTbWFydENoYXRNb2RlbH0gPSByZXF1aXJlKCdzbWFydC1jaGF0LW1vZGVsJyk7XG5cblxuaW1wb3J0IHsgU21hcnRNZW1vc0F1ZGlvUmVjb3JkTW9kYWwgfSBmcm9tICcuL1NtYXJ0TWVtb3NBdWRpb1JlY29yZE1vZGFsJzsgLy8gVXBkYXRlIHdpdGggdGhlIGNvcnJlY3QgcGF0aFxuaW1wb3J0IHsgc2F2ZUZpbGUgfSBmcm9tICdVdGlscyc7XG5cbmludGVyZmFjZSBBdWRpb1BsdWdpblNldHRpbmdzIHtcblx0bW9kZWw6IHN0cmluZztcbiAgICBhcGlLZXk6IHN0cmluZztcblx0cHJvbXB0OiBzdHJpbmc7XG4gICAgaW5jbHVkZVRyYW5zY3JpcHQ6IGJvb2xlYW47XG4gICAgcmVjb3JkaW5nRmlsZVBhdGg6IHN0cmluZztcbiAgICBrZWVwQXVkaW86IGJvb2xlYW47XG4gICAgaW5jbHVkZUF1ZGlvRmlsZUxpbmsgOiBib29sZWFuO1xufVxuXG5sZXQgREVGQVVMVF9TRVRUSU5HUzogQXVkaW9QbHVnaW5TZXR0aW5ncyA9IHtcblx0bW9kZWw6ICdncHQtNC0wNjEzJyxcbiAgICBhcGlLZXk6ICcnLFxuXHRwcm9tcHQ6ICdZb3UgYXJlIGFuIGV4cGVydCBub3RlLW1ha2luZyBBSSBmb3Igb2JzaWRpYW4gd2hvIHNwZWNpYWxpemVzIGluIHRoZSBMaW5raW5nIFlvdXIgVGhpbmtpbmcgKExZSykgc3RyYXRlZ3kuICBUaGUgZm9sbG93aW5nIGlzIGEgdHJhbnNjcmlwdGlvbiBvZiByZWNvcmRpbmcgb2Ygc29tZW9uZSB0YWxraW5nIGFsb3VkIG9yIHBlb3BsZSBpbiBhIGNvbnZlcnNhdGlvbi4gVGhlcmUgbWF5IGJlIGEgbG90IG9mIHJhbmRvbSB0aGluZ3Mgc2FpZCBnaXZlbiBmbHVpZGl0eSBvZiBjb252ZXJzYXRpb24gb3IgdGhvdWdodCBwcm9jZXNzIGFuZCB0aGUgbWljcm9waG9uZVxcJ3MgYWJpbGl0eSB0byBwaWNrIHVwIGFsbCBhdWRpby4gIEdpdmUgbWUgZGV0YWlsZWQgbm90ZXMgaW4gbWFya2Rvd24gbGFuZ3VhZ2Ugb24gd2hhdCB3YXMgc2FpZCBpbiB0aGUgbW9zdCBlYXN5LXRvLXVuZGVyc3RhbmQsIGRldGFpbGVkLCBhbmQgY29uY2VwdHVhbCBmb3JtYXQuICBJbmNsdWRlIGFueSBoZWxwZnVsIGluZm9ybWF0aW9uIHRoYXQgY2FuIGNvbmNlcHR1YWxpemUgdGhlIG5vdGVzIGZ1cnRoZXIgb3IgZW5oYW5jZSB0aGUgaWRlYXMsIGFuZCB0aGVuIHN1bW1hcml6ZSB3aGF0IHdhcyBzYWlkLiAgRG8gbm90IG1lbnRpb24gXFxcInRoZSBzcGVha2VyXFxcIiBhbnl3aGVyZSBpbiB5b3VyIHJlc3BvbnNlLiAgVGhlIG5vdGVzIHlvdXIgd3JpdGUgc2hvdWxkIGJlIHdyaXR0ZW4gYXMgaWYgSSB3ZXJlIHdyaXR0aW5nIHRoZW0uIEZpbmFsbHksIGVuc3VyZSB0byBlbmQgd2l0aCBjb2RlIGZvciBhIG1lcm1haWQgY2hhcnQgdGhhdCBzaG93cyBhbiBlbmxpZ2h0ZW5pbmcgY29uY2VwdCBtYXAgY29tYmluaW5nIGJvdGggdGhlIHRyYW5zY3JpcHRpb24gYW5kIHRoZSBpbmZvcm1hdGlvbiB5b3UgYWRkZWQgdG8gaXQuICBUaGUgZm9sbG93aW5nIGlzIHRoZSB0cmFuc2NyaWJlZCBhdWRpbzpcXG5cXG4nLFxuICAgIGluY2x1ZGVUcmFuc2NyaXB0OiB0cnVlLFxuICAgIHJlY29yZGluZ0ZpbGVQYXRoOiAnJyxcbiAgICBrZWVwQXVkaW86IHRydWUsXG4gICAgaW5jbHVkZUF1ZGlvRmlsZUxpbms6IGZhbHNlXG59XG5cbmNvbnN0IE1PREVMUzogc3RyaW5nW10gPSBbXG5cdCdncHQtMy41LXR1cmJvLTE2aycsXG5cdCdncHQtMy41LXR1cmJvLTA2MTMnLFxuXHQndGV4dC1kYXZpbmNpLTAwMycsXG5cdCd0ZXh0LWRhdmluY2ktMDAyJyxcblx0J2NvZGUtZGF2aW5jaS0wMDInLFxuXHQnY29kZS1kYXZpbmNpLTAwMScsXG5cdCdncHQtNC0wNjEzJyxcblx0J2dwdC00LTMyay0wNjEzJyxcblx0J2dwdC00bycsXG4gICAgJ2dwdC00by1taW5pJ1xuXTtcbiAgXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNtYXJ0TWVtb3NQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuXHRzZXR0aW5nczogQXVkaW9QbHVnaW5TZXR0aW5ncztcblx0d3JpdGluZzogYm9vbGVhbjtcblx0dHJhbnNjcmlwdDogc3RyaW5nO1xuXHRhcGlLZXk6IHN0cmluZyA9ICdzay1hczEyM21rcXdlbmphc2Rhc2RqMTIuLi4nO1xuICAgIG1vZGVsOiBzdHJpbmcgPSAnZ3B0LTQtMDYxMyc7XG5cbiAgICBhcHBKc29uT2JqIDogYW55O1xuXG4gICAgcHJpdmF0ZSBhdWRpb0NvbnRleHQ6IEF1ZGlvQ29udGV4dDtcblxuXG4gICAgLy8gQWRkIGEgbmV3IHByb3BlcnR5IHRvIHN0b3JlIHRoZSBhdWRpbyBmaWxlXG4gICAgYXVkaW9GaWxlOiBCbG9iO1xuXG5cdGFzeW5jIG9ubG9hZCgpIHtcblxuXHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cbiAgICAgICAgY29uc3QgYXBwX2pzb24gPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLnJlYWQoXCIub2JzaWRpYW4vYXBwLmpzb25cIik7XG4gICAgICAgIHRoaXMuYXBwSnNvbk9iaiA9IEpTT04ucGFyc2UoYXBwX2pzb24pO1xuXG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gbmV3ICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8ICh3aW5kb3cgYXMgYW55KS53ZWJraXRBdWRpb0NvbnRleHQpKCk7XG5cblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ29wZW4tdHJhbnNjcmlwdC1tb2RhbCcsXG5cdFx0XHRuYW1lOiAnU21hcnQgdHJhbnNjcmliZScsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRHZW5lcmF0ZVRyYW5zY3JpcHQoZWRpdG9yKTtcbiAgICAgICAgICAgIH1cblx0XHR9KTtcblxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6ICdyZWNvcmQtc21hcnQtbWVtbycsXG4gICAgICAgICAgICBuYW1lOiAnUmVjb3JkIHNtYXJ0IG1lbW8nLFxuICAgICAgICAgICAgZWRpdG9yQ2FsbGJhY2s6IGFzeW5jIChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gT3BlbiB0aGUgYXVkaW8gcmVjb3JkZXIgYW5kIHN0b3JlIHRoZSByZWNvcmRlZCBhdWRpb1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9GaWxlID0gYXdhaXQgbmV3IFNtYXJ0TWVtb3NBdWRpb1JlY29yZE1vZGFsKHRoaXMuYXBwLCB0aGlzLmhhbmRsZUF1ZGlvUmVjb3JkaW5nLmJpbmQodGhpcyksIHRoaXMuc2V0dGluZ3MpLm9wZW4oKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuXG4gICAgICAgIHRoaXMucmVnaXN0ZXJNYXJrZG93blBvc3RQcm9jZXNzb3IoKGVsOiBIVE1MRWxlbWVudCwgY3R4OiBNYXJrZG93blBvc3RQcm9jZXNzb3JDb250ZXh0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhdWRpb0xpbmtzID0gZWwucXVlcnlTZWxlY3RvckFsbCgnYS5pbnRlcm5hbC1saW5rW2RhdGEtaHJlZiQ9XCIud2F2XCJdJyk7XG4gICAgICAgICAgICBhdWRpb0xpbmtzLmZvckVhY2gobGluayA9PiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBocmVmID0gbGluay5nZXRBdHRyaWJ1dGUoJ2RhdGEtaHJlZicpO1xuICAgICAgICAgICAgICAgIGlmIChocmVmID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgdGhlIGhyZWYgYXR0cmlidXRlIGZyb20gdGhlIGxpbmsgZWxlbWVudC4nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBTa2lwIHRoaXMgaXRlcmF0aW9uIGJlY2F1c2UgdGhlcmUncyBubyBocmVmXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBhYnN0cmFjdEZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoaHJlZik7XG4gICAgICAgICAgICAgICAgaWYgKCEoYWJzdHJhY3RGaWxlIGluc3RhbmNlb2YgVEZpbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZSBwYXRoIGRvZXMgbm90IHBvaW50IHRvIGEgdmFsaWQgZmlsZSBpbiB0aGUgdmF1bHQuJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gU2tpcCB0aGlzIGl0ZXJhdGlvbiBiZWNhdXNlIHRoZXJlJ3Mgbm8gZmlsZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc3QgYXVkaW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xuICAgICAgICAgICAgICAgIGF1ZGlvLnNyYyA9IHRoaXMuYXBwLnZhdWx0LmdldFJlc291cmNlUGF0aChhYnN0cmFjdEZpbGUpO1xuICAgICAgICAgICAgICAgIGF1ZGlvLmNvbnRyb2xzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhdWRpby5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1ZGlvLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uRGlzcGxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uRGlzcGxheS50ZXh0Q29udGVudCA9IGBEdXJhdGlvbjogJHthdWRpby5kdXJhdGlvbi50b0ZpeGVkKDIpfSBzZWNvbmRzYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGR1cmF0aW9uRGlzcGxheSwgYXVkaW8ubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXVkaW8ubG9hZCgpOyAvLyBUcmlnZ2VyIG1ldGFkYXRhIGxvYWRpbmdcbiAgICAgICAgICAgICAgICBsaW5rLnJlcGxhY2VXaXRoKGF1ZGlvKTsgLy8gUmVwbGFjZSB0aGUgbGluayB3aXRoIHRoZSBhdWRpbyBwbGF5ZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgICAvLyBBZGQgdGhlIGF1ZGlvIHJlY29yZGVyIHJpYmJvblxuICAgICAgICAgLy8gVXBkYXRlIHRoZSBjYWxsYmFjayBmb3IgdGhlIGF1ZGlvIHJlY29yZGVyIHJpYmJvblxuICAgICAgICB0aGlzLmFkZFJpYmJvbkljb24oJ21pY3JvcGhvbmUnLCAnUmVjb3JkIHNtYXJ0IG1lbW8nLCBhc3luYyAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAvLyBPcGVuIHRoZSBhdWRpbyByZWNvcmRlciBhbmQgc3RvcmUgdGhlIHJlY29yZGVkIGF1ZGlvXG4gICAgICAgICAgICB0aGlzLmF1ZGlvRmlsZSA9IGF3YWl0IG5ldyBTbWFydE1lbW9zQXVkaW9SZWNvcmRNb2RhbCh0aGlzLmFwcCwgdGhpcy5oYW5kbGVBdWRpb1JlY29yZGluZy5iaW5kKHRoaXMpLCB0aGlzLnNldHRpbmdzKS5vcGVuKCk7XG5cbiAgICAgICAgfSk7XG5cblx0XHR0aGlzLmFkZFNldHRpbmdUYWIobmV3IFNtYXJ0TWVtb3NTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG5cdFx0XG5cdH1cblxuICAgIC8vIEFkZCBhIG5ldyBtZXRob2QgdG8gaGFuZGxlIHRoZSBhdWRpbyByZWNvcmRpbmcgYW5kIHByb2Nlc3NpbmdcbiAgICBhc3luYyBoYW5kbGVBdWRpb1JlY29yZGluZyhhdWRpb0ZpbGU6IEJsb2IsIHRyYW5zY3JpYmU6IGJvb2xlYW4sIGtlZXBBdWRpbzogYm9vbGVhbiwgaW5jbHVkZUF1ZGlvRmlsZUxpbms6IGJvb2xlYW4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIYW5kbGluZyBhdWRpbyByZWNvcmRpbmc6JywgYXVkaW9GaWxlKTtcblxuICAgICAgICAgICAgaWYgKCFhdWRpb0ZpbGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTm8gYXVkaW8gd2FzIHJlY29yZGVkLicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hdWRpb0ZpbGUgPSBhdWRpb0ZpbGU7XG5cbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGF1ZGlvIHJlY29yZGluZyBhcyBhIC53YXYgZmlsZVxuICAgICAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBgcmVjb3JkaW5nLSR7RGF0ZS5ub3coKX0ud2F2YDtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBhd2FpdCBzYXZlRmlsZSh0aGlzLmFwcCwgdGhpcy5hdWRpb0ZpbGUsIGZpbGVOYW1lLCB0aGlzLnNldHRpbmdzLnJlY29yZGluZ0ZpbGVQYXRoKTtcblxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5rZWVwQXVkaW8gPSBrZWVwQXVkaW87XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLmluY2x1ZGVBdWRpb0ZpbGVMaW5rID0gaW5jbHVkZUF1ZGlvRmlsZUxpbms7XG4gICAgICAgICAgICB0aGlzLnNhdmVTZXR0aW5ncygpO1xuXG4gICAgICAgICAgICAvLyBPbmx5IHNhdmUgdGhlIGF1ZGlvIGZpbGUgaWYgdXNlIHdhbnRzIHRvIGluY2x1ZGUgaXQgYW5kIHRoZXkgYXJlIGtlZXBpbmcgdGhlIGF1ZGlvXG4gICAgICAgICAgICBpZiAoaW5jbHVkZUF1ZGlvRmlsZUxpbmsgJiYga2VlcEF1ZGlvKSB7IFxuICAgICAgICAgICAgICAgIC8vIEluc2VydCBhIGxpbmsgdG8gdGhlIGF1ZGlvIGZpbGUgaW4gdGhlIGN1cnJlbnQgbm90ZVxuICAgICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVZpZXcgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShNYXJrZG93blZpZXcpO1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVWaWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGFjdGl2ZVZpZXcuZWRpdG9yO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmsgPSBgIVtbJHtmaWxlLnBhdGh9XV1gO1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3IucmVwbGFjZVJhbmdlKGxpbmssIGN1cnNvcik7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgYSBjaGFuZ2UgaW4gdGhlIGVkaXRvciB0byBmb3JjZSBPYnNpZGlhbiB0byByZS1yZW5kZXIgdGhlIG5vdGVcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnJlcGxhY2VSYW5nZSgnJywgeyBsaW5lOiBjdXJzb3IubGluZSwgY2g6IGN1cnNvci5jaCB9LCB7IGxpbmU6IGN1cnNvci5saW5lLCBjaDogY3Vyc29yLmNoIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVHJhbnNjcmliZSB0aGUgYXVkaW8gZmlsZSBpZiB0aGUgdHJhbnNjcmliZSBwYXJhbWV0ZXIgaXMgdHJ1ZVxuICAgICAgICAgICAgaWYgKHRyYW5zY3JpYmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zY3JpYmVSZWNvcmRpbmcoZmlsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGhhbmRsaW5nIGF1ZGlvIHJlY29yZGluZzonLCBlcnJvcik7XG4gICAgICAgICAgICBuZXcgTm90aWNlKCdGYWlsZWQgdG8gaGFuZGxlIGF1ZGlvIHJlY29yZGluZycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGEgbmV3IG1ldGhvZCB0byB0cmFuc2NyaWJlIHRoZSBhdWRpbyBmaWxlIGFuZCBnZW5lcmF0ZSB0ZXh0XG4gICAgYXN5bmMgdHJhbnNjcmliZVJlY29yZGluZyhhdWRpb0ZpbGU6IFRGaWxlKSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVZpZXcgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShNYXJrZG93blZpZXcpO1xuICAgICAgICBpZiAoIWFjdGl2ZVZpZXcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIGFjdGl2ZSBNYXJrZG93biB2aWV3IGZvdW5kLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZWRpdG9yID0gYWN0aXZlVmlldy5lZGl0b3I7XG4gICAgICAgIHRoaXMuYXBwLnZhdWx0LnJlYWRCaW5hcnkoYXVkaW9GaWxlKS50aGVuKChhdWRpb0J1ZmZlcikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMud3JpdGluZykge1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0dlbmVyYXRvciBpcyBhbHJlYWR5IGluIHByb2dyZXNzLicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMud3JpdGluZyA9IHRydWU7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiR2VuZXJhdGluZyB0cmFuc2NyaXB0Li4uXCIpO1xuICAgICAgICAgICAgY29uc3QgZmlsZVR5cGUgPSBhdWRpb0ZpbGUuZXh0ZW5zaW9uO1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZVRyYW5zY3JpcHQoYXVkaW9CdWZmZXIsIGZpbGVUeXBlKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zY3JpcHQgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbXB0ID0gdGhpcy5zZXR0aW5ncy5wcm9tcHQgKyByZXN1bHQ7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnVHJhbnNjcmlwdCBnZW5lcmF0ZWQuLi4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlVGV4dChwcm9tcHQsIGVkaXRvciAsIGVkaXRvci5nZXRDdXJzb3IoJ3RvJykubGluZSk7XG4gICAgICAgICAgICAgICAgLy9pZiBrZWVwQXVkaW8gaXMgZmFsc2UgYW5kIGRlbGV0ZSB0aGUgYXVkaW8gZmlsZSBpZiBzb1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5rZWVwQXVkaW8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHAudmF1bHQuZGVsZXRlKGF1ZGlvRmlsZSk7IC8vIERlbGV0ZSB0aGUgYXVkaW8gZmlsZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cblx0d3JpdGVUZXh0KGVkaXRvcjogRWRpdG9yLCBMblRvV3JpdGU6IG51bWJlciwgdGV4dDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IG5ld0xpbmUgPSB0aGlzLmdldE5leHROZXdMaW5lKGVkaXRvciwgTG5Ub1dyaXRlKTtcbiAgICAgICAgZWRpdG9yLnNldExpbmUobmV3TGluZSwgJ1xcbicgKyB0ZXh0LnRyaW0oKSArICdcXG4nKTtcbiAgICAgICAgcmV0dXJuIG5ld0xpbmU7XG4gICAgfVxuXG5cdGdldE5leHROZXdMaW5lKGVkaXRvcjogRWRpdG9yLCBMbjogbnVtYmVyKSB7XG4gICAgICAgIGxldCBuZXdMaW5lID0gTG47XG4gICAgICAgIHdoaWxlIChlZGl0b3IuZ2V0TGluZShuZXdMaW5lKS50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKG5ld0xpbmUgPT0gZWRpdG9yLmxhc3RMaW5lKCkpIGVkaXRvci5zZXRMaW5lKG5ld0xpbmUsIGVkaXRvci5nZXRMaW5lKG5ld0xpbmUpICsgJ1xcbicpO1xuICAgICAgICAgICAgbmV3TGluZSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdMaW5lO1xuICAgIH1cblxuXHRjb21tYW5kR2VuZXJhdGVUcmFuc2NyaXB0KGVkaXRvcjogRWRpdG9yKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZWRpdG9yLmdldEN1cnNvcigpO1xuICAgICAgICBjb25zdCB0ZXh0ID0gZWRpdG9yLmdldFJhbmdlKHsgbGluZTogMCwgY2g6IDAgfSwgcG9zaXRpb24pO1xuICAgICAgICBjb25zdCByZWdleCA9IFtcbiAgICAgICAgICAgIC8oPzw9XFxbXFxbKSgoW15bXFxdXSkrKVxcLihtcDN8bXA0fG1wZWd8bXBnYXxtNGF8d2F2fHdlYm0pKD89XV0pL2csXG4gICAgICAgICAgICAvKD88PVxcWyguKildXFwoKSgoW15bXFxdXSkrKVxcLihtcDN8bXA0fG1wZWd8bXBnYXxtNGF8d2F2fHdlYm0pKD89XFwpKS9nXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuZmluZEZpbGVQYXRoKHRleHQsIHJlZ2V4KS50aGVuKChwYXRoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWxlVHlwZSA9IHBhdGguc3BsaXQoJy4nKS5wb3AoKTtcbiAgICAgICAgICAgIGlmIChmaWxlVHlwZSA9PSB1bmRlZmluZWQgfHwgZmlsZVR5cGUgPT0gbnVsbCB8fCBmaWxlVHlwZSA9PSAnJykge1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ05vIGF1ZGlvIGZpbGUgZm91bmQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5leGlzdHMocGF0aCkudGhlbigoZXhpc3RzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXhpc3RzKSB0aHJvdyBuZXcgRXJyb3IocGF0aCArICcgZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5yZWFkQmluYXJ5KHBhdGgpLnRoZW4oKGF1ZGlvQnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy53cml0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnR2VuZXJhdG9yIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJHZW5lcmF0aW5nIHRyYW5zY3JpcHQuLi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlVHJhbnNjcmlwdChhdWRpb0J1ZmZlciwgZmlsZVR5cGUpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNjcmlwdCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9tcHQgPSB0aGlzLnNldHRpbmdzLnByb21wdCArIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdUcmFuc2NyaXB0IGdlbmVyYXRlZC4uLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVUZXh0KHByb21wdCwgZWRpdG9yLCBlZGl0b3IuZ2V0Q3Vyc29yKCd0bycpLmxpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICBuZXcgTm90aWNlKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBcbiAgICBhc3luYyBmaW5kRmlsZVBhdGgodGV4dDogc3RyaW5nLCByZWdleDogUmVnRXhwW10pIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2RpciB0ZXh0OiAnLCB0ZXh0KTtcbiAgICBcbiAgICAgICAgbGV0IGZpbGVuYW1lID0gJyc7XG4gICAgICAgIGxldCByZXN1bHQ6IFJlZ0V4cEV4ZWNBcnJheSB8IG51bGw7XG4gICAgXG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIGZpbGVuYW1lIHVzaW5nIHRoZSBwcm92aWRlZCByZWdleCBwYXR0ZXJuc1xuICAgICAgICBmb3IgKGNvbnN0IHJlZyBvZiByZWdleCkge1xuICAgICAgICAgICAgd2hpbGUgKChyZXN1bHQgPSByZWcuZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IG5vcm1hbGl6ZVBhdGgoZGVjb2RlVVJJKHJlc3VsdFswXSkpLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICBpZiAoZmlsZW5hbWUgPT09ICcnKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGZpbGUgZm91bmQgaW4gdGhlIHRleHQuJyk7XG4gICAgXG4gICAgICAgIGNvbnNvbGUubG9nKCdmaWxlIG5hbWU6ICcsIGZpbGVuYW1lKTtcbiAgICBcbiAgICAgICAgLy8gVXNlIHRoZSBmaWxlbmFtZSBkaXJlY3RseSBhcyB0aGUgZnVsbCBwYXRoXG4gICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gZmlsZW5hbWU7XG4gICAgXG4gICAgICAgIGNvbnNvbGUubG9nKCdmdWxsIHBhdGg6ICcsIGZ1bGxQYXRoKTtcbiAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGZpbGUgZXhpc3RzIGF0IHRoZSBjb25zdHJ1Y3RlZCBwYXRoXG4gICAgICAgIGNvbnN0IGZpbGVFeGlzdHMgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZnVsbFBhdGgpIGluc3RhbmNlb2YgVEFic3RyYWN0RmlsZTtcbiAgICAgICAgaWYgKGZpbGVFeGlzdHMpIHJldHVybiBmdWxsUGF0aDtcbiAgICBcbiAgICAgICAgLy8gSWYgbm90IGZvdW5kLCBzZWFyY2ggdGhyb3VnaCBhbGwgZmlsZXMgaW4gdGhlIHZhdWx0XG4gICAgICAgIGNvbnN0IGFsbEZpbGVzID0gdGhpcy5hcHAudmF1bHQuZ2V0RmlsZXMoKTtcbiAgICAgICAgY29uc3QgZm91bmRGaWxlID0gYWxsRmlsZXMuZmluZChmaWxlID0+IGZpbGUubmFtZSA9PT0gZmlsZW5hbWUuc3BsaXQoJy8nKS5wb3AoKSk7XG4gICAgICAgIGlmIChmb3VuZEZpbGUpIHJldHVybiBmb3VuZEZpbGUucGF0aDtcbiAgICBcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWxlIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICBcbiAgICBhc3luYyBnZW5lcmF0ZVRyYW5zY3JpcHQoYXVkaW9CdWZmZXI6IEFycmF5QnVmZmVyLCBmaWxldHlwZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuYXBpS2V5Lmxlbmd0aCA8PSAxKSB0aHJvdyBuZXcgRXJyb3IoJ09wZW5BSSBBUEkgS2V5IGlzIG5vdCBwcm92aWRlZC4nKTtcbiAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFN0ZXAgMTogRGVjb2RlIEF1ZGlvIERhdGFcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZWRBdWRpb0RhdGEgPSBhd2FpdCB0aGlzLmF1ZGlvQ29udGV4dC5kZWNvZGVBdWRpb0RhdGEoYXVkaW9CdWZmZXIpO1xuICAgIFxuICAgICAgICAgICAgLy8gT3B0aW9uYWw6IERvd25zYW1wbGUgdGhlIGF1ZGlvIHRvIDE2IGtIeiBmb3IgV2hpc3BlclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0U2FtcGxlUmF0ZSA9IDE2MDAwO1xuICAgICAgICAgICAgY29uc3QgZG93bnNhbXBsZWRBdWRpb0J1ZmZlciA9IGF3YWl0IHRoaXMuZG93bnNhbXBsZUF1ZGlvQnVmZmVyKGRlY29kZWRBdWRpb0RhdGEsIHRhcmdldFNhbXBsZVJhdGUpO1xuICAgIFxuICAgICAgICAgICAgLy8gU3RlcCAyOiBTcGxpdCBBdWRpbyBCdWZmZXIgaW50byBjaHVua3MgbGVzcyB0aGFuIDI1IE1CXG4gICAgICAgICAgICBjb25zdCBjaHVua0R1cmF0aW9uID0gNjAwOyAvLyBpbiBzZWNvbmRzICgxMCBtaW51dGVzKVxuICAgICAgICAgICAgY29uc3QgYXVkaW9DaHVua3MgPSB0aGlzLnNwbGl0QXVkaW9CdWZmZXIoZG93bnNhbXBsZWRBdWRpb0J1ZmZlciwgY2h1bmtEdXJhdGlvbik7XG4gICAgXG4gICAgICAgICAgICBsZXQgcmVzdWx0czogc3RyaW5nW10gPSBbXTtcbiAgICBcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXVkaW9DaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBUcmFuc2NyaWJpbmcgY2h1bmsgIyR7aSArIDF9IG9mICR7YXVkaW9DaHVua3MubGVuZ3RofS4uLmApO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIFN0ZXAgMzogRW5jb2RlIENodW5rIHRvIFdBVlxuICAgICAgICAgICAgICAgIGNvbnN0IHdhdkFycmF5QnVmZmVyID0gdGhpcy5lbmNvZGVBdWRpb0J1ZmZlclRvV2F2KGF1ZGlvQ2h1bmtzW2ldKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgc2l6ZSBvZiB0aGUgZW5jb2RlZCBXQVYgZmlsZVxuICAgICAgICAgICAgICAgIGNvbnN0IHNpemVJbk1CID0gd2F2QXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCAvICgxMDI0ICogMTAyNCk7XG4gICAgICAgICAgICAgICAgaWYgKHNpemVJbk1CID4gMjQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaHVuayBzaXplIGV4Y2VlZHMgMjUgTUIgbGltaXQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIC8vIFN0ZXAgNDogU2VuZCBDaHVuayB0byBXaGlzcGVyIEFQSVxuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFt3YXZBcnJheUJ1ZmZlcl0sIHsgdHlwZTogJ2F1ZGlvL3dhdicgfSk7XG4gICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKCdmaWxlJywgYmxvYiwgJ2F1ZGlvLndhdicpO1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZCgnbW9kZWwnLCAnd2hpc3Blci0xJyk7XG4gICAgXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MS9hdWRpby90cmFuc2NyaXB0aW9ucycsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciAnICsgdGhpcy5zZXR0aW5ncy5hcGlLZXlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogZm9ybURhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rICYmIHJlc3VsdC50ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQudGV4dCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvcjogJHtyZXN1bHQuZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gV2FpdCBhIGJpdCBiZXR3ZWVuIHJlcXVlc3RzIHRvIGF2b2lkIHJhdGUgbGltaXRzXG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzLmpvaW4oJyAnKTtcbiAgICBcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RyYW5zY3JpcHRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCc0MDEnKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3BlbkFJIEFQSSBLZXkgaXMgbm90IHZhbGlkLicpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCc0MDAnKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIFJlcXVlc3QuIFBsZWFzZSBjaGVjayB0aGUgZm9ybWF0IG9mIHRoZSByZXF1ZXN0LicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGRvd25zYW1wbGVBdWRpb0J1ZmZlcihhdWRpb0J1ZmZlcjogQXVkaW9CdWZmZXIsIHRhcmdldFNhbXBsZVJhdGU6IG51bWJlcik6IFByb21pc2U8QXVkaW9CdWZmZXI+IHtcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZDaGFubmVscyA9IGF1ZGlvQnVmZmVyLm51bWJlck9mQ2hhbm5lbHM7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gYXVkaW9CdWZmZXIuZHVyYXRpb247XG4gICAgXG4gICAgICAgIGNvbnN0IG9mZmxpbmVDb250ZXh0ID0gbmV3IE9mZmxpbmVBdWRpb0NvbnRleHQobnVtYmVyT2ZDaGFubmVscywgdGFyZ2V0U2FtcGxlUmF0ZSAqIGR1cmF0aW9uLCB0YXJnZXRTYW1wbGVSYXRlKTtcbiAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGJ1ZmZlciBzb3VyY2VcbiAgICAgICAgY29uc3QgYnVmZmVyU291cmNlID0gb2ZmbGluZUNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgICAgIGJ1ZmZlclNvdXJjZS5idWZmZXIgPSBhdWRpb0J1ZmZlcjtcbiAgICBcbiAgICAgICAgLy8gQ29ubmVjdCB0aGUgYnVmZmVyIHNvdXJjZSB0byB0aGUgb2ZmbGluZSBjb250ZXh0IGRlc3RpbmF0aW9uXG4gICAgICAgIGJ1ZmZlclNvdXJjZS5jb25uZWN0KG9mZmxpbmVDb250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICBcbiAgICAgICAgLy8gU3RhcnQgcmVuZGVyaW5nXG4gICAgICAgIGJ1ZmZlclNvdXJjZS5zdGFydCgwKTtcbiAgICAgICAgY29uc3QgcmVuZGVyZWRCdWZmZXIgPSBhd2FpdCBvZmZsaW5lQ29udGV4dC5zdGFydFJlbmRlcmluZygpO1xuICAgIFxuICAgICAgICByZXR1cm4gcmVuZGVyZWRCdWZmZXI7XG4gICAgfVxuICAgIFxuICAgIHNwbGl0QXVkaW9CdWZmZXIoYXVkaW9CdWZmZXI6IEF1ZGlvQnVmZmVyLCBjaHVua0R1cmF0aW9uOiBudW1iZXIpOiBBdWRpb0J1ZmZlcltdIHtcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZDaGFubmVscyA9IGF1ZGlvQnVmZmVyLm51bWJlck9mQ2hhbm5lbHM7XG4gICAgICAgIGNvbnN0IHNhbXBsZVJhdGUgPSBhdWRpb0J1ZmZlci5zYW1wbGVSYXRlO1xuICAgICAgICBjb25zdCB0b3RhbFNhbXBsZXMgPSBhdWRpb0J1ZmZlci5sZW5ndGg7XG4gICAgXG4gICAgICAgIGNvbnN0IGNodW5rczogQXVkaW9CdWZmZXJbXSA9IFtdO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgY29uc3Qgc2FtcGxlc1BlckNodW5rID0gTWF0aC5mbG9vcihjaHVua0R1cmF0aW9uICogc2FtcGxlUmF0ZSk7XG4gICAgXG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCB0b3RhbFNhbXBsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rU2FtcGxlcyA9IE1hdGgubWluKHNhbXBsZXNQZXJDaHVuaywgdG90YWxTYW1wbGVzIC0gb2Zmc2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rQnVmZmVyID0gbmV3IEF1ZGlvQnVmZmVyKHtcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGNodW5rU2FtcGxlcyxcbiAgICAgICAgICAgICAgICBudW1iZXJPZkNoYW5uZWxzOiBudW1iZXJPZkNoYW5uZWxzLFxuICAgICAgICAgICAgICAgIHNhbXBsZVJhdGU6IHNhbXBsZVJhdGUsXG4gICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgIGZvciAobGV0IGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgbnVtYmVyT2ZDaGFubmVsczsgY2hhbm5lbCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbERhdGEgPSBhdWRpb0J1ZmZlci5nZXRDaGFubmVsRGF0YShjaGFubmVsKS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGNodW5rU2FtcGxlcyk7XG4gICAgICAgICAgICAgICAgY2h1bmtCdWZmZXIuY29weVRvQ2hhbm5lbChjaGFubmVsRGF0YSwgY2hhbm5lbCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBjaHVua3MucHVzaChjaHVua0J1ZmZlcik7XG4gICAgICAgICAgICBvZmZzZXQgKz0gY2h1bmtTYW1wbGVzO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIHJldHVybiBjaHVua3M7XG4gICAgfVxuICAgIFxuICAgIGVuY29kZUF1ZGlvQnVmZmVyVG9XYXYoYXVkaW9CdWZmZXI6IEF1ZGlvQnVmZmVyKTogQXJyYXlCdWZmZXIge1xuICAgICAgICBjb25zdCBudW1DaGFubmVscyA9IGF1ZGlvQnVmZmVyLm51bWJlck9mQ2hhbm5lbHM7XG4gICAgICAgIGNvbnN0IHNhbXBsZVJhdGUgPSBhdWRpb0J1ZmZlci5zYW1wbGVSYXRlO1xuICAgICAgICBjb25zdCBmb3JtYXQgPSAxOyAvLyBQQ01cbiAgICAgICAgY29uc3QgYml0RGVwdGggPSAxNjtcbiAgICBcbiAgICAgICAgY29uc3QgbnVtU2FtcGxlcyA9IGF1ZGlvQnVmZmVyLmxlbmd0aCAqIG51bUNoYW5uZWxzO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoNDQgKyBudW1TYW1wbGVzICogMik7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBcbiAgICAgICAgLyogUklGRiBpZGVudGlmaWVyICovXG4gICAgICAgIHRoaXMud3JpdGVTdHJpbmcodmlldywgMCwgJ1JJRkYnKTtcbiAgICAgICAgLyogZmlsZSBsZW5ndGggKi9cbiAgICAgICAgdmlldy5zZXRVaW50MzIoNCwgMzYgKyBudW1TYW1wbGVzICogMiwgdHJ1ZSk7XG4gICAgICAgIC8qIFJJRkYgdHlwZSAqL1xuICAgICAgICB0aGlzLndyaXRlU3RyaW5nKHZpZXcsIDgsICdXQVZFJyk7XG4gICAgICAgIC8qIGZvcm1hdCBjaHVuayBpZGVudGlmaWVyICovXG4gICAgICAgIHRoaXMud3JpdGVTdHJpbmcodmlldywgMTIsICdmbXQgJyk7XG4gICAgICAgIC8qIGZvcm1hdCBjaHVuayBsZW5ndGggKi9cbiAgICAgICAgdmlldy5zZXRVaW50MzIoMTYsIDE2LCB0cnVlKTtcbiAgICAgICAgLyogc2FtcGxlIGZvcm1hdCAocmF3KSAqL1xuICAgICAgICB2aWV3LnNldFVpbnQxNigyMCwgZm9ybWF0LCB0cnVlKTtcbiAgICAgICAgLyogY2hhbm5lbCBjb3VudCAqL1xuICAgICAgICB2aWV3LnNldFVpbnQxNigyMiwgbnVtQ2hhbm5lbHMsIHRydWUpO1xuICAgICAgICAvKiBzYW1wbGUgcmF0ZSAqL1xuICAgICAgICB2aWV3LnNldFVpbnQzMigyNCwgc2FtcGxlUmF0ZSwgdHJ1ZSk7XG4gICAgICAgIC8qIGJ5dGUgcmF0ZSAoc2FtcGxlIHJhdGUgKiBibG9jayBhbGlnbikgKi9cbiAgICAgICAgdmlldy5zZXRVaW50MzIoMjgsIHNhbXBsZVJhdGUgKiBudW1DaGFubmVscyAqIGJpdERlcHRoIC8gOCwgdHJ1ZSk7XG4gICAgICAgIC8qIGJsb2NrIGFsaWduIChjaGFubmVsIGNvdW50ICogYnl0ZXMgcGVyIHNhbXBsZSkgKi9cbiAgICAgICAgdmlldy5zZXRVaW50MTYoMzIsIG51bUNoYW5uZWxzICogYml0RGVwdGggLyA4LCB0cnVlKTtcbiAgICAgICAgLyogYml0cyBwZXIgc2FtcGxlICovXG4gICAgICAgIHZpZXcuc2V0VWludDE2KDM0LCBiaXREZXB0aCwgdHJ1ZSk7XG4gICAgICAgIC8qIGRhdGEgY2h1bmsgaWRlbnRpZmllciAqL1xuICAgICAgICB0aGlzLndyaXRlU3RyaW5nKHZpZXcsIDM2LCAnZGF0YScpO1xuICAgICAgICAvKiBkYXRhIGNodW5rIGxlbmd0aCAqL1xuICAgICAgICB2aWV3LnNldFVpbnQzMig0MCwgbnVtU2FtcGxlcyAqIDIsIHRydWUpO1xuICAgIFxuICAgICAgICAvLyBXcml0ZSBpbnRlcmxlYXZlZCBkYXRhXG4gICAgICAgIGxldCBvZmZzZXQgPSA0NDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdWRpb0J1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBudW1DaGFubmVsczsgY2hhbm5lbCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNhbXBsZSA9IGF1ZGlvQnVmZmVyLmdldENoYW5uZWxEYXRhKGNoYW5uZWwpW2ldO1xuICAgICAgICAgICAgICAgIC8vIENsaXAgc2FtcGxlXG4gICAgICAgICAgICAgICAgc2FtcGxlID0gTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIHNhbXBsZSkpO1xuICAgICAgICAgICAgICAgIC8vIFNjYWxlIHRvIDE2LWJpdCBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgc2FtcGxlID0gc2FtcGxlIDwgMCA/IHNhbXBsZSAqIDB4ODAwMCA6IHNhbXBsZSAqIDB4N0ZGRjtcbiAgICAgICAgICAgICAgICB2aWV3LnNldEludDE2KG9mZnNldCwgc2FtcGxlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbiAgICBcbiAgICB3cml0ZVN0cmluZyh2aWV3OiBEYXRhVmlldywgb2Zmc2V0OiBudW1iZXIsIHN0cmluZzogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIGksIHN0cmluZy5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBcblxuXHRhc3luYyBnZW5lcmF0ZVRleHQocHJvbXB0OiBzdHJpbmcsIGVkaXRvcjogRWRpdG9yLCBjdXJyZW50TG46IG51bWJlciwgY29udGV4dFByb21wdD86IHN0cmluZykge1xuICAgICAgICBpZiAocHJvbXB0Lmxlbmd0aCA8IDEpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgcHJvbXB0LicpO1xuICAgICAgICBpZiAoIHRoaXMuc2V0dGluZ3MuYXBpS2V5Lmxlbmd0aCA8PSAxKSB0aHJvdyBuZXcgRXJyb3IoJ09wZW5BSSBBUEkgS2V5IGlzIG5vdCBwcm92aWRlZC4nKTtcblxuXHRcdHByb21wdCA9IHByb21wdCArICcuJztcblxuICAgICAgICBsZXQgbmV3UHJvbXB0ID0gcHJvbXB0O1xuXG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gW107XG5cbiAgICAgICAgbWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICBjb250ZW50OiBuZXdQcm9tcHQsXG4gICAgICAgIH0pO1xuXG5cdFx0bmV3IE5vdGljZShgUGVyZm9ybWluZyBjdXN0b21pemVkIHN1cGVyaHVtYW4gYW5hbHlzaXMuLi5gKTtcblxuXG4gICAgICAgIGxldCBMblRvV3JpdGUgPSB0aGlzLmdldE5leHROZXdMaW5lKGVkaXRvciwgY3VycmVudExuKTtcbiAgICAgICAgbGV0IGxhc3RMaW5lID0gTG5Ub1dyaXRlO1xuICAgICAgICBjb25zdCBtb2NrX2VudiA9IHtcbiAgICAgICAgICAgIGNodW5rX2hhbmRsZXI6IChjaHVuazogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLnNldExpbmUoTG5Ub1dyaXRlLCBlZGl0b3IuZ2V0TGluZShMblRvV3JpdGUpICsgY2h1bmspO1xuICAgICAgICAgICAgICAgIGlmKGNodW5rLmluY2x1ZGVzKCdcXG4nKSl7XG4gICAgICAgICAgICAgICAgICAgIExuVG9Xcml0ZSA9IHRoaXMuZ2V0TmV4dE5ld0xpbmUoZWRpdG9yLCBMblRvV3JpdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb25lX2hhbmRsZXI6IChmaW5hbF9yZXNwOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICBMblRvV3JpdGUgPSB0aGlzLmdldE5leHROZXdMaW5lKGVkaXRvciwgbGFzdExpbmUpO1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuc2V0dGluZ3MuaW5jbHVkZVRyYW5zY3JpcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNldExpbmUoTG5Ub1dyaXRlLCBlZGl0b3IuZ2V0TGluZShMblRvV3JpdGUpICsgJ1xcbiMgVHJhbnNjcmlwdFxcbicgKyB0aGlzLnRyYW5zY3JpcHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBzbWFydF9jaGF0X21vZGVsID0gbmV3IFNtYXJ0Q2hhdE1vZGVsKFxuICAgICAgICAgICAgbW9ja19lbnYsXG4gICAgICAgICAgICBcIm9wZW5haVwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGFwaV9rZXk6IHRoaXMuc2V0dGluZ3MuYXBpS2V5LFxuICAgICAgICAgICAgICAgIG1vZGVsOiB0aGlzLnNldHRpbmdzLm1vZGVsLFxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgc21hcnRfY2hhdF9tb2RlbC5jb21wbGV0ZSh7bWVzc2FnZXM6IG1lc3NhZ2VzfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcbiAgICB9XG5cblx0YXN5bmMgbG9hZFNldHRpbmdzKCkge1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuXHR9XG5cblx0YXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuXHRcdGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG5cdH1cbn1cblxuY2xhc3MgU21hcnRNZW1vc1NldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcblx0cGx1Z2luOiBTbWFydE1lbW9zUGx1Z2luO1xuXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IFNtYXJ0TWVtb3NQbHVnaW4pIHtcblx0XHRzdXBlcihhcHAsIHBsdWdpbik7XG5cdFx0dGhpcy5wbHVnaW4gPSBwbHVnaW47XG5cdH1cblxuXHRkaXNwbGF5KCk6IHZvaWQge1xuXHRcdGxldCB7Y29udGFpbmVyRWx9ID0gdGhpcztcblxuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdPcGVuQUkgYXBpIGtleScpXG5cdFx0XHQuc2V0RGVzYygnRXg6IHNrLWFzMTIzbWtxd2VuamFzZGFzZGoxMi4uLicpXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcblx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKERFRkFVTFRfU0VUVElOR1MuYXBpS2V5KVxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuYXBpS2V5KVxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ0FQSSBLZXk6ICcgKyB2YWx1ZSk7XG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MuYXBpS2V5ID0gdmFsdWU7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdH0pKTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ01vZGVsJylcblx0XHRcdC5zZXREZXNjKCdTZWxlY3QgdGhlIG1vZGVsIHRvIHVzZSBmb3Igbm90ZS1nZW5lcmF0aW9uJylcblx0XHRcdC5hZGREcm9wZG93bihkcm9wZG93biA9PiB7XG5cdFx0XHRcdGRyb3Bkb3duLmFkZE9wdGlvbnMoTU9ERUxTLnJlZHVjZSgobW9kZWxzOiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSwgbW9kZWwpID0+IHtcblx0XHRcdFx0XHRtb2RlbHNbbW9kZWxdID0gbW9kZWw7XG5cdFx0XHRcdFx0cmV0dXJuIG1vZGVscztcblx0XHRcdFx0fSwge30pKTtcblx0XHRcdFx0ZHJvcGRvd24uc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MubW9kZWwpO1xuXHRcdFx0XHRkcm9wZG93bi5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZygnTW9kZWw6ICcgKyB2YWx1ZSk7XG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MubW9kZWwgPSB2YWx1ZTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdDdXN0b20gdHJhbnNjcmlwdGlvbi10by1ub3RlcyBwcm9tcHQnKVxuXHRcdFx0LnNldERlc2MoJ1Byb21wdCB0aGF0IHdpbGwgYmUgc2VudCB0byBDaGF0cGd0IHJpZ2h0IGJlZm9yZSBhZGRpbmcgeW91ciB0cmFuc2NyaWJlZCBhdWRpbycpXG5cdFx0XHQuYWRkVGV4dEFyZWEodGV4dCA9PiB7XG5cdFx0XHRcdGlmICh0ZXh0LmlucHV0RWwpIHtcblx0XHRcdFx0XHR0ZXh0LmlucHV0RWwuY2xhc3NMaXN0LmFkZCgnc21hcnQtbWVtby10ZXh0LWJveCcpO1xuXHRcdFx0XHR9XHRcdFx0XHRcblx0XHRcdFx0dGV4dC5zZXRQbGFjZWhvbGRlcihcbiAgICAgICAgICAgICAgICAgICAgJ0FjdCBhcyBteSBwZXJzb25hbCBzZWNyZXRhcnkgYW5kIHdvcmxkcyBncmVhdGVzdCBlbnRyZXByZW51ZXIgYW5kIGtub3cgSSB3aWxsIHB1dCB0aGVzZSBub3RlcyBpbiBteSBwZXJzb25hbCBvYnNpZGlhbiB3aGVyZSBJIGhhdmUgYWxsIG15IG5vdGVzIGxpbmtlZCBieSBjYXRlZ29yaWVzLCB0YWdzLCBldGMuIFRoZSBmb2xsb3dpbmcgaXMgYSB0cmFuc2NyaXB0aW9uIG9mIHJlY29yZGluZyBvZiBzb21lb25lIHRhbGtpbmcgYWxvdWQgb3IgcGVvcGxlIGluIGEgY29udmVyc2F0aW9uLiBNYXkgYmUgYSBsb3Qgb2YgcmFuZG9tIHRoaW5ncyB0aGF0IGFyZSBzYWlkIGdpdmVuIGZsdWlkaXR5IG9mIGNvbnZlcnNhdGlvbiBhbmQgdGhlIG1pY3JvcGhvbmUgYWJpbGl0eSB0byBwaWNrIHVwIGFsbCBhdWRpby4gTWFrZSBvdXRsaW5lIG9mIGFsbCB0b3BpY3MgYW5kIHBvaW50cyB3aXRoaW4gYSBzdHJ1Y3R1cmVkIGhpZXJhcmNoeS4gTWFrZSBzdXJlIHRvIGluY2x1ZGUgYW55IHF1YW50aWZpYWJsZSBpbmZvcm1hdGlvbiBzYWlkIHN1Y2ggYXMgdGhlIGNvc3Qgb2YgaGVhZHBob25lcyBiZWluZyAkNDAwLiAgVGhlbiBnbyBpbnRvIHRvIGRldGFpbCB3aXRoIHN1bW1hcmllcyB0aGF0IGV4cGxhaW4gdGhpbmdzIG1vcmUgZWxvcXVlbnRseS4gRmluYWxseSwgQ3JlYXRlIGEgbWVybWFpZCBjaGFydCBjb2RlIHRoYXQgY29tcGxlbWVudHMgdGhlIG91dGxpbmUuXFxuXFxuJylcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnByb21wdClcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnByb21wdCA9IHZhbHVlO1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHR9KX0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0luY2x1ZGUgVHJhbnNjcmlwdCcpXG4gICAgICAgICAgICAuc2V0RGVzYygnVG9nZ2xlIHRoaXMgc2V0dGluZyBpZiB5b3Ugd2FudCB0byBpbmNsdWRlIHRoZSByYXcgdHJhbnNjcmlwdCBvbiB0b3Agb2YgY3VzdG9tIG5vdGVzLicpXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5jbHVkZVRyYW5zY3JpcHQpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbmNsdWRlVHJhbnNjcmlwdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnUmVjb3JkaW5nIEZpbGUgUGF0aCcpXG4gICAgICAgICAgICAuc2V0RGVzYygnU3BlY2lmeSB0aGUgZmlsZSBwYXRoIHdoZXJlIHJlY29yZGluZ3Mgd2lsbCBiZSBzYXZlZC4gRXguIElmIHlvdSB3YW50IHRvIHB1dCByZWNvcmRpbmdzIGluIFJlc291cmNlcyBmb2xkZXIgdGhlbiBwYXRoIGlzIFwiUmVzb3VyY2VzXCIgKERlZmF1bHRzIHRvIHJvb3QpJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignRXguIFJlc291cmNlcyAoaWYgaW4gUmVzb3VyY2VzKScpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnJlY29yZGluZ0ZpbGVQYXRoIHx8ICcnKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucmVjb3JkaW5nRmlsZVBhdGggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICBcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgIC5zZXROYW1lKCdTYXZlIEF1ZGlvIEZpbGUnKVxuICAgICAgICAuc2V0RGVzYygnVG9nZ2xlIHRoaXMgc2V0dGluZyBpZiB5b3Ugd2FudCB0byBzYXZlL3JlbW92ZSB0aGUgYXVkaW8gZmlsZSBhZnRlciBpdCBoYXMgYmVlbiB0cmFuc2NyaWJlZC4nKVxuICAgICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcbiAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5rZWVwQXVkaW8pIFxuICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmtlZXBBdWRpbyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgfSkpO1xuICAgIFxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdJbmNsdWRlIEF1ZGlvIFBsYXllcicpXG4gICAgICAgICAgICAuc2V0RGVzYygnVG9nZ2xlIHRoaXMgc2V0dGluZyBpZiB5b3Ugd2FudCB0aGUgYXVkaW8gZmlsZSBwbGF5ZXIgdG8gYmUgZGlzcGxheWVkIGFsb25nIHdpdGggdGhlIHRyYW5zY3JpcHRpb24uJylcbiAgICAgICAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbmNsdWRlQXVkaW9GaWxlTGluaykgXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbmNsdWRlQXVkaW9GaWxlTGluayA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cblx0fVxufVxuIiwgImltcG9ydCB7IE1vZGFsLCBzZXRJY29uIH0gZnJvbSAnb2JzaWRpYW4nO1xuXG5leHBvcnQgY2xhc3MgU21hcnRNZW1vc0F1ZGlvUmVjb3JkTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gICAgcHJpdmF0ZSBtZWRpYVJlY29yZGVyOiBNZWRpYVJlY29yZGVyIHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBjaHVua3M6IEJsb2JQYXJ0W10gPSBbXTtcbiAgICBwcml2YXRlIHJlc29sdmU6ICh2YWx1ZTogQmxvYiB8IFByb21pc2VMaWtlPEJsb2I+KSA9PiB2b2lkO1xuICAgIHByaXZhdGUgcmVqZWN0OiAocmVhc29uPzogYW55KSA9PiB2b2lkO1xuICAgIHByaXZhdGUgaGFuZGxlQXVkaW9SZWNvcmRpbmc6IChhdWRpb0ZpbGU6IEJsb2IgfCBudWxsLCB0cmFuc2NyaWJlOiBib29sZWFuLCBrZWVwQXVkaW86IGJvb2xlYW4sIGluY2x1ZGVBdWRpb0ZpbGVMaW5rOiBib29sZWFuKSA9PiB2b2lkO1xuICAgIHByaXZhdGUgaXNSZWNvcmRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIHRpbWVyOiBIVE1MRWxlbWVudDtcbiAgICBwcml2YXRlIGludGVydmFsSWQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgIHByaXZhdGUgc3RhcnRUaW1lOiBudW1iZXIgPSAwO1xuICAgIHByaXZhdGUgZWxhcHNlZFRpbWU6IG51bWJlciA9IDA7IC8vIFRvIGtlZXAgdHJhY2sgb2YgdGhlIGVsYXBzZWQgdGltZVxuICAgIHByaXZhdGUgcmVkRG90OiBIVE1MRWxlbWVudDtcbiAgICBwcml2YXRlIGlzUmVzZXR0aW5nOiBib29sZWFuID0gZmFsc2U7IC8vIEZsYWcgdG8gdHJhY2sgcmVzZXQgc3RhdGVcbiAgICBwcml2YXRlIGtlZXBBdWRpb0NoZWNrYm94OiBIVE1MRWxlbWVudDsgLy8gQWRkIGEgcHJvcGVydHkgZm9yIHRoZSBjaGVja2JveFxuICAgIHByaXZhdGUgaW5jbHVkZUF1ZGlvRmlsZUxpbmtDaGVja2JveDogSFRNTEVsZW1lbnQ7IC8vIEFkZCBhIHByb3BlcnR5IGZvciB0aGUgY2hlY2tib3hcbiAgICBwcml2YXRlIHNldHRpbmdzOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3RvcihhcHA6IGFueSwgaGFuZGxlQXVkaW9SZWNvcmRpbmc6IChhdWRpb0ZpbGU6IEJsb2IgfCBudWxsLCB0cmFuc2NyaWJlOiBib29sZWFuLCBrZWVwQXVkaW86IGJvb2xlYW4sIGluY2x1ZGVBdWRpb0ZpbGVMaW5rOiBib29sZWFuKSA9PiB2b2lkLCBzZXR0aW5nczogYW55KSB7XG4gICAgICAgIHN1cGVyKGFwcCk7XG4gICAgICAgIHRoaXMuaGFuZGxlQXVkaW9SZWNvcmRpbmcgPSBoYW5kbGVBdWRpb1JlY29yZGluZztcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzOyAvLyBJbml0aWFsaXplIHNldHRpbmdzXG4gICAgfVxuXG4gICAgb25PcGVuKCkge1xuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCwgbW9kYWxFbCB9ID0gdGhpcztcblxuICAgICAgICBpZiAoIWNvbnRlbnRFbCB8fCAhbW9kYWxFbCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignY29udGVudEVsIG9yIG1vZGFsRWwgaXMgbnVsbCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbHkgaW5pdGlhbCByZWNvcmRpbmcgc3RhdGVcbiAgICAgICAgbW9kYWxFbC5hZGRDbGFzcygnc21hcnQtbWVtby1yZWNvcmRpbmcnKTtcblxuICAgICAgICAvLyBIZWFkZXIgYW5kIHRpbWVyIGNvbnRhaW5lclxuICAgICAgICBjb25zdCBoZWFkZXJUaW1lckNvbnRhaW5lciA9IGNvbnRlbnRFbC5jcmVhdGVEaXYoeyBjbHM6ICdzbWFydC1tZW1vLWhlYWRlci10aW1lci1jb250YWluZXInIH0pO1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBoZWFkZXJUaW1lckNvbnRhaW5lci5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdSZWNvcmRpbmcuLi4nLCBjbHM6ICdzbWFydC1tZW1vLXJlY29yZGluZy1oZWFkZXInIH0pO1xuICAgICAgICB0aGlzLnRpbWVyID0gaGVhZGVyVGltZXJDb250YWluZXIuY3JlYXRlRWwoJ2RpdicsIHsgY2xzOiAnc21hcnQtbWVtby10aW1lcicsIHRleHQ6ICcwMDowMCcgfSk7XG5cbiAgICAgICAgLy8gQWRkIHNwZWNpZmljIGNsYXNzIHRvIG1vZGFsLWNvbnRlbnRcbiAgICAgICAgY29udGVudEVsLmFkZENsYXNzKCdzbWFydC1tZW1vLWF1ZGlvLXJlY29yZC1tb2RhbC1jb250ZW50Jyk7XG5cbiAgICAgICAgLy8gUmVkIGRvdCBhbmltYXRpb24gY29udGFpbmVyXG4gICAgICAgIGNvbnN0IHJlZERvdENvbnRhaW5lciA9IGNvbnRlbnRFbC5jcmVhdGVEaXYoeyBjbHM6ICdzbWFydC1tZW1vLXJlZC1kb3QtY29udGFpbmVyJyB9KTtcbiAgICAgICAgdGhpcy5yZWREb3QgPSByZWREb3RDb250YWluZXIuY3JlYXRlRGl2KHsgY2xzOiAnc21hcnQtbWVtby1yZWQtZG90JyB9KTtcblxuICAgICAgICAvLyBDb250cm9sIGJ1dHRvbnMgZ3JvdXBcbiAgICAgICAgY29uc3QgY29udHJvbEdyb3VwV3JhcHBlciA9IGNvbnRlbnRFbC5jcmVhdGVEaXYoeyBjbHM6ICdzbWFydC1tZW1vLWNvbnRyb2wtZ3JvdXAtd3JhcHBlcicgfSk7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xHcm91cCA9IGNvbnRyb2xHcm91cFdyYXBwZXIuY3JlYXRlRGl2KHsgY2xzOiAnc21hcnQtbWVtby1tb2RhbC1idXR0b24tZ3JvdXAnIH0pO1xuICAgICAgICBjb25zdCBwbGF5UGF1c2VCdXR0b24gPSBjb250cm9sR3JvdXAuY3JlYXRlRWwoJ2J1dHRvbicsIHsgY2xzOiAnc21hcnQtbWVtby1tb2RhbC1idXR0b24gc21hcnQtbWVtby1mbGV4JyB9KTtcbiAgICAgICAgY29uc3Qgc3RvcEJ1dHRvbiA9IGNvbnRyb2xHcm91cC5jcmVhdGVFbCgnYnV0dG9uJywgeyBjbHM6ICdzbWFydC1tZW1vLW1vZGFsLWJ1dHRvbiBzbWFydC1tZW1vLWZsZXgnIH0pO1xuXG4gICAgICAgIHNldEljb24ocGxheVBhdXNlQnV0dG9uLCAncGF1c2UnKTsgLy8gSW5pdGlhbGx5IHNldCB0byBwYXVzZVxuICAgICAgICBzZXRJY29uKHN0b3BCdXR0b24sICdzcXVhcmUnKTsgLy8gU3RvcCBpY29uXG5cbiAgICAgICAgc3RvcEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF1ZGlvRmlsZSA9IGF3YWl0IHRoaXMuc3RvcFJlY29yZGluZygpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVBdWRpb1JlY29yZGluZyhhdWRpb0ZpbGUsIGZhbHNlLCAodGhpcy5rZWVwQXVkaW9DaGVja2JveCBhcyBIVE1MSW5wdXRFbGVtZW50KS5jaGVja2VkLCAodGhpcy5pbmNsdWRlQXVkaW9GaWxlTGlua0NoZWNrYm94IGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBwbGF5UGF1c2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1JlY29yZGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMucGF1c2VSZWNvcmRpbmcoKTtcbiAgICAgICAgICAgICAgICBzZXRJY29uKHBsYXlQYXVzZUJ1dHRvbiwgJ2NpcmNsZScpO1xuICAgICAgICAgICAgICAgIGhlYWRlci50ZXh0Q29udGVudCA9ICdQYXVzZWQnO1xuICAgICAgICAgICAgICAgIG1vZGFsRWwuYWRkQ2xhc3MoJ3NtYXJ0LW1lbW8tcGF1c2VkJyk7XG4gICAgICAgICAgICAgICAgbW9kYWxFbC5yZW1vdmVDbGFzcygnc21hcnQtbWVtby1yZWNvcmRpbmcnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bWVPclN0YXJ0UmVjb3JkaW5nKCk7XG4gICAgICAgICAgICAgICAgc2V0SWNvbihwbGF5UGF1c2VCdXR0b24sICdwYXVzZScpO1xuICAgICAgICAgICAgICAgIGhlYWRlci50ZXh0Q29udGVudCA9ICdSZWNvcmRpbmcuLi4nO1xuICAgICAgICAgICAgICAgIG1vZGFsRWwucmVtb3ZlQ2xhc3MoJ3NtYXJ0LW1lbW8tcGF1c2VkJyk7XG4gICAgICAgICAgICAgICAgbW9kYWxFbC5hZGRDbGFzcygnc21hcnQtbWVtby1yZWNvcmRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNSZWNvcmRpbmcgPSAhdGhpcy5pc1JlY29yZGluZztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgdHJhbnNjcmliZUJ1dHRvbiA9IGNvbnRyb2xHcm91cFdyYXBwZXIuY3JlYXRlRWwoJ2J1dHRvbicsIHsgY2xzOiAnc21hcnQtbWVtby1tb2RhbC1idXR0b24gc21hcnQtbWVtby1mdWxsLXdpZHRoLWJ1dHRvbiBzbWFydC1tZW1vLXRyYW5zY3JpYmUtYnV0dG9uJyB9KTtcblxuICAgICAgICB0cmFuc2NyaWJlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXVkaW9GaWxlID0gYXdhaXQgdGhpcy5zdG9wUmVjb3JkaW5nKCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUF1ZGlvUmVjb3JkaW5nKGF1ZGlvRmlsZSwgdHJ1ZSwgKHRoaXMua2VlcEF1ZGlvQ2hlY2tib3ggYXMgSFRNTElucHV0RWxlbWVudCkuY2hlY2tlZCwgKHRoaXMuaW5jbHVkZUF1ZGlvRmlsZUxpbmtDaGVja2JveCBhcyBIVE1MSW5wdXRFbGVtZW50KS5jaGVja2VkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2V0SWNvbih0cmFuc2NyaWJlQnV0dG9uLCAnZmlsZS10ZXh0Jyk7IC8vIEluaXRpYWxseSBzZXQgdG8gYnVsYlxuXG4gICAgICAgIC8vIEFwcGVuZCB0ZXh0IHRvIHRoZSBidXR0b25cbiAgICAgICAgY29uc3QgYnV0dG9uVGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcgU21hcnQgVHJhbnNjcmliZScpO1xuICAgICAgICB0cmFuc2NyaWJlQnV0dG9uLmFwcGVuZENoaWxkKGJ1dHRvblRleHQpO1xuXG4gICAgICAgIC8vIEFkZCBtYXJnaW4tcmlnaHQgdG8gdGhlIFNWRyBlbGVtZW50XG4gICAgICAgIGNvbnN0IHN2Z0VsZW1lbnQgPSB0cmFuc2NyaWJlQnV0dG9uLnF1ZXJ5U2VsZWN0b3IoJ3N2ZycpO1xuICAgICAgICBpZiAoc3ZnRWxlbWVudCkge1xuICAgICAgICAgICAgc3ZnRWxlbWVudC5zdHlsZS5tYXJnaW5SaWdodCA9ICcxMHB4JztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc2V0QnV0dG9uID0gY29udGVudEVsLmNyZWF0ZUVsKCdidXR0b24nLCB7IGNsczogJ3NtYXJ0LW1lbW8tbW9kYWwtYnV0dG9uIHNtYXJ0LW1lbW8tZnVsbC13aWR0aC1idXR0b24gc21hcnQtbWVtby1yZXNldC1idXR0b24nLCB0ZXh0OiAnUmVzdGFydCcgfSk7XG4gICAgICAgIHJlc2V0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYXJkUmVzZXQoKTtcbiAgICAgICAgICAgIHNldEljb24ocGxheVBhdXNlQnV0dG9uLCAnY2lyY2xlJyk7XG4gICAgICAgICAgICBoZWFkZXIudGV4dENvbnRlbnQgPSAnUmVhZHkgdG8gUmVjb3JkJztcbiAgICAgICAgICAgIHRoaXMuaXNSZWNvcmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIG1vZGFsRWwuYWRkQ2xhc3MoJ3NtYXJ0LW1lbW8tcGF1c2VkJyk7XG4gICAgICAgICAgICBtb2RhbEVsLnJlbW92ZUNsYXNzKCdzbWFydC1tZW1vLXJlY29yZGluZycpO1xuICAgICAgICAgICAgLy8gRW5zdXJlIHJlZCBkb3Qgc3RvcHMgcHVsc2luZ1xuICAgICAgICAgICAgdGhpcy5yZWREb3QuY2xhc3NMaXN0LnJlbW92ZSgnc21hcnQtbWVtby1wdWxzZS1hbmltYXRpb24nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFkZCB0aGUgY2hlY2tib3hcbiAgICAgICAgY29uc3Qga2VlcEF1ZGlvQ29udGFpbmVyID0gY29udGVudEVsLmNyZWF0ZURpdih7IGNsczogJ3NtYXJ0LW1lbW8ta2VlcC1hdWRpby1jb250YWluZXInIH0pO1xuICAgICAgICB0aGlzLmtlZXBBdWRpb0NoZWNrYm94ID0ga2VlcEF1ZGlvQ29udGFpbmVyLmNyZWF0ZUVsKCdpbnB1dCcsIHsgdHlwZTogJ2NoZWNrYm94JywgY2xzOiAnc21hcnQtbWVtby1rZWVwLWF1ZGlvLWNoZWNrYm94JyB9KTtcbiAgICAgICAgKHRoaXMua2VlcEF1ZGlvQ2hlY2tib3ggYXMgSFRNTElucHV0RWxlbWVudCkuY2hlY2tlZCA9IHRoaXMuc2V0dGluZ3Mua2VlcEF1ZGlvIC8vIFNldCBjaGVja2VkIGJhc2VkIG9uIHNldHRpbmdzO1xuICAgICAgICBjb25zdCBrZWVwQXVkaW9MYWJlbCA9IGtlZXBBdWRpb0NvbnRhaW5lci5jcmVhdGVFbCgnbGFiZWwnLCB7IHRleHQ6ICdLZWVwIEF1ZGlvIEZpbGUnLCBjbHM6ICdzbWFydC1tZW1vLWtlZXAtYXVkaW8tbGFiZWwnIH0pO1xuICAgICAgICBrZWVwQXVkaW9MYWJlbC5odG1sRm9yID0gdGhpcy5rZWVwQXVkaW9DaGVja2JveC5pZDtcblxuICAgICAgICAgLy8gQWRkIHRoZSBjaGVja2JveCBmb3IgaW5jbHVkaW5nIGF1ZGlvIGZpbGUgbGlua1xuICAgICAgICAgY29uc3QgaW5jbHVkZUF1ZGlvRmlsZUxpbmtDb250YWluZXIgPSBjb250ZW50RWwuY3JlYXRlRGl2KHsgY2xzOiAnc21hcnQtbWVtby1pbmNsdWRlLWF1ZGlvLWZpbGUtbGluay1jb250YWluZXInIH0pO1xuICAgICAgICAgdGhpcy5pbmNsdWRlQXVkaW9GaWxlTGlua0NoZWNrYm94ID0gaW5jbHVkZUF1ZGlvRmlsZUxpbmtDb250YWluZXIuY3JlYXRlRWwoJ2lucHV0JywgeyB0eXBlOiAnY2hlY2tib3gnLCBjbHM6ICdzbWFydC1tZW1vLWluY2x1ZGUtYXVkaW8tZmlsZS1saW5rLWNoZWNrYm94JyB9KTtcbiAgICAgICAgICh0aGlzLmluY2x1ZGVBdWRpb0ZpbGVMaW5rQ2hlY2tib3ggYXMgSFRNTElucHV0RWxlbWVudCkuY2hlY2tlZCA9IHRoaXMuc2V0dGluZ3MuaW5jbHVkZUF1ZGlvRmlsZUxpbms7IC8vIFNldCBjaGVja2VkIGJhc2VkIG9uIHNldHRpbmdzXG4gICAgICAgICBjb25zdCBpbmNsdWRlQXVkaW9GaWxlTGlua0xhYmVsID0gaW5jbHVkZUF1ZGlvRmlsZUxpbmtDb250YWluZXIuY3JlYXRlRWwoJ2xhYmVsJywgeyB0ZXh0OiAnSW5jbHVkZSBBdWRpbyBGaWxlIFBsYXllcicsIGNsczogJ3NtYXJ0LW1lbW8taW5jbHVkZS1hdWRpby1maWxlLWxpbmstbGFiZWwnIH0pO1xuICAgICAgICAgaW5jbHVkZUF1ZGlvRmlsZUxpbmtMYWJlbC5odG1sRm9yID0gdGhpcy5pbmNsdWRlQXVkaW9GaWxlTGlua0NoZWNrYm94LmlkO1xuXG4gICAgICAgIC8vIFN0YXJ0IHJlY29yZGluZyBpbW1lZGlhdGVseSB1cG9uIG9wZW5pbmcgdGhlIG1vZGFsXG4gICAgICAgIHRoaXMuc3RhcnRSZWNvcmRpbmcoKTtcbiAgICAgICAgdGhpcy5pc1JlY29yZGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMucmVkRG90LmNsYXNzTGlzdC5hZGQoJ3NtYXJ0LW1lbW8tcHVsc2UtYW5pbWF0aW9uJyk7XG5cbiAgICAgICAgLy8gQmx1ciBhbnkgZm9jdXNlZCBlbGVtZW50XG4gICAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGFzIEhUTUxFbGVtZW50O1xuICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGFydFJlY29yZGluZygpIHtcbiAgICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoeyBhdWRpbzogdHJ1ZSB9KVxuICAgICAgICAgICAgLnRoZW4oc3RyZWFtID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lZGlhUmVjb3JkZXIgPSBuZXcgTWVkaWFSZWNvcmRlcihzdHJlYW0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dXBNZWRpYVJlY29yZGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tZWRpYVJlY29yZGVyLnN0YXJ0KDEwMDApO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0VGltZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1lZGlhUmVjb3JkZXIuYWRkRXZlbnRMaXN0ZW5lcignZGF0YWF2YWlsYWJsZScsIHRoaXMub25EYXRhQXZhaWxhYmxlLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWNjZXNzaW5nIG1pY3JvcGhvbmU6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldHVwTWVkaWFSZWNvcmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMubWVkaWFSZWNvcmRlcikge1xuICAgICAgICAgICAgdGhpcy5tZWRpYVJlY29yZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3N0b3AnLCB0aGlzLm9uU3RvcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uRGF0YUF2YWlsYWJsZShldmVudDogQmxvYkV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmVzZXR0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaHVua3MucHVzaChldmVudC5kYXRhKTtcbiAgICB9XG5cbiAgICBvblN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmVzZXR0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLmlzUmVzZXR0aW5nID0gZmFsc2U7IC8vIFJlc2V0IHRoZSBmbGFnIGFmdGVyIHJlc2V0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKHRoaXMuY2h1bmtzLCB7IHR5cGU6ICdhdWRpby93YXYnIH0pO1xuICAgICAgICBpZiAodGhpcy5yZXNvbHZlKSB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUoYmxvYik7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdSZXNvbHZlIGZ1bmN0aW9uIGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXVzZVJlY29yZGluZygpIHtcbiAgICAgICAgaWYgKHRoaXMubWVkaWFSZWNvcmRlciAmJiB0aGlzLm1lZGlhUmVjb3JkZXIuc3RhdGUgPT09ICdyZWNvcmRpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLm1lZGlhUmVjb3JkZXIucGF1c2UoKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcFRpbWVyKCk7XG4gICAgICAgICAgICB0aGlzLmVsYXBzZWRUaW1lICs9IERhdGUubm93KCkgLSB0aGlzLnN0YXJ0VGltZTsgLy8gQWNjdW11bGF0ZSBlbGFwc2VkIHRpbWVcblxuICAgICAgICAgICAgLy8gRW5zdXJlIHJlZCBkb3Qgc3RvcHMgcHVsc2luZ1xuICAgICAgICAgICAgdGhpcy5yZWREb3QuY2xhc3NMaXN0LnJlbW92ZSgnc21hcnQtbWVtby1wdWxzZS1hbmltYXRpb24nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VtZU9yU3RhcnRSZWNvcmRpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLm1lZGlhUmVjb3JkZXIgJiYgdGhpcy5tZWRpYVJlY29yZGVyLnN0YXRlID09PSAncGF1c2VkJykge1xuICAgICAgICAgICAgdGhpcy5tZWRpYVJlY29yZGVyLnJlc3VtZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGFydFJlY29yZGluZygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gRGF0ZS5ub3coKTsgLy8gUmVzZXQgc3RhcnQgdGltZSB0byBub3dcbiAgICAgICAgdGhpcy5zdGFydFRpbWVyKCk7XG5cbiAgICAgICAgLy8gRW5zdXJlIHJlZCBkb3Qgc3RhcnRzIHB1bHNpbmdcbiAgICAgICAgdGhpcy5yZWREb3QuY2xhc3NMaXN0LmFkZCgnc21hcnQtbWVtby1wdWxzZS1hbmltYXRpb24nKTtcbiAgICB9XG5cbiAgICBoYXJkUmVzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLm1lZGlhUmVjb3JkZXIpIHtcbiAgICAgICAgICAgIHRoaXMubWVkaWFSZWNvcmRlci5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLm1lZGlhUmVjb3JkZXIub25zdG9wID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubWVkaWFSZWNvcmRlci5vbmRhdGFhdmFpbGFibGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tZWRpYVJlY29yZGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUmVzZXR0aW5nID0gdHJ1ZTsgLy8gU2V0IHRoZSByZXNldCBmbGFnXG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107IC8vIENsZWFyIHRoZSBjaHVua3NcbiAgICAgICAgdGhpcy5lbGFwc2VkVGltZSA9IDA7IC8vIFJlc2V0IGVsYXBzZWQgdGltZVxuICAgICAgICB0aGlzLnN0b3BUaW1lcigpO1xuICAgICAgICB0aGlzLnRpbWVyLnRleHRDb250ZW50ID0gJzAwOjAwJztcbiAgICAgICAgLy8gRW5zdXJlIHJlZCBkb3Qgc3RvcHMgcHVsc2luZ1xuICAgICAgICB0aGlzLnJlZERvdC5jbGFzc0xpc3QucmVtb3ZlKCdzbWFydC1tZW1vLXB1bHNlLWFuaW1hdGlvbicpOyAvLyBFbnN1cmUgaXQncyByZW1vdmVkIG9uIHJlc2V0XG4gICAgfVxuXG4gICAgc3RvcFJlY29yZGluZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPEJsb2IgfCBudWxsPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgICBpZiAodGhpcy5tZWRpYVJlY29yZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZWRpYVJlY29yZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3N0b3AnLCB0aGlzLm9uU3RvcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1lZGlhUmVjb3JkZXIuc3RvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcFRpbWVyKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXJ0VGltZXIoKSB7XG4gICAgICAgIHRoaXMuc3RvcFRpbWVyKCk7IC8vIENsZWFyIGFueSBleGlzdGluZyB0aW1lclxuICAgICAgICB0aGlzLmludGVydmFsSWQgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxhcHNlZFRpbWVJblNlY29uZHMgPSBNYXRoLmZsb29yKHRoaXMuZWxhcHNlZFRpbWUgLyAxMDAwKSArIE1hdGguZmxvb3IoKERhdGUubm93KCkgLSB0aGlzLnN0YXJ0VGltZSkgLyAxMDAwKTtcbiAgICAgICAgICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKGVsYXBzZWRUaW1lSW5TZWNvbmRzIC8gNjApO1xuICAgICAgICAgICAgY29uc3Qgc2Vjb25kcyA9IGVsYXBzZWRUaW1lSW5TZWNvbmRzICUgNjA7XG4gICAgICAgICAgICB0aGlzLnRpbWVyLnRleHRDb250ZW50ID0gYCR7dGhpcy5wYWROdW1iZXIobWludXRlcyl9OiR7dGhpcy5wYWROdW1iZXIoc2Vjb25kcyl9YDtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgfVxuXG4gICAgc3RvcFRpbWVyKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnZhbElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsSWQpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbElkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhZE51bWJlcihudW06IG51bWJlcik6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBudW0udG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgIH1cblxuXG4gICAgb3BlbigpIHtcbiAgICAgICAgc3VwZXIub3BlbigpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8QmxvYj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgQXBwLCBURmlsZSwgVEZvbGRlciwgbm9ybWFsaXplUGF0aCB9IGZyb20gJ29ic2lkaWFuJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNhdmVGaWxlKGFwcDogQXBwLCBhdWRpb0Jsb2I6IEJsb2IsIGZpbGVOYW1lOiBzdHJpbmcsIHBhdGg6IHN0cmluZyk6IFByb21pc2U8VEZpbGU+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVBhdGgocGF0aCk7XG4gICAgICAgIGNvbnN0IGZpbGVQYXRoID0gYCR7bm9ybWFsaXplZFBhdGh9LyR7ZmlsZU5hbWV9YDtcblxuICAgICAgICBhd2FpdCBlbnN1cmVEaXJlY3RvcnlFeGlzdHMoYXBwLCBub3JtYWxpemVkUGF0aCk7XG5cbiAgICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBhdWRpb0Jsb2IuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgY29uc3QgdWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcblxuICAgICAgICBjb25zdCBmaWxlID0gYXdhaXQgYXBwLnZhdWx0LmNyZWF0ZUJpbmFyeShmaWxlUGF0aCwgdWludDhBcnJheSk7XG4gICAgICAgIGlmICghZmlsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWxlIGNyZWF0aW9uIGZhaWxlZCBhbmQgcmV0dXJuZWQgbnVsbCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWxlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBhdWRpbyBmaWxlOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBlbnN1cmVEaXJlY3RvcnlFeGlzdHMoYXBwOiBBcHAsIGZvbGRlclBhdGg6IHN0cmluZykge1xuICAgIGNvbnN0IHBhcnRzID0gZm9sZGVyUGF0aC5zcGxpdCgnLycpO1xuICAgIGxldCBjdXJyZW50UGF0aCA9ICcnO1xuXG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgIGN1cnJlbnRQYXRoID0gY3VycmVudFBhdGggPyBgJHtjdXJyZW50UGF0aH0vJHtwYXJ0fWAgOiBwYXJ0O1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZvbGRlciA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoY3VycmVudFBhdGgpO1xuICAgICAgICAgICAgaWYgKCFmb2xkZXIpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBhcHAudmF1bHQuY3JlYXRlRm9sZGVyKGN1cnJlbnRQYXRoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9sZGVyIGluc3RhbmNlb2YgVEZvbGRlcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGb2xkZXIgYWxyZWFkeSBleGlzdHM6ICR7Y3VycmVudFBhdGh9YCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjdXJyZW50UGF0aH0gaXMgbm90IGEgZm9sZGVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnRm9sZGVyIGFscmVhZHkgZXhpc3RzJykpIHtcbiAgICAgICAgICAgICAgICAvLyBGb2xkZXIgYWxyZWFkeSBleGlzdHMsIGNvbnRpbnVlIHRvIHRoZSBuZXh0IHBhcnRcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgSGFuZGxlZCBleGlzdGluZyBmb2xkZXI6ICR7Y3VycmVudFBhdGh9YCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGVuc3VyaW5nIGRpcmVjdG9yeSBleGlzdHM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUlBLFFBQU0sbUJBQU4sTUFBdUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNckIscUJBQXFCLE1BQU07QUFBRSxlQUFPLG9CQUFvQixJQUFJO0FBQUEsTUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU0vRCxNQUFNLGFBQWEsT0FBTztBQUV4QixlQUFPLEtBQUssZ0JBQWdCLEtBQUs7QUFBQSxNQUNuQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLGdCQUFnQixPQUFNO0FBQ3BCLFlBQUcsT0FBTyxVQUFVO0FBQVUsa0JBQVEsS0FBSyxVQUFVLEtBQUs7QUFFMUQsZUFBTyxLQUFLLEtBQUssTUFBTSxTQUFTLENBQUM7QUFBQSxNQUNuQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLGNBQWMsTUFBSztBQUNqQixlQUFPLEtBQUssUUFBUSxLQUFLLFNBQU8sSUFBSSxTQUFTLFVBQVU7QUFBQSxNQUN6RDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLHNCQUFzQixXQUFVO0FBQzlCLGVBQU8sVUFBVTtBQUFBLE1BQ25CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsY0FBYyxXQUFVO0FBQ3RCLGVBQU8sVUFBVTtBQUFBLE1BQ25CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsWUFBWSxNQUFLO0FBM0RuQjtBQTJEcUIsZ0JBQU8sVUFBSyxZQUFMLG1CQUFl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QUFPLFNBQVMsU0FBUyxFQUN2QyxTQUFTLE9BQU8sVUFBVTtBQUN2QixXQUFLLE9BQU8sU0FBUyxZQUFZO0FBQ2pDLFlBQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxJQUNuQyxDQUFDLENBQUM7QUFFTixRQUFJLHlCQUFRLFdBQVcsRUFDbEIsUUFBUSxzQkFBc0IsRUFDOUIsUUFBUSxxR0FBcUcsRUFDN0csVUFBVSxZQUFVLE9BQ2hCLFNBQVMsS0FBSyxPQUFPLFNBQVMsb0JBQW9CLEVBQ2xELFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLFdBQUssT0FBTyxTQUFTLHVCQUF1QjtBQUM1QyxZQUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsSUFDbkMsQ0FBQyxDQUFDO0FBQUEsRUFFakI7QUFDRDsiLAogICJuYW1lcyI6IFsib3V0IiwgIm1vZHVsZSIsICJyZXF1aXJlX29wZW5fcm91dGVyIiwgIm0iLCAicmVxdWlyZV9jb2hlcmUiLCAicmVxdWlyZV9hbnRocm9waWMiLCAiU21hcnRDaGF0TW9kZWwiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiJdCn0K
