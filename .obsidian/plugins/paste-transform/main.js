/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PasteTransform
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  patterns: [
    "^https://github.com/[^/]+/([^/]+)/issues/(\\d+)$",
    "^https://github.com/[^/]+/([^/]+)/pull/(\\d+)$",
    "^https://github.com/[^/]+/([^/]+)$",
    "^https://\\w+.wikipedia.org/wiki/([^\\s]+)$"
  ],
  replacers: [
    "[\u{1F408}\u200D\u2B1B\u{1F528} $1#$2]($&)",
    "[\u{1F408}\u200D\u2B1B\u{1F6E0}\uFE0E $1#$2]($&)",
    "[\u{1F408}\u200D\u2B1B $1]($&)",
    "[\u{1F4D6} $1]($&)"
  ],
  settingsFormatVersion: 1,
  debugMode: false
};
var ReplaceRule = class {
  constructor(pattern, replacer) {
    this.pattern = new RegExp(pattern, "g");
    this.replacer = replacer;
  }
};
var PasteTransform = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new PasteTransformSettingsTab(this.app, this));
    this.registerEvent(this.app.workspace.on("editor-paste", (event) => this.onPaste(event)));
  }
  onPaste(event) {
    var _a, _b, _c, _d;
    if (event.defaultPrevented) {
      if (this.settings.debugMode) {
        console.log("It doesn't try to apply rules because event prevented already.");
      }
      return;
    }
    let types = (_a = event.clipboardData) == null ? void 0 : _a.types;
    if (this.settings.debugMode) {
      console.log("transform plugin, clipboard content types:", types);
    }
    if (types === void 0 || types.length != 1 || types[0] != "text/plain") {
      return;
    }
    let plainText = (_b = event.clipboardData) == null ? void 0 : _b.getData("text/plain");
    if (plainText === void 0 || plainText == "") {
      return;
    }
    let result = this.applyRules(plainText);
    if (this.settings.debugMode) {
      console.log(`Replaced '${plainText}' -> '${result}'`);
    }
    if (result != plainText) {
      (_d = (_c = this.app.workspace.activeEditor) == null ? void 0 : _c.editor) == null ? void 0 : _d.replaceSelection(result);
      event.preventDefault();
    }
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.compileRules();
  }
  compileRules() {
    this.rules = [];
    let minIndex = this.settings.patterns.length;
    if (this.settings.replacers.length < minIndex) {
      minIndex = this.settings.replacers.length;
    }
    for (let i = 0; i < minIndex; i++) {
      this.rules.push(
        new ReplaceRule(this.settings.patterns[i], this.settings.replacers[i])
      );
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  applyRules(source) {
    if (source === void 0 || source === null) {
      return "";
    }
    let result = source;
    for (let rule of this.rules) {
      if (source.search(rule.pattern) != -1) {
        result = source.replace(rule.pattern, rule.replacer);
        break;
      }
    }
    return result;
  }
};
var PasteTransformSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    let patternsTa = null;
    let replacersTa = null;
    let trySource = null;
    let tryDest = null;
    let plugin = this.plugin;
    let handleChanges = function() {
      try {
        tryDest == null ? void 0 : tryDest.setValue(plugin.applyRules(trySource == null ? void 0 : trySource.getValue()));
      } catch (e) {
        tryDest == null ? void 0 : tryDest.setValue("ERROR:\n" + e);
      }
    };
    let handleTextChange = async function(value, setAttr) {
      let values = value.split("\n");
      if (values.length > 0 && values.last() == "") {
        values.pop();
      }
      setAttr(values);
      try {
        plugin.compileRules();
        handleChanges();
        await plugin.saveSettings();
      } catch (e) {
        tryDest == null ? void 0 : tryDest.setValue("ERROR:\n" + e);
      }
    };
    new import_obsidian.Setting(containerEl).setName("Transform rules").setDesc(
      "Type regexp patterns in left box and replace rules in right box.Every pattern and rule on a line.Pattern and rules use matched by line numbers.Regexp and replace rules use typescript rules."
    ).addTextArea(
      (ta) => {
        patternsTa = ta;
        patternsTa.setPlaceholder("patter 1\npattern 2\n");
        let patternsString = "";
        for (let val of this.plugin.settings.patterns) {
          patternsString += val + "\n";
        }
        patternsTa.setValue(patternsString);
        patternsTa.onChange(async (value) => {
          await handleTextChange(value, (values) => {
            plugin.settings.patterns = values;
          });
        });
      }
    ).addTextArea((ta) => {
      replacersTa = ta;
      replacersTa.setPlaceholder("replacer 1\nreplacer 2\n");
      let replacersString = "";
      for (let val of this.plugin.settings.replacers) {
        replacersString += val + "\n";
      }
      replacersTa.setValue(replacersString);
      replacersTa.onChange(async (value) => {
        await handleTextChange(value, (values) => {
          plugin.settings.replacers = values;
        });
      });
    });
    new import_obsidian.Setting(containerEl).setName("Try rules").setDesc("Write original text here").addTextArea((ta) => {
      trySource = ta;
      ta.setPlaceholder("Sample text");
      ta.onChange((_) => {
        handleChanges();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Result").setDesc("The result of rules apply to original text").addTextArea((ta) => {
      tryDest = ta;
      ta.setPlaceholder("Transform result");
      ta.setDisabled(true);
    });
    new import_obsidian.Setting(containerEl).setName("Debug mode").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.debugMode);
      toggle.onChange(async (value) => {
        this.plugin.settings.debugMode = value;
        await this.plugin.saveSettings();
      });
    });
  }
};
