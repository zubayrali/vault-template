/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/utils.ts
var utils_exports = {};
__export(utils_exports, {
  array_prefix_id: () => array_prefix_id,
  check_value: () => check_value,
  concat_array: () => concat_array,
  get_plugins: () => get_plugins,
  get_tp_func: () => get_tp_func,
  get_tp_user_func: () => get_tp_user_func,
  parse_templater: () => parse_templater
});
function get_plugins(app, name) {
}
function array_prefix_id(items, offset = 1) {
  let res = new Array();
  let N = items.length.toString().length;
  for (let i = 0; i < items.length; i++) {
    let id = (i + offset).toString().padStart(N, "0");
    res.push(`${id} \u{1F525} ${items[i]}`);
  }
  return res;
}
function concat_array(items) {
  if (items == null) {
    return [];
  }
  if (typeof items === "string") {
    return [items];
  }
  if (!(items instanceof Array)) {
    return [items];
  }
  let res = [];
  for (let item of items) {
    if (typeof item === "string") {
      res.push(item);
    } else if (item instanceof Array) {
      res = res.concat(this.concat_array(item));
    } else {
      res.push(item);
    }
  }
  return res;
}
async function check_value(t, k, v, dt, T) {
  let i = 0;
  while (t[k] == null || !(t[k] === v)) {
    await sleep(dt);
    i = dt + dt;
    if (i > T) {
      break;
    }
  }
  if (t[k] && t[k] === v) {
    return true;
  } else {
    return false;
  }
}
function get_tp_func(app, target) {
  let templater = app.plugins.getPlugin(
    "templater-obsidian"
  );
  let items = target.split(".");
  if (items[0].localeCompare("tp") != 0 || items.length != 3) {
    return void 0;
  }
  let modules = templater.templater.functions_generator.internal_functions.modules_array.filter(
    (item) => item.name.localeCompare(items[1]) == 0
  );
  if (modules.length == 0) {
    return void 0;
  }
  return modules[0].static_functions.get(items[2]);
}
async function get_tp_user_func(app, target) {
  let templater = app.plugins.getPlugin(
    "templater-obsidian"
  );
  let items = target.split(".");
  if (items[0].localeCompare("tp") != 0 || items[1].localeCompare("user") != 0 || items.length != 3) {
    return void 0;
  }
  let funcs = await templater.templater.functions_generator.user_functions.user_script_functions.generate_user_script_functions();
  return funcs.get(items[2]);
}
async function templater$1(app, template, active_file, target_file) {
  const config = {
    template_file: template,
    active_file,
    target_file,
    run_mode: "DynamicProcessor"
  };
  const plugins = app.plugins.plugins;
  const exists = plugins["templater-obsidian"];
  if (!exists) {
    new import_obsidian.Notice("Templater is not installed. Please install it.");
    return;
  }
  const { templater } = plugins["templater-obsidian"];
  const functions = await templater.functions_generator.internal_functions.generate_object(config);
  functions.user = {};
  const userScriptFunctions = await templater.functions_generator.user_functions.user_script_functions.generate_user_script_functions(config);
  userScriptFunctions.forEach(
    (value, key) => {
      functions.user[key] = value;
    }
  );
  if (template) {
    const userSystemFunctions = await templater.functions_generator.user_functions.user_system_functions.generate_system_functions(config);
    userSystemFunctions.forEach(
      (value, key) => {
        functions.user[key] = value;
      }
    );
  }
  return async (command) => {
    return await templater.parser.parse_commands(command, functions);
  };
}
async function parse_templater(app, template, without_meta = true) {
  let nc = app.plugins.getPlugin("note-chain");
  if (!nc) {
    return;
  }
  let file = nc.chain.get_tfile(template);
  if (file instanceof import_obsidian.TFile) {
    template = await app.vault.read(file);
    if (without_meta) {
      let headerRegex = /^---\s*([\s\S]*?)\s*---/;
      let match = headerRegex.exec(template);
      if (match) {
        template = template.slice(match[0].length).trim();
      }
    }
  }
  let notes = app.vault.getMarkdownFiles();
  if (notes.length == 0) {
    return;
  }
  let active_file = notes[0];
  let target_file = notes[0];
  let templateFunc = await templater$1(app, "", active_file, target_file);
  return templateFunc ? await templateFunc(template) : void 0;
}
var import_obsidian;
var init_utils = __esm({
  "src/utils.ts"() {
    import_obsidian = require("obsidian");
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NoteChainPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/NCEditor.ts
var NCEditor = class {
  constructor(app) {
    this.app = app;
    this.nretry = 100;
  }
  async set_frontmatter(tfile, key, value, nretry = this.nretry) {
    let kv = {};
    kv[key] = value;
    let flag = await this.set_multi_frontmatter(tfile, kv, nretry);
    return flag;
  }
  check_frontmatter(tfile, kv) {
    try {
      if (!tfile) {
        return false;
      }
      let meta = this.app.metadataCache.getFileCache(tfile);
      if (meta == null ? void 0 : meta.frontmatter) {
        for (let k in kv) {
          if (!(meta.frontmatter[k] == kv[k])) {
            return false;
          }
        }
        return true;
      }
      return false;
    } catch (error) {
      return false;
    }
  }
  async wait_frontmatter(tfile, kv, nretry = this.nretry) {
    let flag = this.check_frontmatter(tfile, kv);
    while (!flag && nretry > 0) {
      await sleep(50);
      nretry = nretry - 1;
      flag = this.check_frontmatter(tfile, kv);
    }
    return flag;
  }
  async set_multi_frontmatter(tfile, kv, nretry = this.nretry) {
    let flag = this.check_frontmatter(tfile, kv);
    while (!flag && nretry > 0) {
      await this.app.fileManager.processFrontMatter(tfile, (fm) => {
        for (let k in kv) {
          fm[k] = kv[k];
        }
      });
      await sleep(100);
      nretry = nretry - 1;
      flag = this.check_frontmatter(tfile, kv);
    }
    return flag;
  }
  get_frontmatter(tfile, key) {
    try {
      if (!tfile) {
        return null;
      }
      let meta = this.app.metadataCache.getFileCache(tfile);
      if (meta == null ? void 0 : meta.frontmatter) {
        return meta.frontmatter[key];
      }
    } catch (error) {
      return null;
    }
  }
  regexp_link(tfile, mode) {
    if (mode === "link") {
      return new RegExp(`\\[\\[${tfile.basename}\\|?.*\\]\\]`, "g");
    }
    if (mode === "para") {
      return new RegExp(`.*\\[\\[${tfile.basename}\\|?.*\\]\\].*`, "g");
    }
  }
  async replace(tfile, regex, target) {
    if (typeof regex === "string") {
      await this.app.vault.process(tfile, (data) => {
        if (data.indexOf(regex) > -1) {
          return data.replace(regex, target);
        }
        return data;
      });
    } else if (regex instanceof RegExp) {
      await this.app.vault.process(tfile, (data) => {
        if (data.match(regex)) {
          return data.replace(regex, target);
        }
        return data;
      });
    }
  }
};

// src/NoteChain.ts
var import_obsidian3 = require("obsidian");
init_utils();

// src/NCModal.ts
var import_obsidian2 = require("obsidian");
var NoteContentModal = class extends import_obsidian2.Modal {
  constructor(app, content, plugin) {
    super(app);
    this.content = content;
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.modalEl.style.display = "flex";
    this.modalEl.style.overflow = "auto";
    const container = contentEl.createDiv({ cls: "note-content-container" });
    container.addClass("markdown-rendered");
    container.style.display = "table-cell";
    container.style.verticalAlign = "middle";
    container.style.padding = "20px";
    const component = new import_obsidian2.Component();
    import_obsidian2.MarkdownRenderer.render(this.app, this.content, container, "", component);
    this.addClickListener(container);
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
  addClickListener(container) {
    container.addEventListener("click", (event) => {
      let target = event.target;
      if (target.tagName === "A" && target.hasClass("internal-link")) {
        event.preventDefault();
        let href = target.getAttribute("href");
        if (href) {
          this.openNoteInMainView(href);
        }
      }
    });
  }
  async openNoteInMainView(linkText) {
    try {
      await this.app.workspace.openLinkText(linkText, "", false, { active: true });
      this.close();
    } catch (error) {
      new import_obsidian2.Notice(`Error opening note: ${error.message}`);
    }
  }
};

// src/NoteChain.ts
var NoteChain = class {
  constructor(plugin, editor, prev = "PrevNote", next = "NextNote") {
    this.plugin = plugin;
    this.app = plugin.app;
    this.editor = new NCEditor(this.app);
    this.prev = prev;
    this.next = next;
    this.init_children();
  }
  async open_note_in_modal(notePath) {
    try {
      let file = this.get_tfile(notePath);
      if (file instanceof import_obsidian3.TFile) {
        let content = await this.app.vault.read(file);
        let modal = new NoteContentModal(this.app, content, this.plugin);
        modal.open();
        return modal;
      } else {
        let modal = new NoteContentModal(this.app, notePath, this.plugin);
        modal.open();
        return modal;
      }
    } catch (error) {
      new import_obsidian3.Notice(`Error opening note in modal: ${error.message}`);
    }
  }
  init_children() {
    var _a;
    this.children = {};
    for (let f of this.get_all_folders()) {
      let tfiles = f.children;
      if ((_a = this.plugin.explorer) == null ? void 0 : _a.file_explorer) {
        tfiles = this.sort_tfiles(
          tfiles,
          this.plugin.explorer.file_explorer.sortOrder
        );
      }
      this.children[f.path] = this.sort_tfiles_by_chain(tfiles);
    }
  }
  refresh_folder(tfolder) {
    if (tfolder == null ? void 0 : tfolder.children) {
      let tfiles = tfolder.children;
      if (this.plugin.explorer.file_explorer) {
        tfiles = this.sort_tfiles(
          tfiles,
          this.plugin.explorer.file_explorer.sortOrder
        );
      }
      this.children[tfolder.path] = this.sort_tfiles_by_chain(
        tfiles
      );
    }
  }
  refresh_tfile(tfile) {
    var _a;
    if ((_a = tfile.parent) == null ? void 0 : _a.children) {
      this.refresh_folder(tfile.parent);
    }
  }
  get tp_find_tfile() {
    return get_tp_func(this.app, "tp.file.find_tfile");
  }
  get tp_suggester() {
    return get_tp_func(this.app, "tp.system.suggester");
  }
  get tp_prompt() {
    return get_tp_func(this.app, "tp.system.prompt");
  }
  get_all_folders() {
    let folders = this.app.vault.getAllFolders();
    let folder = this.app.vault.getFolderByPath("/");
    if (folder && !folders.contains(folder)) {
      folders.push(folder);
    }
    return folders;
  }
  get_all_tfiles(sort_mode = "") {
    let files = this.app.vault.getMarkdownFiles();
    if (!(sort_mode === "")) {
      this.sort_tfiles(files, sort_mode = sort_mode);
    }
    return files;
  }
  sort_folders_by_mtime(folders, reverse = true) {
    function ufunc(f) {
      return Math.max(
        ...f.children.filter((f2) => f2.basename).map((f2) => f2.stat.mtime)
      );
    }
    let res = folders.sort((a, b) => ufunc(a) - ufunc(b));
    if (reverse) {
      res = res.reverse();
    }
    return res;
  }
  async cmd_move_file_to_another_folder(tfile = this.current_note) {
    if (tfile == null) {
      return;
    }
    let folders = this.get_all_folders();
    folders = this.sort_folders_by_mtime(
      folders
    ).filter((f) => f != tfile.parent);
    if (tfile.extension === "md") {
      folders = folders.filter((f) => this.filter_user_ignore(f));
    }
    try {
      let folder = await this.tp_suggester(
        this.plugin.utils.array_prefix_id(
          folders.map((f) => f.path)
        ),
        folders
      );
      let dst = folder.path + "/" + tfile.basename + "." + tfile.extension;
      await this.app.fileManager.renameFile(tfile, dst);
    } catch (error) {
    }
  }
  filter_user_ignore(note) {
    if (!(this.app.vault.config.attachmentFolderPath === "./")) {
      if (note.path.startsWith(
        this.app.vault.config.attachmentFolderPath
      )) {
        return false;
      }
    }
    if (this.app.vault.userIgnoreFilters) {
      for (let x of this.app.vault.userIgnoreFilters) {
        if (note.path.startsWith(x)) {
          return false;
        }
      }
    }
    return true;
  }
  async sugguster_note() {
    let notes = this.sort_tfiles(
      this.app.vault.getFiles(),
      ["mtime", "x"]
    ).filter((f) => this.filter_user_ignore(f));
    try {
      let msg = this.plugin.utils.array_prefix_id(notes.map((f) => f.path));
      let note = await this.tp_suggester(msg, notes);
      return note;
    } catch (error) {
      return null;
    }
  }
  open_note(tfile, new_tab = false, revealFolder = false, collapse = true) {
    if (tfile) {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
      if (new_tab || !view || !view.leaf) {
        this.app.workspace.getLeaf(true).openFile(tfile);
      } else if (view.leaf.pinned) {
        this.app.workspace.getLeaf(true).openFile(tfile);
      } else {
        view.leaf.openFile(tfile);
      }
      if (revealFolder) {
        if (collapse) {
          this.plugin.explorer.file_explorer.tree.setCollapseAll(true);
        }
        this.plugin.explorer.file_explorer.revealInFolder(tfile);
      }
    }
  }
  async sugguster_open_note() {
    try {
      let note = await this.sugguster_note();
      this.open_note(note);
    } catch (error) {
    }
  }
  get_tfile(path) {
    let name = path.split("|")[0].replace("[[", "").replace("]]", "");
    return this.tp_find_tfile(name);
  }
  get_last_daily_note() {
    var _a, _b, _c;
    let pattern = /^\d{4}-\d{2}-\d{2}$/;
    let tfile = this.app.workspace.getActiveFile();
    if (tfile && ((_a = tfile.basename) == null ? void 0 : _a.match(pattern))) {
      return tfile;
    }
    let leaf = this.get_neighbor_leaf();
    tfile = (_b = leaf == null ? void 0 : leaf.view) == null ? void 0 : _b.file;
    if ((_c = tfile == null ? void 0 : tfile.basename) == null ? void 0 : _c.match(pattern)) {
      return tfile;
    }
    let recent = this.app.plugins.getPlugin("recent-files-obsidian");
    if (recent) {
      let files = recent.data.recentFiles.filter(
        (x) => {
          var _a2;
          return (_a2 = x.basename) == null ? void 0 : _a2.match(pattern);
        }
      );
      if (files.length > 0) {
        tfile = this.get_tfile(files[0].basename);
        return tfile;
      }
    } else {
      let fname = (0, import_obsidian3.moment)().format("YYYY-MM-DD");
      tfile = this.get_tfile(fname);
      if (tfile) {
        return tfile;
      }
      let files = this.app.vault.getMarkdownFiles().filter(
        (x) => x.basename.match(pattern)
      );
      files = this.sort_tfiles(files, "name");
      if (files.length > 0) {
        return files[files.length - 1];
      }
    }
    return null;
  }
  get_neighbor_leaf(offset = 1) {
    let app = this.plugin.app;
    let leaves = app.workspace.getLeavesOfType("markdown");
    let activeLeaf = app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (activeLeaf) {
      let idx = leaves.map((x) => x.view == activeLeaf).indexOf(true);
      idx = idx + offset;
      if (idx < 0 || idx > leaves.length - 1) {
        return null;
      }
      return leaves[idx];
    }
  }
  get_last_activate_leaf(skip_conote = true) {
    var _a, _b, _c;
    let leaves = [];
    this.app.workspace.iterateAllLeaves((leaf2) => {
      leaves.push(leaf2);
    });
    leaves = leaves.filter((x) => x.getViewState().state.file);
    let r = this.app.plugins.getPlugin("recent-files-obsidian");
    if (!r) {
      new import_obsidian3.Notice("Need Plugin recent-files-obsidian ", 5e3);
      return;
    }
    let dv = (_a = this.app.plugins.getPlugin("dataview")) == null ? void 0 : _a.api;
    if (!dv) {
      new import_obsidian3.Notice("Need Plugin dataview", 5e3);
      return;
    }
    let rfiles = r.data.recentFiles.map((x) => x.path);
    for (let path of rfiles) {
      if (skip_conote && ((_b = dv.index.tags.delegate.map.get(path)) == null ? void 0 : _b.has("#conote"))) {
        continue;
      }
      for (let leaf2 of leaves) {
        if (leaf2.getViewState().state.file == path) {
          return leaf2;
        }
      }
    }
    for (let leaf2 of leaves.reverse()) {
      let cfile = leaf2.getViewState().state.file;
      if (skip_conote && ((_c = dv.index.tags.delegate.map.get(cfile)) == null ? void 0 : _c.has("#conote"))) {
        continue;
      }
      if (!rfiles.contains(cfile)) {
        return leaf2;
      }
    }
    let leaf = null;
    for (let i of [1, -1, 0]) {
      leaf = this.plugin.chain.get_neighbor_leaf(i);
      if (leaf) {
        return leaf;
      }
    }
    return null;
  }
  get current_note() {
    return this.app.workspace.getActiveFile();
  }
  get_inlinks(tfile = this.current_note, only_md = false) {
    if (tfile == null) {
      return [];
    }
    let res = new Array();
    let dv_api = this.app.plugins.getPlugin("dataview");
    let inlinks = dv_api.index.links.invMap.get(tfile.path);
    if (inlinks == void 0) {
      return [];
    } else {
      return Array.from(inlinks).map(
        (path) => this.app.vault.fileMap[path]
      ).filter(
        (item) => item
      ).filter(
        (item) => {
          return !only_md || item.extension == "md";
        }
      );
    }
  }
  get_outlinks(tfile = this.current_note, only_md = false) {
    if (tfile == null) {
      return [];
    }
    let dv_api = this.app.plugins.getPlugin("dataview");
    let inlinks = dv_api.index.links.map.get(tfile.path);
    if (inlinks == void 0) {
      return [];
    } else {
      return Array.from(inlinks).map(
        (path) => this.app.vault.fileMap[path]
      ).filter(
        (item) => item
      ).filter(
        (item) => {
          return !only_md || item.extension == "md";
        }
      );
    }
  }
  get_links(tfile = this.current_note, only_md = false) {
    let inlinks = this.get_inlinks(tfile, only_md);
    let outlinks = this.get_outlinks(tfile, only_md);
    for (let link of inlinks) {
      if (!outlinks.includes(link)) {
        outlinks.push(link);
      }
    }
    return outlinks;
  }
  get_group_inlinks(tfiles, level = 1) {
    let items = tfiles.map((x) => x);
    while (level != 0) {
      let curr = items.map((x) => x);
      for (let c of curr) {
        let links = this.get_inlinks(c, true);
        for (let link of links) {
          if (!items.contains(link)) {
            items.push(link);
          }
        }
      }
      if (curr.length == items.length) {
        break;
      }
      level = level - 1;
    }
    return items;
  }
  get_group_outlinks(tfiles, level = 1) {
    let items = tfiles.map((x) => x);
    while (level != 0) {
      let curr = items.map((x) => x);
      for (let c of curr) {
        let links = this.get_outlinks(c, true);
        for (let link of links) {
          if (!items.contains(link)) {
            items.push(link);
          }
        }
      }
      if (curr.length == items.length) {
        break;
      }
      level = level - 1;
    }
    return items;
  }
  get_group_links(tfiles, level = 1) {
    let items = tfiles.map((x) => x);
    while (level != 0) {
      let curr = items.map((x) => x);
      for (let c of curr) {
        let links = this.get_links(c, true);
        for (let link of links) {
          if (!items.contains(link)) {
            items.push(link);
          }
        }
      }
      if (curr.length == items.length) {
        break;
      }
      level = level - 1;
    }
    return items;
  }
  get_brothers(tfile = this.current_note) {
    if (tfile && tfile.parent) {
      return this.get_tfiles_of_folder(tfile.parent, false);
    } else {
      return [];
    }
  }
  get_uncles(tfile) {
    if (tfile && tfile.parent && tfile.parent.parent) {
      let folder = tfile.parent.parent;
      return folder.children.filter(
        (x) => x instanceof import_obsidian3.TFile
      );
    }
    return [];
  }
  get_tfiles_of_folder(tfolder, with_children = false) {
    if (tfolder == null) {
      return [];
    }
    let notes = [];
    for (let c of tfolder.children) {
      if (c instanceof import_obsidian3.TFile && c.extension === "md") {
        notes.push(c);
      } else if (c instanceof import_obsidian3.TFolder && with_children) {
        let tmp = this.get_tfiles_of_folder(c);
        for (let x of tmp) {
          notes.push(x);
        }
      }
    }
    return notes;
  }
  indexOfFolder(tfile, tfiles) {
    let fnote = this.tp_find_tfile(tfile.name + ".md");
    if (!fnote) {
      return -1;
    }
    let msg = this.plugin.editor.get_frontmatter(
      fnote,
      "FolderPrevNote"
    );
    if (!msg) {
      return -1;
    }
    let anchor = this.get_tfile(msg);
    if (!anchor) {
      return -1;
    }
    let idx = tfiles.indexOf(anchor);
    let offset = this.plugin.editor.get_frontmatter(
      fnote,
      "FolderPrevNoteOffset"
    );
    if (offset) {
      idx = idx + parseFloat(offset);
    } else {
      idx = idx + 0.5;
    }
    return idx;
  }
  tfile_to_string(tfile) {
    let curr = this.current_note;
    let msg = "";
    if (tfile.parent == (curr == null ? void 0 : curr.parent)) {
      msg = tfile.basename;
    } else {
      msg = tfile.path;
    }
    if (tfile == this.current_note) {
      return `\u{1F3E0} ${msg}`;
    } else {
      return msg;
    }
  }
  async suggester_notes(tfile = this.current_note, curr_first = false, smode = "") {
    if (tfile) {
      tfile == this.current_note;
    }
    let kv = [
      this.plugin.strings.item_get_brothers,
      this.plugin.strings.item_notechain,
      this.plugin.strings.item_uncle_notes,
      this.plugin.strings.item_same_folder,
      this.plugin.strings.item_inlinks_outlinks,
      this.plugin.strings.item_inlins,
      this.plugin.strings.item_outlinks,
      this.plugin.strings.item_all_noes,
      this.plugin.strings.item_recent
    ];
    if (curr_first) {
      kv.unshift(this.plugin.strings.item_currentnote);
    } else {
      kv.push(this.plugin.strings.item_currentnote);
    }
    let mode = "";
    if (kv.contains(smode)) {
      mode = smode;
    } else {
      mode = await this.tp_suggester(this.plugin.utils.array_prefix_id(kv), kv);
    }
    if (mode === this.plugin.strings.item_currentnote) {
      return [tfile];
    } else if (mode === this.plugin.strings.item_get_brothers) {
      return this.get_brothers(tfile);
    } else if (mode === this.plugin.strings.item_same_folder) {
      if (tfile == null ? void 0 : tfile.parent) {
        return this.get_tfiles_of_folder(tfile.parent, true);
      }
    } else if (mode === this.plugin.strings.item_inlinks_outlinks) {
      return this.get_links(tfile);
    } else if (mode === this.plugin.strings.item_inlins) {
      return this.get_inlinks(tfile);
    } else if (mode === this.plugin.strings.item_outlinks) {
      return this.get_outlinks(tfile);
    } else if (mode === this.plugin.strings.item_all_noes) {
      return this.get_all_tfiles();
    } else if (mode === this.plugin.strings.item_recent) {
      let r = this.app.plugins.getPlugin("recent-files-obsidian");
      if (!r) {
        return [];
      }
      return Object.values(
        r.data.recentFiles
      ).map(
        (f) => this.app.vault.fileMap[f.path]
      ).filter((f) => f);
    } else if (mode === this.plugin.strings.item_uncle_notes) {
      if (tfile) {
        return this.get_uncles(tfile);
      }
    } else if (mode === this.plugin.strings.item_notechain) {
      return this.get_chain(
        tfile,
        Number(this.plugin.settings.PrevChain),
        Number(this.plugin.settings.NextChain)
      );
    } else {
      return [];
    }
  }
  // Chain
  get_prev_note(tfile = this.current_note) {
    if (!tfile) {
      return;
    }
    if (tfile.deleted) {
      let tfiles = this.app.vault.getMarkdownFiles();
      tfiles.filter((f) => `[[${tfile.basename}]]` === this.plugin.editor.get_frontmatter(f, "NextNote"));
      tfiles = tfiles.filter((f) => `[[${tfile.basename}]]` === this.editor.get_frontmatter(f, this.next));
      if (tfiles.length > 0) {
        return tfiles[0];
      } else {
        return null;
      }
    } else {
      let name = this.editor.get_frontmatter(tfile, this.prev);
      if (!name) {
        return null;
      }
      let note = this.get_tfile(name);
      return note ? note : null;
    }
  }
  open_prev_notes(tfile = this.current_note) {
    let note = this.get_prev_note(tfile);
    this.open_note(note);
  }
  get_next_note(tfile = this.current_note) {
    if (!tfile) {
      return null;
    }
    if (tfile.deleted) {
      let tfiles = this.app.vault.getMarkdownFiles();
      tfiles = tfiles.filter((f) => `[[${tfile.basename}]]` === this.editor.get_frontmatter(f, this.prev));
      if (tfiles.length > 0) {
        return tfiles[0];
      } else {
        return null;
      }
    } else {
      let name = this.editor.get_frontmatter(tfile, this.next);
      if (!name) {
        return null;
      }
      let note = this.get_tfile(name);
      return note ? note : null;
    }
  }
  open_next_notes(tfile = this.current_note) {
    let note = this.get_next_note(tfile);
    this.open_note(note);
  }
  get_chain(tfile = this.current_note, prev = 10, next = 10, with_self = true) {
    if (tfile == null) {
      return [];
    }
    let res = new Array();
    if (with_self) {
      res.push(tfile);
    }
    let tmp = tfile;
    for (let i = prev; i != 0; i--) {
      let note = this.get_prev_note(tmp);
      if (!note) {
        break;
      } else if (res.includes(note)) {
        break;
      } else {
        res.unshift(note);
        tmp = note;
      }
    }
    tmp = tfile;
    for (let i = next; i != 0; i--) {
      let note = this.get_next_note(tmp);
      if (!note) {
        break;
      } else if (res.includes(note)) {
        break;
      } else {
        res.push(note);
        tmp = note;
      }
    }
    return res;
  }
  get_first_note(tfile = this.current_note) {
    let notes = this.get_chain(tfile, -1, 0, false);
    if (notes.length > 0) {
      return notes[0];
    } else {
      return null;
    }
  }
  get_last_note(tfile = this.current_note) {
    let notes = this.get_chain(tfile, 0, -1, false);
    if (notes.length > 0) {
      return notes[notes.length - 1];
    } else {
      return null;
    }
  }
  get_neighbors(tfile = this.current_note) {
    return [
      this.get_prev_note(tfile),
      this.get_next_note(tfile)
    ];
  }
  async chain_set_prev(tfile, prev) {
    if (tfile == null || tfile == prev) {
      return;
    }
    if (this.get_prev_note(tfile) == prev) {
      return;
    }
    let msg = `Note Chain: ${prev == null ? void 0 : prev.basename} --> \u{1F3E0}${tfile.basename}`;
    if (prev == null) {
      await this.editor.set_frontmatter(
        tfile,
        this.prev,
        null
      );
    } else {
      await this.editor.set_frontmatter(
        tfile,
        this.prev,
        `[[${prev.basename}]]`
      );
    }
    new import_obsidian3.Notice(msg, 5e3);
  }
  async chain_set_next(tfile, next) {
    if (tfile == null || tfile == next) {
      return;
    }
    if (this.get_next_note(tfile) == next) {
      return;
    }
    let msg = `Note Chain: \u{1F3E0}${tfile == null ? void 0 : tfile.basename} <-- ${next == null ? void 0 : next.basename}`;
    if (next == null) {
      await this.editor.set_frontmatter(
        tfile,
        this.next,
        null
      );
    } else {
      await this.editor.set_frontmatter(
        tfile,
        this.next,
        `[[${next.basename}]]`
      );
    }
    new import_obsidian3.Notice(msg, 5e3);
  }
  async chain_set_prev_next(tfile, prev, next) {
    if (tfile == null || prev == next || tfile == prev || tfile == next) {
      return;
    }
    if (this.get_prev_note(tfile) == prev) {
      await this.chain_set_next(tfile, next);
      return;
    }
    if (this.get_next_note(tfile) == next) {
      await this.chain_set_prev(tfile, prev);
      return;
    }
    let msg = `Note Chain: ${prev == null ? void 0 : prev.basename} --> \u{1F3E0}${tfile == null ? void 0 : tfile.basename} <-- ${next == null ? void 0 : next.basename}`;
    let fm = {};
    fm[this.prev] = prev ? `[[${prev.basename}]]` : null;
    fm[this.next] = next ? `[[${next.basename}]]` : null;
    await this.plugin.editor.set_multi_frontmatter(tfile, fm);
    new import_obsidian3.Notice(msg, 5e3);
  }
  async chain_link_prev_next(prev, next) {
    await this.chain_set_prev(next, prev);
    await this.chain_set_next(prev, next);
  }
  async chain_concat_tfiles(tfiles) {
    let prev = this.get_prev_note(tfiles[0]);
    if (tfiles.contains(prev)) {
      await this.chain_set_prev(tfiles[0], null);
    }
    let next = this.get_next_note(tfiles[tfiles.length - 1]);
    if (tfiles.contains(next)) {
      await this.chain_set_next(tfiles[tfiles.length - 1], null);
    }
    if (tfiles.length <= 1) {
      return;
    }
    let N = tfiles.length;
    await this.chain_set_next(tfiles[0], tfiles[1]);
    await this.chain_set_prev(tfiles[N - 1], tfiles[N - 2]);
    for (let i = 1; i < tfiles.length - 1; i++) {
      await this.chain_set_prev_next(tfiles[i], tfiles[i - 1], tfiles[i + 1]);
    }
  }
  async chain_pop_node(tfile) {
    let notes = this.get_neighbors(tfile);
    await this.chain_link_prev_next(notes[0], notes[1]);
  }
  async chain_insert_node_as_head(tfile, anchor) {
    let head = this.get_first_note(anchor);
    await this.chain_link_prev_next(tfile, head);
  }
  async chain_insert_node_as_tail(tfile, anchor) {
    let tail = this.get_last_note(anchor);
    await this.chain_link_prev_next(tail, tfile);
  }
  async chain_insert_node_after(tfile, anchor) {
    let anchor_next = this.get_next_note(anchor);
    if (anchor_next == tfile) {
      return;
    }
    let tfile_neighbor = this.get_neighbors(tfile);
    if (tfile_neighbor[1] == anchor) {
      await this.chain_concat_tfiles(
        [tfile_neighbor[0], anchor, tfile, anchor_next]
      );
    } else {
      await this.chain_pop_node(tfile);
      await this.chain_concat_tfiles([anchor, tfile, anchor_next]);
    }
  }
  async chain_insert_node_before(tfile, anchor) {
    let anchor_prev = this.get_prev_note(anchor);
    if (anchor_prev == tfile) {
      return;
    }
    let tfile_neighbor = this.get_neighbors(tfile);
    if (tfile_neighbor[0] == anchor) {
      await this.chain_concat_tfiles(
        [anchor_prev, tfile, anchor, tfile_neighbor[1]]
      );
    } else {
      await this.chain_pop_node(tfile);
      await this.chain_concat_tfiles([anchor_prev, tfile, anchor]);
    }
  }
  async chain_insert_folder_after(tfile, anchor) {
    if (!tfile.parent || tfile.parent.parent != anchor.parent) {
      return;
    }
    let note = this.get_tfile(tfile.parent.name);
    if (!note) {
      return;
    }
    await this.plugin.editor.set_multi_frontmatter(
      note,
      {
        "FolderPrevNote": `[[${anchor.basename}]]`,
        "FolderPrevNoteOffset": 0.5
      }
    );
  }
  async chain_suggester_tfiles(tfile = this.current_note, mode = "suggester") {
    let notes = this.get_brothers(tfile);
    if (notes.length == 0) {
      return;
    }
    let files = await this.suggester_sort(notes);
    await this.chain_concat_tfiles(files);
  }
  sort_tfiles(files, field) {
    if (typeof field === "string") {
      if (field === "name" || field === "alphabetical") {
        return files.sort(
          (a, b) => a.name.localeCompare(b.name)
        );
      } else if (field === "mtime" || field === "byModifiedTime") {
        return files.sort(
          (a, b) => {
            var _a, _b;
            return ((_a = a.stat) == null ? void 0 : _a.mtime) - ((_b = b.stat) == null ? void 0 : _b.mtime);
          }
        );
      } else if (field === "ctime" || field === "byCreatedTime") {
        return files.sort(
          (a, b) => {
            var _a, _b;
            return ((_a = a.stat) == null ? void 0 : _a.ctime) - ((_b = b.stat) == null ? void 0 : _b.ctime);
          }
        );
      } else if (field === "alphabeticalReverse") {
        return files.sort(
          (b, a) => a.name.localeCompare(b.name)
        );
      } else if (field === "byModifiedTimeReverse") {
        return files.sort(
          (b, a) => {
            var _a, _b;
            return ((_a = a.stat) == null ? void 0 : _a.mtime) - ((_b = b.stat) == null ? void 0 : _b.mtime);
          }
        );
      } else if (field === "byCreatedTimeReverse") {
        return files.sort(
          (b, a) => {
            var _a, _b;
            return ((_a = a.stat) == null ? void 0 : _a.ctime) - ((_b = b.stat) == null ? void 0 : _b.ctime);
          }
        );
      } else if (field === "chain") {
        return this.sort_tfiles_by_chain(files);
      }
      return files;
    } else if (typeof field === "object") {
      if (field instanceof Array) {
        let nfiles = this.sort_tfiles(files, field[0]);
        if (field.length >= 2) {
          if (field[1] === "x") {
            return nfiles.reverse();
          }
        }
        return nfiles;
      }
    }
    return files;
  }
  sort_tfiles_by_chain(tfiles) {
    let notes = tfiles.filter((f) => f instanceof import_obsidian3.TFile);
    let res = [];
    let ctfiles = [];
    while (notes.length > 0) {
      let note = notes[0];
      if (note instanceof import_obsidian3.TFile) {
        let xchain = this.get_chain(note, -1, -1);
        for (let x of xchain) {
          if (notes.contains(x)) {
            ctfiles.push(x);
            notes.remove(x);
          }
        }
      }
    }
    res.push(...ctfiles);
    let canvas = res.filter((f) => f instanceof import_obsidian3.TFile && f.extension == "canvas");
    res = res.filter((f) => f instanceof import_obsidian3.TFile && f.extension != "canvas");
    let folders = tfiles.filter((f) => f instanceof import_obsidian3.TFolder);
    if (folders.length > 0) {
      let indexOf = function(f) {
        if (f instanceof import_obsidian3.TFile) {
          return res.indexOf(f);
        } else if (f instanceof import_obsidian3.TFolder) {
          return idxs[folders.indexOf(f)];
        } else {
          return -1;
        }
      };
      let idxs = folders.map(
        (f) => this.indexOfFolder(f, ctfiles)
      );
      res.push(...folders);
      res = res.sort((a, b) => indexOf(a) - indexOf(b));
    }
    for (let tfile of canvas) {
      let rname = res.map((x) => x instanceof import_obsidian3.TFolder ? x.name : x.basename);
      let cname = tfile.basename;
      let idx = rname.indexOf(cname);
      if (idx < 0) {
        idx = rname.indexOf(cname.split(".").slice(0, -1).join("."));
      }
      if (idx < 0) {
        res.push(tfile);
      } else {
        res.splice(idx + 1, 0, tfile);
      }
    }
    return res;
  }
  sort_tfiles_folder_first(tfiles) {
    let A = tfiles.filter((f) => f instanceof import_obsidian3.TFolder).sort((a, b) => a.name.localeCompare(b.name));
    let B = tfiles.filter((f) => f instanceof import_obsidian3.TFile);
    return this.plugin.utils.concat_array([A, B]);
  }
  sort_tfiles_by_field(tfiles, field) {
    let res = tfiles.sort(
      (a, b) => {
        let av = this.editor.get_frontmatter(a, field);
        let bv = this.editor.get_frontmatter(b, field);
        return av - bv;
      }
    );
    return res;
  }
  async suggester_sort(tfiles) {
    if (!tfiles) {
      return [];
    }
    if (tfiles.length == 0) {
      return [];
    }
    ;
    let kv = {
      "chain": "chain",
      "name (a to z)": "name",
      "ctime (old to new)": "ctime",
      "mtime (old to new)": "mtime",
      "name (z to a)": ["name", "x"],
      "ctime (new to old)": ["ctime", "x"],
      "mtime (new to old)": ["mtime", "x"]
    };
    let field = await this.tp_suggester(
      Object.keys(kv),
      Object.values(kv)
    );
    if (field == null) {
      return [];
    }
    if (field == "chain") {
      tfiles = this.sort_tfiles(tfiles, "name");
    }
    return this.sort_tfiles(tfiles, field);
  }
  view_sort_by_chain() {
    var _a;
    let view = (_a = this.app.workspace.getLeavesOfType(
      "file-explorer"
    )[0]) == null ? void 0 : _a.view;
    if (!view) {
      return;
    }
    view.sort();
    if (view.ready) {
      for (let path in view.fileItems) {
        let item = view.fileItems[path];
        if (item.vChildren) {
          let files = item.vChildren._children.map((f) => f.file);
          files = this.sort_tfiles_by_chain(files);
          let children = item.vChildren._children.sort(
            (a, b) => files.indexOf(a.file) - files.indexOf(b.file)
          );
          item.vChildren.setChildren(children);
        }
      }
      view.tree.infinityScroll.compute();
    }
  }
  async get_file_links(tfile, xlinks = true, inlinks = true, outlinks = true, onlymd = false) {
    let items = {};
    if (!tfile) {
      return items;
    }
    items["\u{1F3E0} " + tfile.basename] = this.app.vault.adapter.getFullPath(tfile.path);
    if (xlinks) {
      let tmp;
      tmp = this.editor.get_frontmatter(tfile, "github");
      if (tmp) {
        if (tmp.contains("github.com")) {
          items["\u{1F310}github"] = tmp;
        } else {
          items["\u{1F310}github"] = `https://github.com/` + tmp;
        }
      }
      tmp = this.editor.get_frontmatter(tfile, "huggingface");
      if (tmp) {
        if (tmp.contains("huggingface.co")) {
          items["\u{1F310}huggingface\u{1F917}"] = tmp;
        } else {
          items["\u{1F310}huggingface\u{1F917}"] = `https://huggingface.co/` + tmp;
        }
      }
      tmp = this.editor.get_frontmatter(tfile, "arxiv");
      if (tmp == null ? void 0 : tmp.ID) {
        items["\u{1F310}arxiv"] = `https://arxiv.org/abs/` + (tmp == null ? void 0 : tmp.ID);
      }
      let text = await this.app.vault.cachedRead(tfile);
      const regex = /\[[^(\[\])]*?\]\(.*?\)/g;
      const matches = text.match(regex);
      if (matches) {
        for (const match of matches) {
          let key = match.slice(1, match.indexOf("]("));
          let value = match.slice(match.indexOf("](")).slice(2, -1);
          if (value === "") {
            continue;
          }
          if (key === "") {
            key = value;
          }
          if (value.startsWith("http")) {
            key = "\u{1F310} " + key;
          } else if (value.startsWith("file:///")) {
            value = value.slice(8);
            key = "\u{1F4C1} " + key;
          } else {
            key = "\u{1F517} " + key;
          }
          items[key] = value;
        }
      }
    }
    if (inlinks) {
      let links = this.get_inlinks();
      for (let i of links) {
        if (onlymd && !(i.extension === "md")) {
          continue;
        }
        if (i.extension === "md") {
          items["\u2139\uFE0F " + i.basename] = this.app.vault.adapter.getFullPath(i.path);
        } else {
          items["\u2139\uFE0F " + i.name] = this.app.vault.adapter.getFullPath(i.path);
        }
      }
    }
    if (outlinks) {
      let links = this.get_outlinks();
      for (let i of links) {
        if (onlymd && !(i.extension === "md")) {
          continue;
        }
        if (i.extension === "md") {
          items["\u{1F17E}\uFE0F " + i.basename] = this.app.vault.adapter.getFullPath(i.path);
        } else {
          items["\u{1F17E}\uFE0F " + i.name] = this.app.vault.adapter.getFullPath(i.path);
        }
      }
    }
    items["\u{1F492} vault"] = this.app.vault.adapter.getFullPath(".");
    return items;
  }
};

// src/NCFileExplorer.ts
var chain_sort = function(org_sort) {
  let plugin = this.app.plugins.getPlugin("note-chain");
  return function(...d) {
    if (plugin) {
      if (plugin == null ? void 0 : plugin.settings.isSortFileExplorer) {
        let e = this.file, t = this.view, i = e.children.slice();
        i = i.filter((x) => x);
        if (i.length > 0) {
          let items = plugin.chain.children[i[0].parent.path];
          if (items) {
            let a = items.filter((x) => i.contains(x));
            let b = items.filter((x) => !i.contains(x));
            a.push(...b);
            i = a;
          }
        }
        if (plugin.settings.isFolderFirst) {
          i = plugin.chain.sort_tfiles_folder_first(i);
        }
        let r = [];
        for (let o = 0, a = i; o < a.length; o++) {
          let s = a[o], l = t.fileItems[s.path];
          l && r.push(l);
        }
        this.vChildren.setChildren(r);
      } else {
        return org_sort.call(this, ...d);
      }
    } else {
      return org_sort.call(this, ...d);
    }
  };
};
var getSortedFolderItems = function(org_sort) {
  let plugin = this.app.plugins.getPlugin("note-chain");
  return function(e) {
    if (plugin) {
      try {
        let res = org_sort.call(this, e);
        let tfiles = plugin.chain.children[e.path];
        if (tfiles) {
          res = res.sort((a, b) => tfiles.indexOf(a.file) - tfiles.indexOf(b.file));
        }
        return res;
      } catch (e2) {
        return org_sort.call(this, e2);
      }
    } else {
      return org_sort.call(this, e);
    }
  };
};
var NCFileExplorer = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.chain = plugin.chain;
    this.app = plugin.app;
    this.register();
  }
  register() {
    this.app.workspace.onLayoutReady(() => {
      let folder = this.app.vault.getAllFolders()[0];
      let dom = this.file_explorer.createFolderDom(folder).constructor;
      this._FolderDom_ = dom;
      this.org_sort = dom.prototype.sort;
      this.new_sort = chain_sort(this.org_sort);
      this._FolderDom_.prototype.sort = this.new_sort;
      this.getSortedFolderItems = this.file_explorer.constructor.prototype.getSortedFolderItems;
      this.getSortedFolderItems_new = getSortedFolderItems(this.getSortedFolderItems);
      this.file_explorer.constructor.prototype.getSortedFolderItems = this.getSortedFolderItems_new;
      this.sort(0, true);
    });
  }
  unregister() {
    if (this.org_sort) {
      this._FolderDom_.prototype.sort = this.org_sort;
    }
    if (this.getSortedFolderItems) {
      this.file_explorer.constructor.prototype.getSortedFolderItems = this.getSortedFolderItems;
    }
  }
  get file_explorer() {
    var _a;
    let view = (_a = this.app.workspace.getLeavesOfType(
      "file-explorer"
    )[0]) == null ? void 0 : _a.view;
    return view;
  }
  async sort(nsleep = 0, init = false) {
    var _a;
    if ((_a = this.file_explorer) == null ? void 0 : _a.sort) {
      if (nsleep > 0) {
        await sleep(nsleep);
      }
      if (init) {
        this.plugin.chain.init_children();
      }
      if (Object.keys(this.plugin.chain.children).length == 0) {
        setTimeout(() => {
          this.sort(nsleep, true);
        }, 3e3);
      } else {
        this.file_explorer.sort();
      }
    }
  }
};

// src/strings.ts
var Strings = class {
  constructor() {
    let lang = window.localStorage.getItem("language");
    if (lang) {
      this.language = lang;
    } else {
      this.language = "en";
    }
  }
  get cmd_mermaid_flowchart_link() {
    if (this.language == "zh") {
      return "Mermaid\u94FE\u63A5\u5361\u7247";
    } else {
      return "Mermaid of linked notes";
    }
  }
  get cmd_mermaid_flowchart_folder() {
    if (this.language == "zh") {
      return "Mermaid\u76EE\u5F55\u5361\u7247";
    } else {
      return "Mermaid of folder notes";
    }
  }
  get cmd_mermaid_flowchart_auto() {
    if (this.language == "zh") {
      return "Mermaid\u5361\u7247";
    } else {
      return "Mermaid of notes";
    }
  }
  get cmd_file_open_with_system_app() {
    if (this.language == "zh") {
      return "\u6587\u4EF6 - \u4F7F\u7528\u7CFB\u7EDF\u7A0B\u5E8F\u6253\u5F00\uFF08\u4EC5\u684C\u9762\uFF09";
    } else {
      return "File - open with system app (desktop only)";
    }
  }
  get cmd_file_show_in_system_explorer() {
    if (this.language == "zh") {
      return "\u6587\u4EF6 - \u5728\u7CFB\u7EDF\u6D4F\u89C8\u7684\u67E5\u770B\uFF08\u4EC5\u684C\u9762\uFF09";
    } else {
      return "File - show in system explorer (desktop only)";
    }
  }
  get cmd_file_rename() {
    if (this.language == "zh") {
      return "\u6587\u4EF6 - \u91CD\u547D\u540D\u6587\u4EF6";
    } else {
      return "File - rename file";
    }
  }
  get cmd_longform2notechain() {
    if (this.language == "zh") {
      return "\u6839\u636ELongForm\u91CD\u7F6E\u7B14\u8BB0\u94FE\u6761";
    } else {
      return "Reset note chain by longform";
    }
  }
  get cmd_longform4notechain() {
    if (this.language == "zh") {
      return "\u6839\u636E\u7B14\u8BB0\u94FE\u6761\uFF0C\u91CD\u7F6ELongForm\u573A\u666F";
    } else {
      return "Reset longform scenes by note chain";
    }
  }
  get cmd_sort_file_explorer() {
    if (this.language == "zh") {
      return "\u6839\u636E\u7B14\u8BB0\u94FE\u6392\u5E8F";
    } else {
      return "Sort file explorer by note chain";
    }
  }
  get cmd_open_notes_smarter() {
    if (this.language == "zh") {
      return "\u667A\u80FD\u6253\u5F00\u6587\u4EF6";
    } else {
      return "Open note smarter";
    }
  }
  get cmd_open_note() {
    if (this.language == "zh") {
      return "\u6253\u5F00\u6587\u4EF6";
    } else {
      return "Open note";
    }
  }
  get cmd_open_prev_note() {
    if (this.language == "zh") {
      return "\u6253\u5F00\u524D\u7F6E\u7B14\u8BB0";
    } else {
      return "Open prev note";
    }
  }
  get chain_move_up_node() {
    if (this.language == "zh") {
      return "\u6253\u5F00\u524D\u7F6E\u7B14\u8BB0";
    } else {
      return "Move node up";
    }
  }
  get chain_move_down_node() {
    if (this.language == "zh") {
      return "\u6253\u5F00\u524D\u7F6E\u7B14\u8BB0";
    } else {
      return "Move node down";
    }
  }
  get cmd_open_next_note() {
    if (this.language == "zh") {
      return "\u6253\u5F00\u540E\u7F6E\u7B14\u8BB0";
    } else {
      return "Open next note";
    }
  }
  get cmd_reveal_note() {
    if (this.language == "zh") {
      return "\u5B9A\u4F4D\u5F53\u524D\u7B14\u8BB0";
    } else {
      return "Reveal current file in navigation";
    }
  }
  get cmd_open_and_reveal_note() {
    if (this.language == "zh") {
      return "\u6253\u5F00\u5E76\u5B9A\u4F4D\u7B14\u8BB0";
    } else {
      return "Open and reveal note";
    }
  }
  get cmd_open_prev_note_of_right_leaf() {
    if (this.language == "zh") {
      return "\u53F3\u4FA7\u9875\u9762\u6253\u5F00\u524D\u7F6E\u7B14\u8BB0";
    } else {
      return "Open prev note of right leaf";
    }
  }
  get cmd_open_next_note_of_right_leaf() {
    if (this.language == "zh") {
      return "\u53F3\u4FA7\u9875\u9762\u6253\u5F00\u540E\u7F6E\u7B14\u8BB0";
    } else {
      return "Open next note of right leaf";
    }
  }
  get filemenu_create_next_note() {
    if (this.language == "zh") {
      return "\u521B\u5EFA\u540E\u7F6E\u7B14\u8BB0";
    } else {
      return "Create next note";
    }
  }
  get filemenu_move_as_next_note() {
    if (this.language == "zh") {
      return "\u79FB\u52A8\u4E3A\u540E\u7F6E\u7B14\u8BB0";
    } else {
      return "Move as next note";
    }
  }
  get clear_inlinks() {
    if (this.language == "zh") {
      return "\u6E05\u7406\u7B14\u8BB0\u5165\u94FE";
    } else {
      return "Clear inlinks of current file";
    }
  }
  get move_file_to_another_folder() {
    if (this.language == "zh") {
      return "\u79FB\u52A8\u5F53\u524D\u6587\u4EF6";
    } else {
      return "Move current file to another folder";
    }
  }
  get replace_notes_with_regx() {
    if (this.language == "zh") {
      return "\u6B63\u5219\u8868\u8FBE\u5F0F\u66FF\u6362\u7B14\u8BB0\u5185\u5BB9";
    } else {
      return "Replace by regex";
    }
  }
  get chain_insert_node() {
    if (this.language == "zh") {
      return "\u63D2\u5165\u8282\u70B9";
    } else {
      return "Insert node of chain";
    }
  }
  get chain_set_seq_note() {
    if (this.language == "zh") {
      return "\u91CD\u5851\u5F53\u524D\u6587\u4EF6\u5939\u7B14\u8BB0\u94FE\u6761";
    } else {
      return "Rebuild the chain of current folder";
    }
  }
  get create_new_note() {
    if (this.language == "zh") {
      return "\u521B\u5EFA\u65B0\u7B14\u8BB0";
    } else {
      return "Create new note";
    }
  }
  get setting_isSortFileExplorer() {
    if (this.language == "zh") {
      return "\u6839\u636E\u7B14\u8BB0\u94FE\u6761\u6392\u5E8F\u76EE\u5F55";
    } else {
      return "Sort by chain in file explorer?";
    }
  }
  get setting_isFolderFirst() {
    if (this.language == "zh") {
      return "\u6392\u5E8F\u65F6\u76EE\u5F55\u65F6\u6587\u4EF6\u5939\u4F18\u5148\uFF1F";
    } else {
      return "Sort folder first in file explorer?";
    }
  }
  get setting_PrevChain() {
    if (this.language == "zh") {
      return "\u524D\u7F6E\u7B14\u8BB0\u6570\u91CF\uFF1F";
    } else {
      return "Number of prev notes to show?";
    }
  }
  get setting_NextChain() {
    if (this.language == "zh") {
      return "\u540E\u7F6E\u7B14\u8BB0\u6570\u91CF\uFF1F";
    } else {
      return "Number of next notes to show?";
    }
  }
  get setting_suggesterNotesMode() {
    if (this.language == "zh") {
      return `${this.chain_insert_node}\uFF1A\u9ED8\u8BA4\u6A21\u5F0F`;
    } else {
      return `${this.chain_insert_node}:Default mode`;
    }
  }
  get setting_auto_notechain() {
    if (this.language == "zh") {
      return "\u6253\u5F00\u6587\u4EF6\u65F6\uFF0C\u81EA\u52A8\u91CD\u5851\u6587\u4EF6\u5939\u7B14\u8BB0\u94FE\uFF1F";
    } else {
      return "Auto build notechain of folder while open new file?";
    }
  }
  get setting_refreshDataView() {
    if (this.language == "zh") {
      return "\u6253\u5F00\u6587\u4EF6\u65F6\uFF0C\u5237\u65B0Dataview\u89C6\u56FE\uFF1F";
    } else {
      return "Refresh dataview while open new file?";
    }
  }
  get setting_refreshTasks() {
    if (this.language == "zh") {
      return "\u6253\u5F00\u6587\u4EF6\u65F6\uFF0C\u5237\u65B0Tasks\u89C6\u56FE\uFF1F";
    } else {
      return "Refresh tasks while open new file?";
    }
  }
  get setting_wordcout() {
    if (this.language == "zh") {
      return "\u7EDF\u8BA1\u6BCF\u65E5\u5B57\u6570";
    } else {
      return "Register daily word count?";
    }
  }
  get setting_wordcout_xfolder() {
    if (this.language == "zh") {
      return "\u8DF3\u8FC7\u4EE5\u4E0B\u76EE\u5F55";
    } else {
      return "Ignore these folders";
    }
  }
  get item_insert_suggester() {
    if (this.language == "zh") {
      return "\u63D2\u5165\u6A21\u5F0F\uFF08\u76F8\u5BF9\u4E8E\u951A\u70B9\uFF09";
    } else {
      return "Insert mode(relate to anchor).";
    }
  }
  get item_insert_node_after() {
    if (this.language == "zh") {
      return "\u540E\u7F6E\u7B14\u8BB0";
    } else {
      return "Next note";
    }
  }
  get item_insert_node_before() {
    if (this.language == "zh") {
      return "\u524D\u7F6E\u7B14\u8BB0";
    } else {
      return "Prev note";
    }
  }
  get item_insert_node_as_head() {
    if (this.language == "zh") {
      return "\u94FE\u5934";
    } else {
      return "Head of chain";
    }
  }
  get item_insert_node_as_tail() {
    if (this.language == "zh") {
      return "\u94FE\u5C3E";
    } else {
      return "Tail of thain";
    }
  }
  get item_insert_folder_after() {
    if (this.language == "zh") {
      return "\u6587\u4EF6\u5939\u540E\u7F6E";
    } else {
      return "Folder as next";
    }
  }
  get item_get_brothers() {
    if (this.language == "zh") {
      return "\u540C\u7EA7\u7B14\u8BB0";
    } else {
      return "Notes in same folder";
    }
  }
  get item_same_folder() {
    if (this.language == "zh") {
      return "\u540C\u7EA7\u7B14\u8BB0+\u5B50\u76EE\u5F55";
    } else {
      return "Notes in same folder(recursive)";
    }
  }
  get item_inlinks_outlinks() {
    if (this.language == "zh") {
      return "\u51FA\u94FE+\u5165\u94FE";
    } else {
      return "outLinks + inLinks";
    }
  }
  get item_inlins() {
    if (this.language == "zh") {
      return "\u5165\u94FE";
    } else {
      return "inlinks";
    }
  }
  get item_outlinks() {
    if (this.language == "zh") {
      return "\u51FA\u94FE";
    } else {
      return "outlinks";
    }
  }
  get item_all_noes() {
    if (this.language == "zh") {
      return "\u6240\u6709\u7B14\u8BB0";
    } else {
      return "All notes";
    }
  }
  get item_recent() {
    if (this.language == "zh") {
      return "\u8FD1\u671F\u7B14\u8BB0\uFF08\u57FA\u4E8E\u63D2\u4EF6\uFF1Arecent-files-obsidian\uFF09";
    } else {
      return "Recent (Based on recent files plugin)";
    }
  }
  get item_uncle_notes() {
    if (this.language == "zh") {
      return "\u4E0A\u7EA7\u7B14\u8BB0";
    } else {
      return "Notes in grandpa folder";
    }
  }
  get item_notechain() {
    if (this.language == "zh") {
      return "\u7B14\u8BB0\u94FE\u6761";
    } else {
      return "Note chain";
    }
  }
  get item_currentnote() {
    if (this.language == "zh") {
      return "\u5F53\u524D\u7B14\u8BB0";
    } else {
      return "Current note";
    }
  }
  get item_chain_insert_node_after() {
    if (this.language == "zh") {
      return "\u6DFB\u52A0\u540E\u7F6E\u7B14\u8BB0";
    } else {
      return "Create next note";
    }
  }
  get item_chain_insert_node_as_tail() {
    if (this.language == "zh") {
      return "\u94FE\u5C3E\u6DFB\u52A0\u7B14\u8BB0";
    } else {
      return "Create tail note";
    }
  }
  get item_chain_insert_node_before() {
    if (this.language == "zh") {
      return "\u6DFB\u52A0\u524D\u7F6E\u7B14\u8BB0";
    } else {
      return "Create prev note";
    }
  }
  get item_chain_insert_node_as_head() {
    if (this.language == "zh") {
      return "\u94FE\u5934\u6DFB\u52A0\u7B14\u8BB0";
    } else {
      return "Create head note";
    }
  }
  get item_item_chain_insert_null() {
    if (this.language == "zh") {
      return "\u65E0\u94FE\u63A5";
    } else {
      return "Create note not in chain";
    }
  }
  get prompt_notename() {
    if (this.language == "zh") {
      return "\u8F93\u5165\u7B14\u8BB0\u540D";
    } else {
      return "Input note name";
    }
  }
};
var strings = new Strings();

// src/WordCount.ts
var import_obsidian4 = require("obsidian");
var WordCount = class {
  constructor(plugin, app) {
    this.plugin = plugin;
    this.app = app;
    this.nretry = 100;
    this.register();
  }
  filter(tfile) {
    if (!tfile) {
      return false;
    }
    if (tfile.deleted) {
      return false;
    }
    if (tfile.extension != "md") {
      return false;
    }
    let xfolders = this.plugin.settings.wordcountxfolder.split("\n").filter((x) => x != "");
    for (let item of xfolders) {
      if (tfile.path.startsWith(item)) {
        return false;
      }
    }
    return true;
  }
  count_words(ctx, ignore = /[\s!"#$%&'()*+,./:;<=>?@[\]^_`{|}，。！？【】、；：“”‘’《》（）［］—…￥]/g) {
    let headerRegex = /^---\s*([\s\S]*?)\s*---/;
    let match = headerRegex.exec(ctx);
    if (match) {
      ctx = ctx.slice(match[0].length).trim();
    }
    let N = ctx.replace(ignore, "").length;
    let enregex = /[a-zA-Z0-9-]+/g;
    let matches = ctx.match(enregex);
    if (matches) {
      let elen = 0;
      matches.forEach((x) => elen = elen + x.length);
      N = N - elen + matches.length;
    }
    return N;
  }
  async set_mtime_value(tfile, key, val) {
    var _a, _b;
    let activeView = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
    let editorState = {};
    if (activeView && activeView.file === tfile) {
      let editor = activeView.editor;
      if (editor) {
        editorState.cursor = editor.getCursor();
        editorState.selection = editor.getSelection();
        editorState.sanchor = editor.getCursor("anchor");
        editorState.shead = editor.getCursor("head");
        editorState.scrollInfo = editor.getScrollInfo();
      }
    }
    let aline = ((_a = editorState == null ? void 0 : editorState.cursor) == null ? void 0 : _a.line) !== void 0 ? (_b = activeView == null ? void 0 : activeView.editor) == null ? void 0 : _b.getLine(editorState.cursor.line) : void 0;
    if (aline && aline.startsWith("|") && aline.endsWith("|")) {
      return;
    }
    await this.app.fileManager.processFrontMatter(
      tfile,
      (fm) => {
        let t = import_obsidian4.moment.unix(tfile.stat.mtime / 1e3);
        let mtime = t.format("YYYY-MM-DD");
        if (fm[key] == null) {
          if (val > 0) {
            fm[key] = {};
            if (mtime == (0, import_obsidian4.moment)().format("YYYY-MM-DD") && mtime != import_obsidian4.moment.unix(tfile.stat.ctime / 1e3).format("YYYY-MM-DD")) {
              fm[key][t.add(-1, "days").format("YYYY-MM-DD")] = val;
            } else {
              fm[key][mtime] = val;
            }
          }
        } else {
          let ts = Object.keys(fm[key]).sort((b, a) => a.localeCompare(b)).filter((x) => !(x == mtime));
          if (ts.length == 0) {
            if (val > 0) {
              fm[key][mtime] = val;
            } else if (fm[key][mtime]) {
              fm[key][mtime] = val;
            }
          } else {
            if (val - fm[key][ts[0]] != 0) {
              fm[key][mtime] = val;
            } else if (fm[key][mtime]) {
              delete fm[key][mtime];
            }
          }
        }
      }
    );
    if (activeView && activeView.file === tfile) {
      let editor = activeView.editor;
      if (editor) {
        if (editorState.scrollInfo) {
          editor.scrollTo(editorState.scrollInfo.left, editorState.scrollInfo.top);
        }
        if (editorState.selection && editorState.sanchor && editorState.shead) {
          try {
            editor.setSelection(editorState.sanchor, editorState.shead);
          } catch (error) {
            new import_obsidian4.Notice(`Error setting selection:${error}`, 3e3);
          }
        } else if (editorState.cursor) {
          editor.setCursor(editorState.cursor);
        }
      }
    }
  }
  get_new_words(tfile, day = (0, import_obsidian4.moment)().format("YYYY-MM-DD")) {
    var _a;
    let meta = this.app.metadataCache.getFileCache(tfile);
    let values = (_a = meta == null ? void 0 : meta.frontmatter) == null ? void 0 : _a.words;
    if (values) {
      let keys = Object.keys(values).sort((a, b) => a.localeCompare(b));
      let idx = keys.indexOf(day);
      if (idx < 0) {
        return 0;
      } else if (idx == 0) {
        return values[day];
      } else {
        return values[day] - values[keys[idx - 1]];
      }
    }
  }
  async update_word_count(tfile) {
    if (!this.filter(tfile)) {
      return;
    }
    let ctx = await this.app.vault.cachedRead(tfile);
    let N = this.count_words(ctx);
    await this.set_mtime_value(tfile, "words", N);
  }
  check_frontmatter(tfile, kv) {
    try {
      if (!tfile) {
        return false;
      }
      let meta = this.app.metadataCache.getFileCache(tfile);
      if (meta == null ? void 0 : meta.frontmatter) {
        for (let k in kv) {
          if (!(meta.frontmatter[k] == kv[k])) {
            return false;
          }
        }
        return true;
      }
      return false;
    } catch (error) {
      return false;
    }
  }
  async wait_frontmatter(tfile, kv, nretry = this.nretry) {
    let flag = this.check_frontmatter(tfile, kv);
    while (!flag && nretry > 0) {
      await sleep(50);
      nretry = nretry - 1;
      flag = this.check_frontmatter(tfile, kv);
    }
    return flag;
  }
  async update_word_count_of_vault() {
    let tfiles = this.app.vault.getMarkdownFiles().filter((x) => this.filter(x));
    let i = 0;
    for (let tfile of tfiles) {
      new import_obsidian4.Notice(`${i}/${tfiles.length}:${tfile.name}`, 3e3);
      await this.update_word_count(tfile);
      i = i + 1;
    }
  }
  register() {
    if (this.plugin.settings.wordcout) {
      this.regeister_editor_change();
      this.regeister_active_leaf_change();
    }
  }
  regeister_editor_change() {
    this.plugin.registerEvent(
      this.app.workspace.on("editor-change", async (editor, info) => {
        var _a;
        if (((_a = info.file) == null ? void 0 : _a.extension) != "md") {
          return;
        }
        if (this.timerId !== null) {
          clearTimeout(this.timerId);
        }
        if (info.file) {
          this.timerId = setTimeout(() => {
            this.update_word_count(info.file);
          }, 3e3);
        }
      })
    );
  }
  regeister_active_leaf_change() {
    this.plugin.registerEvent(
      this.app.workspace.on("active-leaf-change", async (leaf) => {
        var _a, _b;
        let tfile = (leaf == null ? void 0 : leaf.view).file;
        if (!(leaf == null ? void 0 : leaf.view)) {
          return;
        }
        if (!(((_b = (_a = leaf.view) == null ? void 0 : _a.file) == null ? void 0 : _b.extension) == "md")) {
          return;
        }
        await this.update_word_count(tfile);
        if (this.curr_active_file == null) {
          this.curr_active_file = tfile;
          return;
        }
        if (this.curr_active_file != tfile) {
          await this.update_word_count(this.curr_active_file);
          this.curr_active_file = tfile;
        }
      })
    );
  }
  get_words_of_tfiles() {
    return this.plugin.chain.get_all_tfiles().map(
      (x) => this.plugin.editor.get_frontmatter(x, "words")
    ).filter((x) => x);
  }
  sum_words_of_tifles(files, begt, endt) {
    if (typeof begt == "number") {
      begt = (0, import_obsidian4.moment)().add(-begt, "days").format("YYYY-MM-DD");
    }
    if (typeof endt == "number") {
      endt = (0, import_obsidian4.moment)().add(-endt, "days").format("YYYY-MM-DD");
    }
    let startDate = new Date(begt);
    let endDate = new Date(endt);
    let dailyWordCounts = {};
    for (let date = new Date(startDate); date <= endDate; date.setDate(date.getDate() + 1)) {
      let dateStr = date.toISOString().split("T")[0];
      dailyWordCounts[dateStr] = 0;
    }
    files.forEach((file) => {
      let lastWordCount = 0;
      let earliestDate = new Date(Object.keys(file).sort()[0]);
      if (earliestDate < startDate) {
        lastWordCount = file[earliestDate.toISOString().split("T")[0]];
      }
      for (let date = new Date(startDate); date <= endDate; date.setDate(date.getDate() + 1)) {
        let dateStr = date.toISOString().split("T")[0];
        if (file.hasOwnProperty(dateStr)) {
          lastWordCount = file[dateStr];
        }
        dailyWordCounts[dateStr] += lastWordCount;
      }
    });
    return dailyWordCounts;
  }
  diff_words_of_tifles(dailyWordCounts, first_as_zero = true) {
    let dailyNewWordCounts = {};
    let previousTotal = 0;
    let first = "";
    for (let date in dailyWordCounts) {
      if (first === "") {
        first = date;
      }
      let currentTotal = dailyWordCounts[date];
      dailyNewWordCounts[date] = currentTotal - previousTotal;
      previousTotal = currentTotal;
    }
    if (first_as_zero && first !== "") {
      dailyNewWordCounts[first] = 0;
    }
    return dailyNewWordCounts;
  }
};

// src/graph.ts
var import_obsidian5 = require("obsidian");
var NoteNode = class {
  constructor(tfile) {
    this.tfile = tfile;
    this.note2id = {};
    this.id = 0;
  }
  // 返回 IDXXXX
  get_id(tfile) {
    if (tfile.basename in this.note2id) {
      return this.note2id[tfile.basename];
    }
    let newId = `ID${this.id.toString().padStart(4, "0")}`;
    this.note2id[tfile.basename] = newId;
    this.id = this.id + 1;
    return newId;
  }
  // 返回IDXXXX["tfile.basename"]
  get_node(tfile) {
    let id = this.get_id(tfile);
    return `${id}("${tfile.basename}")`;
  }
  get_mehrmaid_node(node) {
    if (node in this.note2id) {
      return this.note2id[node];
    }
    let newId = `ID${this.id.toString().padStart(4, "0")}`;
    this.note2id[node] = newId;
    this.id = this.id + 1;
    return `${newId}("${node}")`;
  }
  notes2class() {
    let msg = "\n";
    for (let tfile in this.note2id) {
      msg = msg + `	class ${this.note2id[tfile]} internal-link;
`;
    }
    return msg;
  }
};
var MermaidGraph = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.app = plugin.app;
    this.editor = plugin.editor;
    this.editor = new NCEditor(this.app);
  }
  get_note_node(tfile) {
    let node = new NoteNode(tfile);
    return node;
  }
  subgraph_chain(node, tfiles, subgraph = "", line = "<-->") {
    let msg = "";
    let items = tfiles.map((x) => x);
    let stab = "	";
    if (subgraph != "") {
      msg = msg + `
	subgraph ${subgraph}
`;
      stab = "		";
    }
    let i = 0;
    while (i < items.length - 1) {
      let prev = node.get_node(items[i]);
      let next = node.get_node(items[i + 1]);
      msg = msg + `${stab}${prev}${line}${next}
`;
      i = i + 1;
    }
    if (subgraph != "") {
      msg = msg + "	end\n";
    }
    return msg;
  }
  subgraph_links(node, tfiles, subgraph = "", line = "-->", tfiles_first = false) {
    let msg = "";
    let items = tfiles.map((x) => x);
    let stab = "	";
    if (subgraph != "") {
      msg = msg + `
	subgraph ${subgraph}
`;
      stab = "		";
    }
    let i = 0;
    let sid = node.get_node(node.tfile);
    while (i < items.length) {
      let id = node.get_node(items[i]);
      if (tfiles_first) {
        msg = msg + `${stab}${id}${line}${sid}
`;
      } else {
        msg = msg + `${stab}${sid}${line}${id}
`;
      }
      i = i + 1;
    }
    if (subgraph != "") {
      msg = msg + "	end\n";
    }
    return msg;
  }
  // [src,dst,io]
  edges_of_tfiles(tfiles, merge_inout = true) {
    let inlinks = {};
    let outlinks = {};
    for (let tfile of tfiles) {
      outlinks[tfiles.indexOf(tfile)] = this.plugin.chain.get_outlinks(tfile, true);
      inlinks[tfiles.indexOf(tfile)] = this.plugin.chain.get_inlinks(tfile, true);
    }
    let edges = [];
    for (let tfile of tfiles) {
      let i = tfiles.indexOf(tfile);
      for (let outlink of outlinks[i]) {
        if (tfiles.contains(outlink)) {
          if (tfiles.indexOf(outlink) <= i) {
            continue;
          }
          if (merge_inout) {
            if (inlinks[i].contains(outlink)) {
              edges.push([tfile, outlink, true]);
            } else {
              edges.push([tfile, outlink, false]);
            }
          } else {
            edges.push([tfile, outlink, false]);
          }
        }
      }
      for (let inlink of inlinks[i]) {
        if (tfiles.contains(inlink)) {
          if (tfiles.indexOf(inlink) <= i) {
            continue;
          }
          if (merge_inout) {
            if (!outlinks[i].contains(inlink)) {
              edges.push([inlink, tfile, false]);
            }
          } else {
            edges.push([inlink, tfile, false]);
          }
        }
      }
    }
    return edges;
  }
  subgraph_cross(node, tfiles, subgraph = "", line = "-->", tfiles_first = false) {
    let msg = "";
    let items = tfiles.map((x) => x);
    let stab = "	";
    if (subgraph != "") {
      msg = msg + `
	subgraph ${subgraph}
`;
      stab = "		";
    }
    let edges = this.edges_of_tfiles(tfiles);
    for (let edge of edges) {
      let sid = node.get_node(edge[0]);
      let did = node.get_node(edge[1]);
      if (edge[2]) {
        msg = msg + `${stab}${sid}<-.->${did}
`;
      } else {
        msg = msg + `${stab}${sid}-.->${did}
`;
      }
    }
    if (subgraph != "") {
      msg = msg + "	end\n";
    }
    return msg;
  }
  get_flowchart(tfile, N = 2, c_chain = "#F05454", c_inlink = "#776B5D", c_outlink = "#222831", c_anchor = "#40A578") {
    if (!tfile) {
      let leaf = this.plugin.chain.get_last_activate_leaf();
      if (leaf) {
        tfile = leaf.view.file;
      }
    }
    if (!tfile) {
      return "No File.";
    }
    let node = new NoteNode(tfile);
    let nc = this.plugin;
    let msg = "```mermaid\nflowchart TD\n";
    let chain = nc.chain.get_chain(tfile, N, N);
    msg = msg + this.subgraph_chain(node, chain, "\u7B14\u8BB0\u94FE");
    let inlinks = nc.chain.get_inlinks(tfile, true).filter((x) => !chain.contains(x));
    let outlinks = nc.chain.get_outlinks(tfile, true).filter((x) => !chain.contains(x));
    msg = msg + this.subgraph_links(node, inlinks, "\u5165\u94FE", "-->", true);
    msg = msg + this.subgraph_links(node, outlinks, "\u51FA\u94FE", "-->");
    msg = msg + node.notes2class();
    msg = msg + [
      "classDef \u7B14\u8BB0\u94FEC fill:" + c_chain,
      "classDef \u5165\u94FEC fill:" + c_inlink,
      "classDef \u51FA\u94FEC fill:" + c_outlink,
      `classDef Anchor fill:${c_anchor},stoke:${c_anchor}`,
      "class \u7B14\u8BB0\u94FE \u7B14\u8BB0\u94FEC",
      "class \u5165\u94FE \u5165\u94FEC",
      "class \u51FA\u94FE \u51FA\u94FEC",
      ""
    ].join("\n");
    msg = msg + "```";
    msg = msg.replace(
      `class ${node.get_id(tfile)} internal-link;`,
      `class ${node.get_id(tfile)} Anchor;`
    );
    return msg;
  }
  flowchart_folder(tfile, subgraph = "Folder", color = "#F05454", c_anchor = "#40A578") {
    if (!tfile) {
      let leaf = this.plugin.chain.get_last_activate_leaf();
      if (leaf) {
        tfile = leaf.view.file;
      }
    }
    if (!tfile) {
      return "No File.";
    }
    let tfiles = this.plugin.chain.get_brothers(tfile);
    return this.flowchart_cross(tfile, tfiles, subgraph, color, c_anchor);
  }
  flowchart_notechain(tfile, N = 10, subgraph = "NoteChain", color = "#F05454", c_anchor = "#40A578") {
    if (!tfile) {
      let leaf = this.plugin.chain.get_last_activate_leaf();
      if (leaf) {
        tfile = leaf.view.file;
      }
    }
    if (!tfile) {
      return "No File.";
    }
    let tfiles = this.plugin.chain.get_chain(tfile, N, N);
    return this.flowchart_cross(tfile, tfiles, subgraph, color, c_anchor);
  }
  flowchart_cross(anchor, tfiles, subgraph = "", color = "#F05454", c_anchor = "#40A578") {
    let node = new NoteNode(tfiles[0]);
    let msg = "```mermaid\nflowchart TD\n";
    msg = msg + this.subgraph_cross(node, tfiles, subgraph);
    msg = msg + node.notes2class();
    msg = msg + [
      `classDef ${subgraph}C fill:${color}`,
      `classDef Anchor fill:${c_anchor},stoke:${c_anchor}`,
      `class ${subgraph} ${subgraph}C`,
      ""
    ].join("\n");
    msg = msg + "```";
    msg = msg.replace(
      `class ${node.get_id(anchor)} internal-link;`,
      `class ${node.get_id(anchor)} Anchor;`
    );
    return msg;
  }
  get_subgrah_names(group_name, tfiles, name = "group") {
    let nc = this.plugin;
    let items = {};
    for (let cfile of tfiles) {
      let cgroup = nc.editor.get_frontmatter(cfile, name);
      if (cgroup) {
        for (let cg of cgroup) {
          let tmp = cg.split("/");
          if (tmp[0] == group_name) {
            if (tmp.length == 1) {
              items[tfiles.indexOf(cfile)] = "";
            } else {
              items[tfiles.indexOf(cfile)] = tmp[1];
            }
            break;
          }
        }
      }
    }
    return items;
  }
  flowchart_groups(anchor, name = "group") {
    let nc = this.plugin;
    let tfiles = nc.chain.get_brothers(anchor);
    tfiles = nc.chain.get_group_links(tfiles, 1);
    let node = nc.mermaid.get_note_node(anchor);
    let group = nc.editor.get_frontmatter(anchor, name);
    if (!group) {
      return [];
    }
    let res = [];
    for (let g of group) {
      g = g.split("/")[0];
      let items = this.get_subgrah_names(g, tfiles, name);
      let subs = new Set(Object.values(items));
      let msg = `\`\`\`mermaid
---
title: ${g}
---
flowchart TD
`;
      for (let sub of subs) {
        if (sub == "") {
          for (let idx in items) {
            if (items[idx] == sub) {
              msg = msg + "\n" + node.get_node(tfiles[idx]);
            }
          }
        } else {
          msg = msg + "\nsubgraph " + sub + "\n";
          for (let idx in items) {
            if (items[idx] == sub) {
              msg = msg + "\n	" + node.get_node(tfiles[idx]);
            }
          }
          msg = msg + "\nend";
        }
      }
      msg = msg + "\n" + this.subgraph_cross(node, Object.keys(items).map((x) => tfiles[x]));
      msg = msg + "\n" + node.notes2class();
      msg = msg + "\n```";
      res.push(msg);
    }
    return res;
  }
  get_relationship_graph(tfile, N = 1, key = "link", show_all_node = true) {
    let nc = this.plugin;
    let node = new NoteNode(tfile);
    let msg = "```mermaid\nflowchart TD\n";
    let tfiles = nc.chain.get_group_links([tfile], N);
    if (show_all_node) {
      for (let tfile2 of tfiles) {
        msg += `${node.get_node(tfile2)}
`;
      }
    }
    let processedFiles = /* @__PURE__ */ new Set();
    for (let currentFile of tfiles) {
      if (processedFiles.has(currentFile))
        continue;
      processedFiles.add(currentFile);
      let links = nc.editor.get_frontmatter(currentFile, key);
      if (links) {
        for (let [relation, linkedNote] of Object.entries(links)) {
          if (linkedNote instanceof Array) {
            for (let item of linkedNote) {
              let linkedTFile = nc.chain.get_tfile(item);
              if (linkedTFile instanceof import_obsidian5.TFile) {
                msg += `	${node.get_node(currentFile)} -->|${relation}| ${node.get_node(linkedTFile)}
`;
              }
            }
          } else {
            let linkedTFile = nc.chain.get_tfile(linkedNote);
            if (linkedTFile instanceof import_obsidian5.TFile) {
              msg += `	${node.get_node(currentFile)} -->|${relation}| ${node.get_node(linkedTFile)}
`;
            }
          }
        }
      }
    }
    msg = msg + node.notes2class();
    msg += "```";
    let c_anchor = "#40A578";
    msg = msg.replace(
      `class ${node.get_id(tfile)} internal-link;`,
      `classDef Anchor fill:${c_anchor},stoke:${c_anchor}
class ${node.get_id(tfile)} Anchor;`
    );
    return msg;
  }
  get_mehrmaid_graph(tfile, N = 1, key = "mermaid", c_anchor = "#d4c4b7") {
    if (!tfile) {
      let leaf = this.plugin.chain.get_last_activate_leaf();
      if (leaf) {
        tfile = leaf.view.file;
      }
    }
    if (!tfile) {
      return "No File.";
    }
    let nc = this.plugin;
    let node = new NoteNode(tfile);
    let msg = "```mehrmaid\nflowchart TD\n";
    let tfiles = nc.chain.get_group_links([tfile], N);
    for (let currentFile of tfiles) {
      let src2 = `[[${currentFile.basename}]]`;
      let links = nc.editor.get_frontmatter(currentFile, key);
      if (links) {
        for (let link of links) {
          if (link["edge"] != null && link["node"] != null) {
            let cedge = link["edge"];
            let cnode = link["node"];
            if (cedge == "") {
              cedge = "";
            } else {
              cedge = `|"${cedge}"|`;
            }
            let line = "-->";
            if (link["line"]) {
              line = link["line"];
            }
            if (cnode instanceof Array) {
              for (let item of cnode) {
                msg += `${node.get_mehrmaid_node(src2)} ${line} ${cedge} ${node.get_mehrmaid_node(item)}
`;
              }
            } else {
              msg += `${node.get_mehrmaid_node(src2)} ${line} ${cedge} ${node.get_mehrmaid_node(cnode)}
`;
            }
          } else if (link["group"]) {
            msg += `subgraph ${link["group"]}
	${node.get_mehrmaid_node(src2)}
end
`;
            if (link["color"]) {
              msg += `classDef ${link["group"]}Class fill:${link["color"]}
`;
              msg += `class ${link["group"]} ${link["group"]}Class
`;
            }
          }
        }
      }
    }
    let src = `[[${tfile.basename}]]`;
    msg += `${node.get_mehrmaid_node(src)}
`;
    if (c_anchor) {
      msg += `classDef Anchor fill:${c_anchor},stoke:${c_anchor}
class ${node.get_mehrmaid_node(src)} Anchor;
`;
    }
    msg += "```";
    return msg;
  }
};

// src/setting.ts
var import_obsidian6 = require("obsidian");
var DEFAULT_SETTINGS = {
  PrevChain: "10",
  NextChain: "10",
  auto_notechain: false,
  refreshDataView: true,
  refreshTasks: true,
  isSortFileExplorer: true,
  isFolderFirst: true,
  suggesterNotesMode: "",
  wordcout: true,
  wordcountxfolder: "",
  modal_default_width: 800,
  modal_default_height: 600
};
var NCSettingTab = class extends import_obsidian6.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian6.Setting(containerEl).setName(this.plugin.strings.setting_isSortFileExplorer).addToggle(
      (text) => text.setValue(this.plugin.settings.isSortFileExplorer).onChange(async (value) => {
        this.plugin.settings.isSortFileExplorer = value;
        await this.plugin.saveSettings();
        this.plugin.explorer.sort();
      })
    );
    new import_obsidian6.Setting(containerEl).setName(this.plugin.strings.setting_isFolderFirst).addToggle(
      (text) => text.setValue(this.plugin.settings.isFolderFirst).onChange(async (value) => {
        this.plugin.settings.isFolderFirst = value;
        await this.plugin.saveSettings();
        this.plugin.explorer.sort();
      })
    );
    new import_obsidian6.Setting(containerEl).setName(this.plugin.strings.setting_PrevChain).addText((text) => text.setValue(this.plugin.settings.PrevChain).onChange(async (value) => {
      this.plugin.settings.PrevChain = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName(this.plugin.strings.setting_suggesterNotesMode).addDropdown((dropdown) => dropdown.addOption("item_get_brothers", this.plugin.strings.item_get_brothers).addOption("item_uncle_notes", this.plugin.strings.item_uncle_notes).addOption("item_notechain", this.plugin.strings.item_notechain).addOption("item_same_folder", this.plugin.strings.item_same_folder).addOption("item_inlinks_outlinks", this.plugin.strings.item_inlinks_outlinks).addOption("item_inlins", this.plugin.strings.item_inlins).addOption("item_outlinks", this.plugin.strings.item_outlinks).addOption("item_all_noes", this.plugin.strings.item_all_noes).addOption("item_recent", this.plugin.strings.item_recent).addOption("", "").setValue(this.plugin.settings.suggesterNotesMode).onChange(async (value) => {
      this.plugin.settings.suggesterNotesMode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName(this.plugin.strings.setting_NextChain).addText((text) => text.setValue(this.plugin.settings.NextChain).onChange(async (value) => {
      this.plugin.settings.NextChain = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName(this.plugin.strings.setting_auto_notechain).addToggle(
      (text) => text.setValue(this.plugin.settings.auto_notechain).onChange(async (value) => {
        this.plugin.settings.auto_notechain = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName(this.plugin.strings.setting_refreshDataView).addToggle(
      (text) => text.setValue(this.plugin.settings.refreshDataView).onChange(async (value) => {
        this.plugin.settings.refreshDataView = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName(this.plugin.strings.setting_refreshTasks).addToggle(
      (text) => text.setValue(this.plugin.settings.refreshTasks).onChange(async (value) => {
        this.plugin.settings.refreshTasks = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName(this.plugin.strings.setting_wordcout).addToggle(
      (text) => text.setValue(this.plugin.settings.wordcout).onChange(async (value) => {
        this.plugin.settings.wordcout = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName(this.plugin.strings.setting_wordcout_xfolder).addTextArea(
      (text) => text.setValue(this.plugin.settings.wordcountxfolder).onChange(async (value) => {
        this.plugin.settings.wordcountxfolder = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/commands.ts
var import_obsidian7 = require("obsidian");
var cmd_longform2notechain = (plugin) => ({
  id: "longform2notechain",
  name: plugin.strings.cmd_longform2notechain,
  callback: async () => {
    let curr = plugin.chain.current_note;
    if (curr == null) {
      return;
    }
    plugin.app.fileManager.processFrontMatter(
      curr,
      async (fm) => {
        if (curr == null) {
          return;
        }
        if (fm["longform"] == null) {
          return;
        }
        let scenes = plugin.utils.concat_array(fm.longform.scenes);
        let ignoredFiles = plugin.utils.concat_array(fm.longform.ignoredFiles);
        ignoredFiles = ignoredFiles.filter((f) => !scenes.contains(f));
        let notes = plugin.utils.concat_array([scenes, ignoredFiles]);
        notes = notes.map((f) => plugin.chain.tp_find_tfile(f));
        if (curr.parent == null) {
          return;
        }
        ;
        let tfiles = plugin.chain.get_tfiles_of_folder(curr.parent).filter((f) => !notes.contains(f));
        notes = plugin.utils.concat_array([tfiles, notes]);
        await plugin.chain.chain_concat_tfiles(notes);
        plugin.explorer.sort();
      }
    );
  }
});
var cmd_longform4notechain = (plugin) => ({
  id: "longform4notechain",
  name: plugin.strings.cmd_longform4notechain,
  callback: async () => {
    let nc = plugin;
    let curr = plugin.chain.current_note;
    if (curr == null || curr.parent == null) {
      return;
    }
    let path = curr.parent.path + "/" + curr.parent.name + ".md";
    let dst = await nc.chain.get_tfile(path);
    if (dst == null) {
      let ufunc = nc.utils.get_tp_func(nc.app, "tp.file.create_new");
      dst = await ufunc(
        "",
        curr.parent.name,
        false,
        curr.parent
      );
    }
    await nc.app.fileManager.processFrontMatter(
      dst,
      (fm) => {
        if (fm["longform"] == null) {
          fm["longform"] = {
            "format": "scenes",
            "title": dst.parent.name,
            "workflow": "Default Workflow",
            "sceneFolder": "/",
            "scenes": [],
            "ignoredFiles": []
          };
        }
      }
    );
    await plugin.app.fileManager.processFrontMatter(
      dst,
      (fm) => {
        if (dst == null) {
          return;
        }
        if (dst.parent == null) {
          return;
        }
        ;
        if (fm["longform"] == null) {
          return;
        }
        let notes = plugin.chain.get_tfiles_of_folder(dst.parent);
        notes = plugin.chain.sort_tfiles_by_chain(notes);
        fm.longform.scenes = notes.map((f) => f.basename);
      }
    );
    await nc.chain.open_note(dst);
  }
});
var cmd_sort_file_explorer = (plugin) => ({
  id: "sort_file_explorer",
  name: plugin.strings.cmd_sort_file_explorer,
  callback: async () => {
    await plugin.explorer.sort(0, true);
  }
});
var cmd_open_notes_smarter = (plugin) => ({
  id: "open_notes_smarter",
  name: plugin.strings.cmd_open_notes_smarter,
  callback: () => {
    plugin.open_note_smarter();
  }
});
var cmd_open_note = (plugin) => ({
  id: "suggestor_open_note",
  name: plugin.strings.cmd_open_note,
  callback: () => {
    plugin.chain.sugguster_open_note();
  }
});
var cmd_open_prev_note = (plugin) => ({
  id: "open_prev_notes",
  name: plugin.strings.cmd_open_prev_note,
  callback: () => {
    plugin.chain.open_prev_notes();
  }
});
var cmd_open_next_note = (plugin) => ({
  id: "open_next_notes",
  name: plugin.strings.cmd_open_next_note,
  callback: () => {
    plugin.chain.open_next_notes();
  }
});
var clear_inlinks = (plugin) => ({
  id: "clear_inlinks",
  name: plugin.strings.clear_inlinks,
  callback: () => {
    plugin.clear_inlinks();
  }
});
var move_file_to_another_folder = (plugin) => ({
  id: "move_file_to_another_folder",
  name: plugin.strings.move_file_to_another_folder,
  callback: () => {
    plugin.chain.cmd_move_file_to_another_folder();
  }
});
var replace_notes_with_regx = (plugin) => ({
  id: "replace_notes_with_regx",
  name: plugin.strings.replace_notes_with_regx,
  callback: () => {
    plugin.replace_notes_with_regx();
  }
});
var chain_insert_node = (plugin) => ({
  id: "chain_insert_node",
  name: plugin.strings.chain_insert_node,
  callback: async () => {
    await plugin.cmd_chain_insert_node();
    await plugin.explorer.sort(500);
  }
});
var chain_set_seq_note = (plugin) => ({
  id: "chain_set_seq_note",
  name: plugin.strings.chain_set_seq_note,
  callback: async () => {
    await plugin.chain.chain_suggester_tfiles();
    plugin.explorer.sort();
  }
});
var chain_move_up_node = (plugin) => ({
  id: "chain_move_up_node",
  name: plugin.strings.chain_move_up_node,
  callback: async () => {
    let tfile = plugin.chain.current_note;
    if (tfile) {
      let anchor = plugin.chain.get_prev_note(tfile);
      if (anchor) {
        await plugin.chain.chain_insert_node_before(
          tfile,
          anchor
        );
        await plugin.explorer.sort();
      }
    }
  }
});
var chain_move_down_node = (plugin) => ({
  id: "chain_move_donw_node",
  name: plugin.strings.chain_move_down_node,
  callback: async () => {
    let tfile = plugin.chain.current_note;
    if (tfile) {
      let anchor = plugin.chain.get_next_note(tfile);
      if (anchor) {
        await plugin.chain.chain_insert_node_after(
          tfile,
          anchor
        );
        await plugin.explorer.sort();
      }
    }
  }
});
var create_new_note = (plugin) => ({
  id: "create_new_note",
  name: plugin.strings.create_new_note,
  callback: async () => {
    let targets = {};
    targets[plugin.strings.item_chain_insert_node_after] = "chain_insert_node_after";
    targets[plugin.strings.item_chain_insert_node_as_tail] = "chain_insert_node_as_tail";
    targets[plugin.strings.item_chain_insert_node_before] = "chain_insert_node_before";
    targets[plugin.strings.item_chain_insert_node_as_head] = "chain_insert_node_as_head";
    targets[plugin.strings.item_item_chain_insert_null] = "null";
    let target = await plugin.chain.tp_suggester(
      plugin.utils.array_prefix_id(Object.keys(targets)),
      Object.values(targets),
      true
    );
    if (!target) {
      return;
    }
    let name = await plugin.chain.tp_prompt(plugin.strings.prompt_notename);
    if (name) {
      let curr = plugin.chain.current_note;
      if (curr && curr.parent) {
        let path = curr.parent.path + "/" + name + ".md";
        let dst = await plugin.chain.get_tfile(path);
        if (dst == null) {
          let func = plugin.utils.get_tp_func(plugin.app, "tp.file.create_new");
          dst = await func(
            "",
            name,
            false,
            curr.parent
          );
          await sleep(300);
          if (!(target === "null")) {
            await plugin.chain[target](dst, curr);
          }
          await sleep(300);
          await plugin.chain.open_note(dst);
          await plugin.explorer.sort();
        }
      }
    }
  }
});
var cmd_reveal_note = (plugin) => ({
  id: "cmd_reveal_note",
  name: plugin.strings.cmd_reveal_note,
  callback: async () => {
    let nc = plugin;
    let note = nc.chain.current_note;
    if (note) {
      await nc.explorer.file_explorer.tree.setCollapseAll(true);
      await nc.explorer.file_explorer.revealInFolder(note);
      await sleep(100);
      let containerEl = nc.explorer.file_explorer.containerEl;
      let panel = containerEl.querySelector(".nav-files-container");
      let itemEl = containerEl.querySelector(`[data-path="${note.path}"]`);
      if (panel && itemEl && itemEl.offsetTop) {
        let xtop = panel.scrollTop + (itemEl.offsetTop - (panel.scrollTop + panel.clientHeight / 2));
        panel.scrollTo({ top: xtop, behavior: "smooth" });
      }
    }
  }
});
var cmd_open_and_reveal_note = (plugin) => ({
  id: "cmd_open_and_reveal_note",
  name: plugin.strings.cmd_open_and_reveal_note,
  callback: async () => {
    let nc = plugin;
    let note = await nc.chain.sugguster_note();
    if (note) {
      await nc.chain.open_note(note);
      await nc.explorer.file_explorer.tree.setCollapseAll(true);
      await nc.explorer.file_explorer.revealInFolder(note);
      await sleep(100);
      let containerEl = nc.explorer.file_explorer.containerEl;
      let panel = containerEl.querySelector(".nav-files-container");
      let itemEl = containerEl.querySelector(`[data-path="${note.path}"]`);
      if (panel && itemEl && itemEl.offsetTop) {
        let xtop = panel.scrollTop + (itemEl.offsetTop - (panel.scrollTop + panel.clientHeight / 2));
        panel.scrollTo({ top: xtop, behavior: "smooth" });
      }
    }
  }
});
var cmd_open_prev_note_of_right_leaf = (plugin) => ({
  id: "cmd_open_prev_note_of_right_leaf",
  name: plugin.strings.cmd_open_prev_note_of_right_leaf,
  callback: async () => {
    let nc = plugin;
    let leaf = nc.chain.get_last_activate_leaf();
    if (leaf) {
      let prev = nc.chain.get_prev_note(leaf.view.file);
      if (prev) {
        await leaf.openFile(prev, { active: false });
        await nc.app.workspace.trigger("file-open", leaf);
      }
    }
  }
});
var cmd_open_next_note_of_right_leaf = (plugin) => ({
  id: "cmd_open_next_note_of_right_leaf",
  name: plugin.strings.cmd_open_next_note_of_right_leaf,
  callback: async () => {
    let nc = plugin;
    let leaf = nc.chain.get_last_activate_leaf();
    if (leaf) {
      let next = nc.chain.get_next_note(leaf.view.file);
      if (next) {
        await leaf.openFile(next, { active: false });
        await nc.app.workspace.trigger("file-open", leaf);
      }
    }
  }
});
var cmd_file_open_with_system_app = (plugin) => ({
  id: "cmd_file_open_with_system_app",
  name: plugin.strings.cmd_file_open_with_system_app,
  callback: async () => {
    let nc = plugin;
    if (nc.app.isMobile) {
      return;
    }
    let tfile = nc.chain.current_note;
    if (tfile) {
      let items = await nc.chain.get_file_links(tfile);
      let keys = Object.keys(items);
      let key = await nc.chain.tp_suggester(
        nc.utils.array_prefix_id(keys),
        keys
      );
      if (key) {
        let item = items[key];
        let electron = require("electron");
        electron.remote.shell.openPath(item);
      }
    }
  }
});
var cmd_file_show_in_system_explorer = (plugin) => ({
  id: "cmd_file_show_in_system_explorer",
  name: plugin.strings.cmd_file_show_in_system_explorer,
  callback: async () => {
    let nc = plugin;
    if (nc.app.isMobile) {
      return;
    }
    let tfile = nc.chain.current_note;
    if (tfile) {
      let items = await nc.chain.get_file_links(tfile);
      let keys = Object.keys(items);
      let key = await nc.chain.tp_suggester(
        nc.utils.array_prefix_id(keys),
        keys
      );
      if (key) {
        let item = items[key];
        let electron = require("electron");
        electron.remote.shell.showItemInFolder(item);
      }
    }
  }
});
var cmd_file_rename = (plugin) => ({
  id: "cmd_file_rename",
  name: plugin.strings.cmd_file_rename,
  callback: async () => {
    let nc = plugin;
    if (nc.app.isMobile) {
      return;
    }
    let tfile = nc.chain.current_note;
    if (tfile) {
      let items = {};
      let links = nc.chain.get_inlinks();
      for (let i of links) {
        if (i.extension === "md") {
          items["\u2139\uFE0F " + i.basename] = i;
        } else {
          items["\u2139\uFE0F " + i.name] = i;
        }
      }
      links = nc.chain.get_outlinks();
      for (let i of links) {
        if (i.extension === "md") {
          items["\u{1F17E}\uFE0F " + i.basename] = i;
        } else {
          items["\u{1F17E}\uFE0F " + i.name] = i;
        }
      }
      let keys = Object.keys(items);
      let key = await nc.chain.tp_suggester(
        nc.utils.array_prefix_id(keys),
        keys
      );
      if (key) {
        let note = items[key];
        let res = await nc.chain.tp_prompt("New Name", note.basename);
        if (res && !(res === note.basename) && !(res === "")) {
          let npath = note.parent.path + "/" + res + "." + note.extension;
          let dst = nc.chain.get_tfile(res + "." + note.extension);
          if (dst) {
            new import_obsidian7.Notice("Exist:" + res + note.extension, 3e3);
          } else {
            nc.app.fileManager.renameFile(note, npath);
          }
        }
      }
    }
  }
});
var cmd_mermaid_flowchart_link = (plugin) => ({
  id: "cmd_mermaid_flowchart_link",
  name: plugin.strings.cmd_mermaid_flowchart_link,
  callback: async () => {
    const content = "```dataviewjs\nlet nc=app.plugins.getPlugin('note-chain');\nlet msg =nc.mermaid.get_flowchart(null,2);\ndv.span(msg)\n```";
    await plugin.chain.open_note_in_modal(content);
  }
});
var cmd_mermaid_flowchart_folder = (plugin) => ({
  id: "cmd_mermaid_flowchart_folder",
  name: plugin.strings.cmd_mermaid_flowchart_folder,
  callback: async () => {
    const content = "```dataviewjs\nlet nc=app.plugins.getPlugin('note-chain');\nlet msg =nc.mermaid.flowchart_folder(null,'Folder');\ndv.span(msg)\n```";
    await plugin.chain.open_note_in_modal(content);
  }
});
var cmd_mermaid_flowchart_auto = (plugin) => ({
  id: "cmd_mermaid_flowchart_auto",
  name: plugin.strings.cmd_mermaid_flowchart_auto,
  callback: async () => {
    const content = "```dataviewjs\nlet nc=app.plugins.getPlugin('note-chain');\nlet msg =nc.mermaid.get_mehrmaid_graph(null,4,'mermaid');\ndv.span(msg)\n```";
    await plugin.chain.open_note_in_modal(content);
  }
});
var commandBuilders = [
  cmd_open_note,
  cmd_reveal_note,
  cmd_open_and_reveal_note,
  cmd_open_prev_note,
  cmd_open_next_note,
  cmd_open_prev_note_of_right_leaf,
  cmd_open_next_note_of_right_leaf,
  cmd_open_notes_smarter,
  cmd_longform2notechain,
  cmd_longform4notechain,
  cmd_sort_file_explorer,
  clear_inlinks,
  replace_notes_with_regx,
  move_file_to_another_folder,
  chain_insert_node,
  chain_set_seq_note,
  create_new_note,
  chain_move_up_node,
  chain_move_down_node,
  cmd_file_rename,
  cmd_mermaid_flowchart_link,
  cmd_mermaid_flowchart_folder,
  cmd_mermaid_flowchart_auto
];
var commandBuildersDesktop = [
  cmd_file_open_with_system_app,
  cmd_file_show_in_system_explorer
];
function addCommands(plugin) {
  commandBuilders.forEach((c) => {
    plugin.addCommand(c(plugin));
  });
  if (plugin.app.isMobile == false) {
    commandBuildersDesktop.forEach((c) => {
      plugin.addCommand(c(plugin));
    });
  }
}

// main.ts
var NoteChainPlugin = class extends import_obsidian8.Plugin {
  async onload() {
    this.debug = true;
    await this.loadSettings();
    this.utils = (init_utils(), __toCommonJS(utils_exports));
    this.ob = require("obsidian");
    this.editor = new NCEditor(this.app);
    this.chain = new NoteChain(this, this.editor);
    this.explorer = new NCFileExplorer(this);
    this.mermaid = new MermaidGraph(this);
    this.strings = new Strings();
    addCommands(this);
    this.addSettingTab(new NCSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("file-open", this.ufunc_on_file_open.bind(this))
    );
    this.registerEvent(this.app.vault.on(
      "delete",
      async (file) => {
        await this.chain.chain_pop_node(file);
        await this.explorer.sort();
      }
    ));
    this.registerEvent(this.app.vault.on(
      "create",
      async () => {
        await sleep(500);
        this.explorer.sort(0, true);
      }
    ));
    this.registerEvent(this.app.vault.on(
      "rename",
      async (file, oldPath) => {
        let oldFolder = this.app.vault.getFolderByPath(
          oldPath.slice(0, oldPath.lastIndexOf("/"))
        );
        oldFolder && this.chain.refresh_folder(oldFolder);
        this.chain.refresh_tfile(file);
        this.explorer.sort();
      }
    ));
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (file instanceof import_obsidian8.TFile) {
          menu.addItem((item) => {
            item.setTitle(this.strings.filemenu_create_next_note).setIcon("file-plus").onClick(async () => {
              let filename = await this.chain.tp_prompt("File name");
              let dst = file.parent ? file.parent.path + "/" + filename + ".md" : filename + ".md";
              if (this.chain.get_tfile(dst)) {
                new import_obsidian8.Notice("Exists:" + file.path, 3e3);
              } else {
                let tfile = await this.app.vault.create(dst, "");
                await this.chain.chain_insert_node_after(tfile, file);
                await this.chain.open_note(tfile, false, false);
              }
            });
          });
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (file instanceof import_obsidian8.TFile && file.extension == "md") {
          menu.addItem((item) => {
            item.setTitle(this.strings.filemenu_move_as_next_note).setIcon("hand").onClick(async () => {
              let anchor = await this.chain.sugguster_note();
              if (anchor) {
                await this.chain.chain_insert_node_after(file, anchor);
                if (file.parent != anchor.parent) {
                  let dst = anchor.parent.path + "/" + file.name;
                  await this.app.fileManager.renameFile(file, dst);
                }
                this.explorer.sort();
              }
            });
          });
        } else if (file instanceof import_obsidian8.TFolder) {
          menu.addItem((item) => {
            item.setTitle(this.strings.filemenu_move_as_next_note).setIcon("hand").onClick(async () => {
              var _a;
              let notes = (_a = file.parent) == null ? void 0 : _a.children;
              if (notes) {
                let anchor = await this.chain.tp_suggester(
                  (f) => f.name,
                  notes.filter((x) => x instanceof import_obsidian8.TFile)
                );
                let note = this.chain.get_tfile(file.path + "/" + file.name + ".md");
                if (!note) {
                  note = await this.app.vault.create(
                    file.path + "/" + file.name + ".md",
                    ""
                  );
                }
                await this.editor.set_multi_frontmatter(
                  note,
                  {
                    "FolderPrevNote": `[[${anchor.basename}]]`,
                    "FolderPrevNoteOffset": 0.5
                  }
                );
                this.chain.refresh_tfile(file);
                await this.explorer.sort(0, false);
              }
            });
          });
        }
      })
    );
    this.registerEvent(
      this.app.metadataCache.on(
        "changed",
        (file, data, cache) => {
          clearTimeout(this.timerId);
          this.timerId = setTimeout(() => {
            if (file.parent) {
              this.chain.children[file.parent.path] = this.chain.sort_tfiles_by_chain(
                file.parent.children
              );
            }
            this.explorer.sort(0, false);
          }, 500);
        }
      )
    );
    this.wordcout = new WordCount(this, this.app);
  }
  onunload() {
    this.explorer.unregister();
    this.explorer.sort();
  }
  async ufunc_on_file_open(file) {
    var _a;
    if (this.settings.refreshDataView) {
      this.app.commands.executeCommandById(
        "dataview:dataview-force-refresh-views"
      );
    }
    if (this.settings.refreshTasks) {
      let target = await this.app.plugins.getPlugin("obsidian-tasks-plugin");
      target && target.cache.notifySubscribers();
    }
    if (this.settings.auto_notechain) {
      let notes = this.chain.get_brothers(file);
      if (notes.length == 0) {
        return;
      }
      let xfolders = this.settings.wordcountxfolder.split("\n").filter((x) => x != "");
      for (let item of xfolders) {
        if (file.path.startsWith(item)) {
          return false;
        }
      }
      if ((_a = this.explorer) == null ? void 0 : _a.file_explorer) {
        notes = this.chain.sort_tfiles(notes, this.explorer.file_explorer.sortOrder);
        notes = this.chain.sort_tfiles(notes, "chain");
        await this.chain.chain_concat_tfiles(notes);
        this.explorer.sort();
      }
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async clear_inlinks(tfile = this.chain.current_note, mode = "suggester") {
    if (tfile == null) {
      return;
    }
    let notes = this.chain.get_inlinks(tfile);
    if (notes.length) {
      if (mode === "suggester") {
        mode = await this.chain.tp_suggester(
          ["delete links", "replace links", "delete paragraph with links"],
          [["link", "del"], ["link", "rep"], ["para", "del"]]
        );
      }
      let reg = this.editor.regexp_link(tfile, mode[0]);
      if (reg) {
        for (let note of notes) {
          let target;
          if (mode[1] === "rep") {
            target = tfile.basename;
          } else {
            target = "";
          }
          this.editor.replace(note, reg, target);
        }
      }
    }
  }
  async replace_notes_with_regx() {
    let notes = await this.chain.suggester_notes();
    if ((notes == null ? void 0 : notes.length) > 0) {
      try {
        let regs = await this.chain.tp_prompt("Enter the regular expression to replace.");
        if (regs == null) {
          return;
        }
        let reg = new RegExp(regs, "g");
        let target = await this.chain.tp_prompt("Enter the target string.");
        if (target == null) {
          return;
        }
        target = target.trim().replace(
          /\\n/g,
          "\n"
        );
        for (let note of notes) {
          await this.editor.replace(note, reg, target);
        }
      } catch (error) {
      }
    }
  }
  async cmd_chain_insert_node() {
    let curr = this.chain.current_note;
    if (curr == null) {
      return;
    }
    let smode = this.strings[this.settings.suggesterNotesMode];
    let notes = await this.chain.suggester_notes(curr, false, smode);
    if (!notes) {
      return;
    }
    notes = this.chain.sort_tfiles(notes, ["mtime", "x"]);
    notes = this.chain.sort_tfiles_by_chain(notes);
    const note = await this.chain.tp_suggester(
      this.utils.array_prefix_id(
        notes.map((file) => this.tfile_to_string(file, [], ""))
      ),
      notes
    );
    if (!note) {
      return;
    }
    let sitems = [
      this.strings.item_insert_node_after,
      this.strings.item_insert_node_before,
      this.strings.item_insert_node_as_head,
      this.strings.item_insert_node_as_tail,
      this.strings.item_insert_folder_after
    ];
    let mode = await this.chain.tp_suggester(
      this.utils.array_prefix_id(sitems),
      sitems,
      false,
      this.strings.item_insert_suggester
    );
    if (!mode) {
      return;
    }
    if (mode === this.strings.item_insert_node_as_head) {
      await this.chain.chain_insert_node_as_head(curr, note);
    } else if (mode === this.strings.item_insert_node_as_tail) {
      await this.chain.chain_insert_node_as_tail(curr, note);
    } else if (mode === this.strings.item_insert_node_before) {
      await this.chain.chain_insert_node_before(curr, note);
    } else if (mode === this.strings.item_insert_node_after) {
      await this.chain.chain_insert_node_after(curr, note);
    } else if (mode === this.strings.item_insert_folder_after) {
      await this.chain.chain_insert_folder_after(curr, note);
    } else {
      return;
    }
  }
  tfile_to_string(tfile, fields, seq) {
    let items = new Array();
    if (tfile == this.chain.current_note) {
      items.push("\u{1F3E0}" + tfile.basename);
    } else {
      items.push(tfile.basename);
    }
    for (let field of fields) {
      try {
        items.push(this.editor.get_frontmatter(tfile, field));
      } catch (error) {
        items.push("-");
      }
    }
    return items.join(seq);
  }
  async open_note_smarter() {
    let curr = this.chain.current_note;
    let notes = await this.chain.suggester_notes(curr, false);
    notes = this.chain.sort_tfiles(notes, ["mtime", "x"]);
    notes = this.chain.sort_tfiles_by_chain(notes);
    if (notes.length > 0) {
      let note = await this.chain.tp_suggester(
        this.utils.array_prefix_id(
          notes.map((file) => this.chain.tfile_to_string(file))
        ),
        notes
      );
      if (note) {
        await this.chain.open_note(note);
      }
    }
  }
};
