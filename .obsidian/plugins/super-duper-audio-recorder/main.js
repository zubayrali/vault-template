/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// settings-tab.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  recordingFormat: "webm",
  saveFolder: "",
  filePrefix: "recording",
  startStopHotkey: "",
  pauseHotkey: "",
  resumeHotkey: "",
  audioDeviceId: "",
  sampleRate: 44100,
  bitrate: 128e3,
  enableMultiTrack: false,
  maxTracks: 2,
  outputMode: "single",
  useSourceNamesForTracks: true,
  trackAudioSources: {},
  debug: false
};
var AudioRecorderSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async getAudioInputDevices() {
    const devices = await navigator.mediaDevices.enumerateDevices();
    return devices.filter((device) => device.kind === "audioinput");
  }
  async getSupportedFormats() {
    const formats = ["ogg", "webm", "mp3", "m4a", "mp4", "wav"];
    const supportedFormats = formats.filter((format) => MediaRecorder.isTypeSupported(`audio/${format}`));
    return supportedFormats;
  }
  getFolderOptions() {
    const folders = [];
    import_obsidian.Vault.recurseChildren(this.app.vault.getRoot(), (file) => {
      if (file instanceof import_obsidian.TFolder) {
        folders.push(file.path);
      }
    });
    return folders;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Audio recorder plus").setDesc("Configure the settings for the Audio Recorder Plus plugin.").setHeading();
    const supportedFormats = await this.getSupportedFormats();
    new import_obsidian.Setting(containerEl).setName("Recording format").setDesc("Select the audio recording format.").addDropdown((dropdown) => {
      supportedFormats.forEach((format) => {
        dropdown.addOption(format, format);
      });
      dropdown.setValue(this.plugin.settings.recordingFormat);
      dropdown.onChange(async (value) => {
        this.plugin.settings.recordingFormat = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Sample rate").setDesc("Select the audio sample rate.").addDropdown((dropdown) => {
      const sampleRates = [8e3, 16e3, 22050, 44100, 48e3];
      sampleRates.forEach((rate) => {
        dropdown.addOption(rate.toString(), rate.toString());
      });
      dropdown.setValue(this.plugin.settings.sampleRate.toString());
      dropdown.onChange(async (value) => {
        this.plugin.settings.sampleRate = parseInt(value);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Save folder").setDesc("Specify the folder to save recordings. Auto-complete enabled.").addText((text) => {
      const folderOptions = this.getFolderOptions();
      text.inputEl.setAttribute("list", "folder-options");
      const datalist = document.createElement("datalist");
      datalist.id = "folder-options";
      folderOptions.forEach((folder) => {
        const option = document.createElement("option");
        option.value = folder;
        datalist.appendChild(option);
      });
      text.inputEl.appendChild(datalist);
      text.setValue(this.plugin.settings.saveFolder);
      text.onChange(async (value) => {
        this.plugin.settings.saveFolder = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("File naming").setDesc('Use the File prefix setting to customize the naming of your audio files. The final file name will include this prefix followed by a timestamp. For example, if your prefix is "meeting", the file name will look like "meeting-2023-07-21T15-30-00.ogg"').setHeading();
    new import_obsidian.Setting(containerEl).setName("File prefix").setDesc("Set a prefix for the audio file names.").addText((text) => text.setPlaceholder("Enter file prefix").setValue(this.plugin.settings.filePrefix).onChange(async (value) => {
      this.plugin.settings.filePrefix = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Debug mode").setDesc("Enable debug logging").addToggle((toggle) => toggle.setValue(this.plugin.settings.debug).onChange(async (value) => {
      this.plugin.settings.debug = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Multi-track recording").setDesc("Configure settings for multi-track recording.").setHeading();
    new import_obsidian.Setting(containerEl).setName("Enable multi-track recording").setDesc("Toggle to activate or deactivate multi-track recording.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableMultiTrack).onChange(async (value) => {
      this.plugin.settings.enableMultiTrack = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.enableMultiTrack) {
      new import_obsidian.Setting(containerEl).setName("Maximum tracks").setDesc("Set the number of simultaneous tracks (1-8).").addSlider((slider) => slider.setLimits(1, 8, 1).setValue(this.plugin.settings.maxTracks).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.maxTracks = value;
        await this.plugin.saveSettings();
        this.display();
      }));
      new import_obsidian.Setting(containerEl).setName("Output mode").setDesc("Choose between single combined file or separate files for each track.").addDropdown((dropdown) => dropdown.addOption("single", "Single File").addOption("multiple", "Multiple Files").setValue(this.plugin.settings.outputMode).onChange(async (value) => {
        this.plugin.settings.outputMode = value;
        await this.plugin.saveSettings();
      }));
      for (let i = 1; i <= this.plugin.settings.maxTracks; i++) {
        new import_obsidian.Setting(containerEl).setName(`Audio Source for Track ${i}`).setDesc(`Select the audio input device for track ${i}`).addDropdown(async (dropdown) => {
          await this.populateAudioDevices(dropdown);
          dropdown.setValue(this.plugin.settings.trackAudioSources[i] || "");
          dropdown.onChange(async (value) => {
            this.plugin.settings.trackAudioSources[i] = value;
            await this.plugin.saveSettings();
          });
        });
      }
    }
    new import_obsidian.Setting(containerEl).setName("Documentation").setDesc(
      "File Prefix: Customize the prefix for your audio files. The final filename includes this prefix and a timestamp.\n\nRecording Format: Choose between OGG, WEBM, MP3, or M4A for your audio recordings.\n\nSave Folder: Specify where recordings will be saved. Autocomplete suggestions are available.\n\nAudio Input Device: Select the microphone for recording.\n\nSample Rate: Set the sample rate for your audio recordings.\n\nHotkeys:\n- Start/Stop: Set a hotkey to quickly start and stop recordings.\n- Pause: Set a hotkey to pause recordings.\n- Resume: Set a hotkey to resume recordings.\n\nBitrate: Adjust to control quality and file size of your recordings.\n\nVisual Indicators: The status bar displays when recording is active.\n\nMulti-track Recording:\n- Enable to record multiple audio sources simultaneously.\n- Maximum Tracks: Set the number of simultaneous tracks (1-8).\n- Output Mode: Choose between a single combined file or separate files for each track.\n- Use Source Names: Option to use audio source names for individual track filenames.\n- Audio Source Selection: Choose specific audio input devices for each track."
    ).setHeading();
  }
  async populateAudioDevices(dropdown) {
    const devices = await this.getAudioInputDevices();
    devices.forEach((device) => {
      dropdown.addOption(device.deviceId, device.label || `Audio Device ${device.deviceId}`);
    });
  }
};

// main.ts
var AudioRecorderPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.recorders = [];
    this.audioChunks = [];
    this.statusBarItem = null;
    this.recordingStatus = 0 /* Idle */;
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new AudioRecorderSettingTab(this.app, this));
    this.registerCommands();
    this.addRibbonIcon("microphone", "Start/Stop Recording", () => this.toggleRecording());
    this.setupStatusBar();
  }
  onunload() {
    this.updateStatusBar();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  registerCommands() {
    this.addCommand({
      id: "start-stop-recording",
      name: "Start/Stop Recording",
      callback: () => this.toggleRecording()
    });
    this.addCommand({
      id: "pause-resume-recording",
      name: "Pause/Resume Recording",
      callback: () => this.togglePauseResume()
    });
    this.addCommand({
      id: "select-audio-input-device",
      name: "Select Audio Input Device",
      callback: () => this.showDeviceSelectionModal()
    });
  }
  setupStatusBar() {
    this.statusBarItem = this.addStatusBarItem();
    this.updateStatusBar();
  }
  debugLog(message) {
    if (this.settings.debug) {
      console.log(`[AudioRecorder Debug] ${message}`);
    }
  }
  updateStatusBar() {
    if (!this.statusBarItem)
      return;
    switch (this.recordingStatus) {
      case 1 /* Recording */:
        this.statusBarItem.setText("Recording \u{1F399}\uFE0F...");
        this.statusBarItem.addClass("is-recording");
        break;
      case 2 /* Paused */:
        this.statusBarItem.setText("Recording paused \u{1F399}\uFE0F");
        this.statusBarItem.addClass("is-recording");
        break;
      case 0 /* Idle */:
      default:
        this.statusBarItem.setText("");
        this.statusBarItem.removeClass("is-recording");
        break;
    }
  }
  async toggleRecording() {
    if (this.recordingStatus === 0 /* Idle */) {
      await this.startRecording();
    } else {
      await this.stopRecording();
    }
  }
  async startRecording() {
    try {
      const mimeType = `audio/${this.settings.recordingFormat};codecs=opus`;
      if (!MediaRecorder.isTypeSupported(mimeType)) {
        throw new Error(`The format ${mimeType} is not supported in this browser.`);
      }
      const streams = await this.getAudioStreams();
      this.recorders = streams.map((stream) => new MediaRecorder(stream, { mimeType }));
      this.audioChunks = this.recorders.map(() => []);
      this.recorders.forEach((recorder, index) => {
        recorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            this.audioChunks[index].push(event.data);
          }
        };
        recorder.start();
      });
      this.recordingStatus = 1 /* Recording */;
      this.updateStatusBar();
      new import_obsidian2.Notice("Recording started");
    } catch (error) {
      new import_obsidian2.Notice(`Error starting recording: ${error.message}`);
      this.debug(`Error in startRecording: ${error}`);
    }
  }
  async stopRecording() {
    try {
      await Promise.all(this.recorders.map((recorder) => {
        return new Promise((resolve) => {
          recorder.addEventListener("stop", () => resolve(), { once: true });
          recorder.stop();
        });
      }));
      this.recordingStatus = 0 /* Idle */;
      this.updateStatusBar();
      new import_obsidian2.Notice("Recording stopped");
      await this.saveRecording();
    } catch (error) {
      new import_obsidian2.Notice(`Error stopping recording: ${error.message}`);
      this.debug(`Error in stopRecording: ${error}`);
    }
  }
  togglePauseResume() {
    if (this.recordingStatus === 1 /* Recording */) {
      this.recorders.forEach((recorder) => recorder.pause());
      this.recordingStatus = 2 /* Paused */;
      new import_obsidian2.Notice("Recording paused");
    } else if (this.recordingStatus === 2 /* Paused */) {
      this.recorders.forEach((recorder) => recorder.resume());
      this.recordingStatus = 1 /* Recording */;
      new import_obsidian2.Notice("Recording resumed");
    } else {
      new import_obsidian2.Notice("No active recording to pause or resume");
    }
    this.updateStatusBar();
  }
  async getAudioStreams() {
    const devices = await this.getAudioInputDevices();
    const streamPromises = this.settings.enableMultiTrack ? Object.values(this.settings.trackAudioSources).map((deviceId) => this.getAudioStream(deviceId)) : [this.getAudioStream(this.settings.audioDeviceId)];
    return Promise.all(streamPromises);
  }
  async getAudioStream(deviceId) {
    return navigator.mediaDevices.getUserMedia({
      audio: {
        deviceId: deviceId ? { exact: deviceId } : void 0,
        sampleRate: this.settings.sampleRate
      }
    });
  }
  async getAudioInputDevices() {
    const devices = await navigator.mediaDevices.enumerateDevices();
    return devices.filter((device) => device.kind === "audioinput");
  }
  async saveRecording() {
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
    const fileLinks = [];
    if (this.settings.outputMode === "single") {
      const mergedAudio = await this.mergeAudioTracks();
      const fileName = `${this.settings.filePrefix}-multitrack-${timestamp}.wav`;
      const filePath = await this.saveAudioFile(mergedAudio, fileName);
      if (filePath)
        fileLinks.push(filePath);
    } else {
      for (let i = 0; i < this.audioChunks.length; i++) {
        const chunks = this.audioChunks[i];
        if (chunks.length === 0)
          continue;
        const audioBlob = new Blob(chunks, { type: `audio/${this.settings.recordingFormat}` });
        const sourceName = await this.getAudioSourceName(this.settings.trackAudioSources[i + 1]);
        const fileName = `${this.settings.filePrefix}-${sourceName}-${timestamp}.${this.settings.recordingFormat}`;
        const filePath = await this.saveAudioFile(audioBlob, fileName);
        if (filePath)
          fileLinks.push(filePath);
      }
    }
    if (fileLinks.length > 0) {
      this.insertFileLinks(fileLinks);
      new import_obsidian2.Notice(`Saved ${fileLinks.length} audio file(s)`);
    } else {
      new import_obsidian2.Notice("No audio data recorded");
    }
  }
  async mergeAudioTracks() {
    const audioContext = new (window.AudioContext || window.AudioContext)();
    const buffers = await Promise.all(this.audioChunks.map(async (chunks) => {
      if (chunks.length === 0)
        return null;
      const blob = new Blob(chunks, { type: `audio/${this.settings.recordingFormat}` });
      const arrayBuffer = await blob.arrayBuffer();
      return audioContext.decodeAudioData(arrayBuffer);
    }));
    const validBuffers = buffers.filter((buffer) => buffer !== null);
    if (validBuffers.length === 0) {
      throw new Error("No audio data recorded");
    }
    const longestDuration = Math.max(...validBuffers.map((buffer) => buffer.duration));
    const offlineContext = new OfflineAudioContext(2, audioContext.sampleRate * longestDuration, audioContext.sampleRate);
    validBuffers.forEach((buffer) => {
      const source = offlineContext.createBufferSource();
      source.buffer = buffer;
      source.connect(offlineContext.destination);
      source.start(0);
    });
    const renderedBuffer = await offlineContext.startRendering();
    return this.bufferToWave(renderedBuffer, renderedBuffer.length);
  }
  bufferToWave(abuffer, len) {
    this.debugLog("abuffer:" + abuffer);
    this.debugLog("len:" + len);
    this.debugLog("abuffer.numberOfChannels:" + abuffer.numberOfChannels);
    const numOfChan = abuffer.numberOfChannels;
    const length = len * numOfChan * 2 + 44;
    const buffer = new ArrayBuffer(length);
    const view = new DataView(buffer);
    const channels = [];
    let i, sample;
    let offset = 0;
    this.debugLog(`Buffer length: ${abuffer.length}, Channels: ${numOfChan}, Sample rate: ${abuffer.sampleRate}`);
    setUint32(1179011410);
    setUint32(length - 8);
    setUint32(1163280727);
    setUint32(544501094);
    setUint32(16);
    setUint16(1);
    setUint16(numOfChan);
    setUint32(abuffer.sampleRate);
    setUint32(abuffer.sampleRate * 2 * numOfChan);
    setUint16(numOfChan * 2);
    setUint16(16);
    setUint32(1635017060);
    setUint32(length - 44);
    for (i = 0; i < abuffer.numberOfChannels; i++)
      channels.push(abuffer.getChannelData(i));
    for (offset = 0; offset < len && offset < abuffer.length; offset++) {
      for (i = 0; i < numOfChan; i++) {
        sample = Math.max(-1, Math.min(1, channels[i][offset]));
        view.setInt16(44 + offset * numOfChan * 2 + i * 2, sample < 0 ? sample * 32768 : sample * 32767, true);
      }
    }
    return new Blob([buffer], { type: "audio/wav" });
    function setUint16(data) {
      view.setUint16(offset, data, true);
      offset += 2;
    }
    function setUint32(data) {
      view.setUint32(offset, data, true);
      offset += 4;
    }
  }
  async saveAudioFile(audioBlob, fileName) {
    if (audioBlob.size === 0) {
      this.debug(`Skipping empty file: ${fileName}`);
      return null;
    }
    const arrayBuffer = await audioBlob.arrayBuffer();
    const base64Audio = Buffer.from(arrayBuffer).toString("base64");
    let sanitizedFileName = fileName.replace(/[\\\\/:*?"<>|]/g, "-");
    let filePath = (0, import_obsidian2.normalizePath)(this.settings.saveFolder + "/" + sanitizedFileName);
    let counter = 1;
    while (await this.app.vault.adapter.exists(filePath)) {
      const parts = sanitizedFileName.split(".");
      const ext = parts.pop();
      const name = parts.join(".");
      sanitizedFileName = `${name}_${counter}.${ext}`;
      filePath = (0, import_obsidian2.normalizePath)(this.settings.saveFolder + "/" + sanitizedFileName);
      counter++;
    }
    await this.app.vault.createBinary(filePath, Buffer.from(base64Audio, "base64"));
    return filePath;
  }
  insertFileLinks(fileLinks) {
    var _a;
    const editor = (_a = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView)) == null ? void 0 : _a.editor;
    if (editor) {
      const links = fileLinks.map((path) => `![[${path}]]`).join("\n");
      editor.replaceSelection(links);
    }
  }
  async getAudioSourceName(deviceId) {
    const devices = await this.getAudioInputDevices();
    const device = devices.find((d) => d.deviceId === deviceId);
    return device ? device.label.replace(/[^a-zA-Z0-9]/g, "") || `Device${deviceId}` : "UnknownDevice";
  }
  async showDeviceSelectionModal() {
    const devices = await this.getAudioInputDevices();
    if (devices.length === 0) {
      new import_obsidian2.Notice("No audio input devices found");
      return;
    }
    new SelectInputDeviceModal(this.app, this, devices).open();
  }
  debug(message) {
    if (this.settings.debug) {
      console.log(`[AudioRecorder Debug] ${message}`);
    }
  }
};
var SelectInputDeviceModal = class extends import_obsidian2.Modal {
  constructor(app, plugin, devices) {
    super(app);
    this.plugin = plugin;
    this.devices = devices;
  }
  onOpen() {
    const { contentEl } = this;
    new import_obsidian2.Setting(contentEl).setName("Select audio input device").setHeading();
    const dropdown = contentEl.createEl("select");
    this.devices.forEach((device) => {
      const option = dropdown.createEl("option");
      option.value = device.deviceId;
      option.text = device.label || `Device ${device.deviceId}`;
    });
    const button = contentEl.createEl("button", { text: "Select" });
    button.onclick = async () => {
      const selectedDeviceId = dropdown.value;
      this.plugin.settings.audioDeviceId = selectedDeviceId;
      await this.plugin.saveSettings();
      new import_obsidian2.Notice(`Selected audio device: ${dropdown.selectedOptions[0].text}`);
      this.close();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var main_default = AudioRecorderPlugin;
