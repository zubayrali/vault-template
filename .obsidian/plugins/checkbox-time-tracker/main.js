/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Main
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");
var import_view = require("@codemirror/view");

// src/commands.ts
var import_obsidian4 = require("obsidian");

// src/operations.ts
var import_obsidian3 = require("obsidian");

// src/Task.ts
var import_obsidian = require("obsidian");

// src/Status.ts
var StatusType = {
  TODO: "TODO",
  DOING: "DOING",
  DONE: "DONE",
  CANCELLED: "CANCELLED"
};
var StatusSymbol = {
  [StatusType.TODO]: " ",
  [StatusType.DOING]: "/",
  [StatusType.DONE]: "x",
  [StatusType.CANCELLED]: "-"
};
var Status = class _Status {
  constructor(symbol, name, type, nextStatusType) {
    this.symbol = symbol;
    this.name = name;
    this.type = type;
    this.nextStatusType = nextStatusType;
  }
  static fromType(type) {
    switch (type) {
      case StatusType.TODO:
        return _Status.Todo();
      case StatusType.DOING:
        return _Status.Doing();
      case StatusType.DONE:
        return _Status.Done();
      case StatusType.CANCELLED:
        return _Status.Cancelled();
      default:
        throw new Error(`Unknown status type: ${type}`);
    }
  }
  static fromSymbol(symbol) {
    switch (symbol) {
      case StatusSymbol.TODO:
        return _Status.Todo();
      case StatusSymbol.DOING:
        return _Status.Doing();
      case StatusSymbol.DONE:
        return _Status.Done();
      case StatusSymbol.CANCELLED:
        return _Status.Cancelled();
      default:
        throw new Error(`Unknown status symbol: ${symbol}`);
    }
  }
  nextStatus() {
    return _Status.fromType(this.nextStatusType);
  }
  static Todo() {
    return new _Status(
      StatusSymbol.TODO,
      "Todo",
      StatusType.TODO,
      StatusType.DOING
    );
  }
  static Doing() {
    return new _Status(
      StatusSymbol.DOING,
      "Doing",
      StatusType.DOING,
      StatusType.DONE
    );
  }
  static Done() {
    return new _Status(
      StatusSymbol.DONE,
      "Done",
      StatusType.DONE,
      StatusType.DONE
    );
  }
  static Cancelled() {
    return new _Status(
      StatusSymbol.CANCELLED,
      "Cancelled",
      StatusType.CANCELLED,
      StatusType.TODO
    );
  }
  static isTodo(status) {
    return status.type === StatusType.TODO;
  }
  static isDoing(status) {
    return status.type === StatusType.DOING;
  }
  static isDone(status) {
    return status.type === StatusType.DONE;
  }
};

// src/Task.ts
var Task = class _Task {
  constructor({
    indentation = "",
    listMarker = "-",
    checkboxBody,
    status,
    start,
    end,
    taskBody
  }) {
    this.indentation = indentation;
    this.listMarker = listMarker;
    this.checkboxBody = checkboxBody;
    this.status = status;
    this.start = start;
    this.end = end;
    this.taskBody = taskBody;
  }
  /**
   * タスクを開始する
   * @returns ステータスがDOINGで、開始時刻の実績が入ったTask
   *
   * タスクの開始時は、先頭が時刻表記であるかどうかに関わらず開始時刻を挿入できるよう、
   * checkboxBodyをtaskBodyにコピーし、startをtimeに設定し、endをundefinedにする
   */
  makeDoing(time) {
    return new _Task({
      ...this,
      status: Status.Doing(),
      // @ts-expect-error: In obsidian.d.ts, Moment is namespace imported instead of default imported.
      start: time ?? (0, import_obsidian.moment)(),
      end: void 0,
      taskBody: this.checkboxBody
    });
  }
  /**
   * タスクを終了する
   * @returns ステータスがDONEで、終了時刻の実績が入ったTask
   *
   * タスク終了時は、終了時刻
   */
  makeDone(time) {
    return new _Task({
      ...this,
      status: Status.Done(),
      // @ts-expect-error: In obsidian.d.ts, Moment is namespace imported instead of default imported.
      end: time ?? (0, import_obsidian.moment)()
    });
  }
};

// src/utils.ts
var import_obsidian2 = require("obsidian");
function parseDateTime(dateTime, format) {
  const dateTimeParsed = (0, import_obsidian2.moment)(dateTime, format, true);
  if (!dateTimeParsed.isValid()) {
    throw new Error(
      "Invalid date-time format. Expected format: " + format + "."
    );
  }
  return dateTimeParsed;
}

// src/operations.ts
var taskOperations = class {
  constructor(settings) {
    this.taskBodyRegex = /(?= )\s+(?<taskBody>.*)/;
    this.settings = settings;
  }
  get startRegex() {
    return this.settings.enableDateInserting ? /\s*(?<start>\S+? \S+?)/ : /\s*(?<start>\S+?)/;
  }
  get endRegex() {
    return this.settings.enableDateInserting ? /\s*(?<end>\S+? \S+?)/ : /\s*(?<end>\S+?)/;
  }
  get doingBodyRegex() {
    return new RegExp(this.startRegex.source + this.taskBodyRegex.source);
  }
  get doneBodyRegex() {
    return new RegExp(
      this.startRegex.source + this.settings.separator + this.endRegex.source + this.taskBodyRegex.source
    );
  }
  parseLine(line) {
    const { statusSymbol } = splitCheckbox(line);
    const status = Status.fromSymbol(statusSymbol);
    if (Status.isTodo(status)) {
      return this.parseTodo(line);
    } else if (Status.isDoing(status)) {
      return this.parseDoing(line);
    } else if (Status.isDone(status)) {
      return this.parseDone(line);
    }
  }
  parseTodo(line) {
    const {
      indentation,
      listMarker,
      statusSymbol,
      body: checkboxBody
    } = splitCheckbox(line);
    const status = Status.fromSymbol(statusSymbol);
    return new Task({
      indentation,
      listMarker,
      status,
      checkboxBody,
      start: void 0,
      end: void 0,
      taskBody: checkboxBody
    });
  }
  parseDoing(line) {
    const {
      indentation,
      listMarker,
      statusSymbol,
      body: checkboxBody
    } = splitCheckbox(line);
    const status = Status.fromSymbol(statusSymbol);
    const matchingTimes = checkboxBody.match(this.doingBodyRegex);
    if (matchingTimes === null) {
      throw new Error("Line does not match Doing regex");
    }
    const { start, taskBody } = matchingTimes.groups ?? {};
    const parsed = parseDateTime(start, this.datetimeFormat);
    return new Task({
      indentation,
      listMarker,
      status,
      checkboxBody,
      start: parsed,
      end: void 0,
      taskBody
    });
  }
  parseDone(line) {
    const {
      indentation,
      listMarker,
      statusSymbol,
      body: checkboxBody
    } = splitCheckbox(line);
    const status = Status.fromSymbol(statusSymbol);
    const matchingTimes = checkboxBody.trim().match(this.doneBodyRegex);
    if (matchingTimes === null) {
      throw new Error("Line does not match Done regex");
    }
    const { start, end, taskBody } = matchingTimes.groups ?? {};
    const parsedStart = parseDateTime(start, this.datetimeFormat);
    const parsedEnd = parseDateTime(end, this.datetimeFormat);
    return new Task({
      indentation,
      listMarker,
      status,
      checkboxBody,
      start: parsedStart,
      end: parsedEnd,
      taskBody
    });
  }
  get datetimeFormat() {
    return this.settings.enableDateInserting ? `${this.settings.dateFormat} ${this.settings.timeFormat}` : this.settings.timeFormat;
  }
  toggleTask(task, start_time = (0, import_obsidian3.moment)(), end_time = (0, import_obsidian3.moment)()) {
    if (!this.settings.enableDoingStatus || this.settings.disableDoingStatusForSubTasks && task.indentation.length > 0) {
      return this.endTask(task, end_time);
    }
    if (task.status.type === StatusType.TODO) {
      return this.startTask(task, start_time);
    } else if (task.status.type === StatusType.DOING) {
      return this.endTask(task, end_time);
    } else {
      return task;
    }
  }
  /**
   * Duplicate a task as new task
   * @param task
   */
  duplicateTask(task) {
    return new Task({
      ...task,
      checkboxBody: task.taskBody,
      status: Status.Todo(),
      start: void 0,
      end: void 0
    });
  }
  checkWillIncrement(task, end_time) {
    return !!(this.settings.autoIncrementOnSameTime && task.start && task.start.isSame(end_time, "minute"));
  }
  // @ts-expect-error: In obsidian.d.ts, Moment is namespace imported instead of default imported.
  startTask(task, time = (0, import_obsidian3.moment)()) {
    if (task.status.type !== StatusType.TODO) {
      throw new Error("Task is not in TODO status");
    }
    return task.makeDoing(time);
  }
  // @ts-expect-error: In obsidian.d.ts, Moment is namespace imported instead of default imported.
  endTask(task, time = (0, import_obsidian3.moment)()) {
    const willIncrement = this.checkWillIncrement(task, time);
    const end_time = willIncrement ? time.clone().add(1, "minutes") : time.clone();
    return task.makeDone(end_time);
  }
  formatTask(task) {
    const start = task.start?.format(this.datetimeFormat) ?? "";
    const startEndSeparator = task.start && task.end ? this.settings.separator : "";
    const endDatetimeFormat = this.settings.omitEndDateOnSameDate && task.start?.isSame(task.end, "day") ? this.settings.timeFormat : this.datetimeFormat;
    const end = task.end?.format(endDatetimeFormat) ?? "";
    const bodySeparator = task.start || task.end ? " " : "";
    return `${task.indentation}${task.listMarker} [${task.status.symbol}] ${start}${startEndSeparator}${end}${bodySeparator}${task.taskBody}`;
  }
};
var INDENTATION_REGEX = /^(?<indentation>[\s\t]*)/;
var LIST_MARKER_REGEX = /(?<listMarker>[-*+])/;
var CHECKBOX_MARKER_REGEX = /\[(?<statusSymbol>.)\]/u;
var CHECKBOX_BODY_REGEX = / *(?<body>.*)/u;
var CHECKBOX_REGEX = new RegExp(
  INDENTATION_REGEX.source + LIST_MARKER_REGEX.source + " +" + CHECKBOX_MARKER_REGEX.source + CHECKBOX_BODY_REGEX.source,
  "u"
);
function splitCheckbox(line) {
  const regexMatch = line.match(CHECKBOX_REGEX);
  if (regexMatch === null) {
    throw new Error("Line does not match task regex");
  }
  const { indentation, listMarker, statusSymbol, body } = regexMatch.groups ?? {};
  return { indentation, listMarker, statusSymbol, body };
}

// src/commands.ts
function createCommands(settings) {
  return [
    {
      id: "cycle-task-status",
      name: "Cycle task status",
      icon: "check-in-circle",
      editorCallback: (editor) => {
        const { line, ch } = editor.getCursor();
        const lineContent = editor.getLine(line);
        const taskOp = new taskOperations(settings);
        const task = taskOp.parseLine(lineContent);
        if (!task) {
          new import_obsidian4.Notice("No task found");
          return;
        }
        try {
          const toggled = taskOp.toggleTask(task);
          editor.setLine(line, taskOp.formatTask(toggled));
          editor.setCursor(line, ch);
        } catch (e) {
          new import_obsidian4.Notice(e.message);
        }
      }
    },
    {
      id: "duplicate-as-new-task",
      name: "Duplicate as new task",
      icon: "copy-check",
      editorCallback: (editor) => {
        const { line, ch } = editor.getCursor();
        const lineContent = editor.getLine(line);
        const taskOp = new taskOperations(settings);
        const task = taskOp.parseLine(lineContent);
        if (!task) {
          new import_obsidian4.Notice("No task found");
          return;
        }
        try {
          const taskOp2 = new taskOperations(settings);
          const duplicated = taskOp2.duplicateTask(task);
          editor.replaceRange("\n" + taskOp2.formatTask(duplicated), {
            line,
            ch: lineContent.length
          });
          editor.setCursor(line, ch);
        } catch (e) {
          new import_obsidian4.Notice(e.message);
        }
      }
    },
    {
      id: "end-and-duplicate-task",
      name: "End current task and insert duplicated on the next line",
      icon: "check-check",
      editorCallback: (editor) => {
        const { line, ch } = editor.getCursor();
        const lineContent = editor.getLine(line);
        const taskOp = new taskOperations(settings);
        const task = taskOp.parseLine(lineContent);
        if (!task) {
          new import_obsidian4.Notice("No task found");
          return;
        }
        try {
          const taskOp2 = new taskOperations(settings);
          const ended = taskOp2.endTask(task);
          editor.setLine(line, taskOp2.formatTask(ended));
          const duplicated = taskOp2.duplicateTask(ended);
          editor.replaceRange("\n" + taskOp2.formatTask(duplicated), {
            line,
            ch: editor.getLine(line).length
          });
          editor.setCursor(line, ch);
        } catch (e) {
          new import_obsidian4.Notice(e.message);
        }
      }
    }
  ];
}

// src/settings.ts
var import_obsidian5 = require("obsidian");
var DEFAULT_SETTINGS = {
  targetCssClasses: ["checkbox-time-tracker", "ctt"],
  timeFormat: "HH:mm",
  separator: "-",
  enableDateInserting: false,
  dateFormat: "YYYY-MM-DD",
  omitEndDateOnSameDate: false,
  enableDoingStatus: false,
  disableDoingStatusForSubTasks: false,
  autoIncrementOnSameTime: false
};
var SettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian5.Setting(containerEl).setName("CSS classes for track").setDesc(
      "Specify the CSS class of the element to which the timer applies. If you specify multiple classes, separate them with spaces. There is no need to start with a dot (.)."
    ).addTextArea(
      (text) => text.setPlaceholder("").setValue(this.plugin.settings.targetCssClasses.join(" ")).onChange(async (value) => {
        this.plugin.settings.targetCssClasses = value.split(/\s+|\n+/);
        await this.plugin.saveSettings();
        this.display();
      })
    );
    const timeFormatSettingEl = new import_obsidian5.Setting(containerEl).setName("Time format").setDesc("The format of the time to insert. (default: HH:mm)");
    timeFormatSettingEl.addMomentFormat(
      (text) => text.setDefaultFormat("HH:mm").setValue(this.plugin.settings.timeFormat).onChange(async (value) => {
        if (value.includes(" ")) {
          timeFormatSettingEl.controlEl.addClass("setting-error");
          new import_obsidian5.Notice("Time format should not contain spaces.");
          return;
        }
        timeFormatSettingEl.controlEl.removeClass("setting-error");
        this.plugin.settings.timeFormat = value;
        await this.plugin.saveSettings();
      }).inputEl.onblur = () => {
        this.display();
      }
    );
    new import_obsidian5.Setting(containerEl).setName("Enable date inserting").setDesc("Insert the date in addition to the time.").addToggle((tc) => {
      tc.setValue(this.plugin.settings.enableDateInserting).onChange(
        async (value) => {
          this.plugin.settings.enableDateInserting = value;
          await this.plugin.saveSettings();
          this.display();
        }
      );
    });
    if (this.plugin.settings.enableDateInserting) {
      const dateFormatSettingEl = new import_obsidian5.Setting(containerEl).setName("Date format").setDesc("The format of the date to insert. (default: YYYY-MM-DD)");
      dateFormatSettingEl.addMomentFormat(
        (text) => text.setDefaultFormat("HH:mm").setValue(this.plugin.settings.dateFormat).onChange(async (value) => {
          if (value.includes(" ")) {
            timeFormatSettingEl.controlEl.addClass("setting-error");
            new import_obsidian5.Notice("Time format should not contain spaces.");
            return;
          }
          timeFormatSettingEl.controlEl.removeClass("setting-error");
          this.plugin.settings.dateFormat = value;
          await this.plugin.saveSettings();
        }).inputEl.onblur = () => {
          this.display();
        }
      );
    }
    new import_obsidian5.Setting(containerEl).setName("Enable doing status").setDesc(
      `Adds Doing(In Progress) to the status. The symbol is "/".
        So, when you click a checkbox, it will switch like this: ex. [ ] -> [/] -> [x].
        A custom theme or CSS snippet may be required to display the symbols properly.`
    ).addToggle((tc) => {
      tc.setValue(this.plugin.settings.enableDoingStatus).onChange(
        async (value) => {
          this.plugin.settings.enableDoingStatus = value;
          if (!value) {
            this.plugin.settings.disableDoingStatusForSubTasks = false;
          }
          await this.plugin.saveSettings();
          this.display();
        }
      );
    });
    if (this.plugin.settings.enableDoingStatus) {
      const separatorEl = new import_obsidian5.Setting(containerEl).setName("Separator");
      const separatorDesc = document.createDocumentFragment();
      separatorDesc.append(
        "Separator between start time and end time. (default: -)",
        separatorDesc.createEl("br"),
        separatorDesc.createEl("em", {
          text: "The following special characters are not allowed: ^ $ * + ? . [ ] { } | \\"
        })
      );
      separatorEl.setDesc(separatorDesc);
      separatorEl.addText(
        (text) => text.setPlaceholder("-").setValue(this.plugin.settings.separator).onChange(async (value) => {
          const disallowedCharsRegex = /[$*+?.|()\\[\]{}]/;
          if (disallowedCharsRegex.test(value)) {
            separatorEl.controlEl.addClass("setting-error");
            new import_obsidian5.Notice("Separator should not contain special characters.");
            this.plugin.settings.separator = value.replaceAll(
              disallowedCharsRegex,
              ""
            );
            await this.plugin.saveSettings();
            return;
          }
          this.plugin.settings.separator = value;
          await this.plugin.saveSettings();
        }).inputEl.onblur = () => {
          this.display();
        }
      );
    }
    if (this.plugin.settings.enableDoingStatus) {
      new import_obsidian5.Setting(containerEl).setName("Disable doing status for sub tasks").setDesc(
        "Turn this on if you don't want to use the Doing status for subtasks (indented checkboxes)"
      ).addToggle((tc) => {
        tc.setValue(
          this.plugin.settings.disableDoingStatusForSubTasks
        ).onChange(async (value) => {
          this.plugin.settings.disableDoingStatusForSubTasks = value;
          await this.plugin.saveSettings();
        });
      });
    }
    if (this.plugin.settings.enableDoingStatus) {
      new import_obsidian5.Setting(containerEl).setName(
        "Enable auto increment when end time is the same as start time"
      ).setDesc(
        "If the start and end time are the same, delay the end time by 1 minute."
      ).addToggle((tc) => {
        tc.setValue(this.plugin.settings.autoIncrementOnSameTime).onChange(
          async (value) => {
            this.plugin.settings.autoIncrementOnSameTime = value;
            await this.plugin.saveSettings();
          }
        );
      });
    }
    if (this.plugin.settings.enableDoingStatus && this.plugin.settings.enableDateInserting) {
      new import_obsidian5.Setting(containerEl).setName("Omit end date on same date").setDesc(
        "If the end date is the same as the start date, do not insert end date to avoid duplication."
      ).addToggle((tc) => {
        tc.setValue(this.plugin.settings.omitEndDateOnSameDate).onChange(
          async (value) => {
            this.plugin.settings.omitEndDateOnSameDate = value;
            await this.plugin.saveSettings();
            this.display();
          }
        );
      });
    }
    const taskOp = new taskOperations(this.plugin.settings);
    const TASK_SETTINGS = {
      indentation: "",
      listMarker: "-",
      checkboxBody: "",
      status: Status.Doing(),
      // @ts-ignore
      start: (0, import_obsidian5.moment)(),
      // @ts-ignore
      end: (0, import_obsidian5.moment)().add(1, "hour"),
      taskBody: "Example task"
    };
    const desc = containerEl.createEl("p", {
      text: "Preview inserted datetime: ",
      cls: "inserted-preview"
    });
    desc.createEl("span", {
      text: this.plugin.settings.enableDoingStatus ? taskOp.formatTask(
        new Task({
          ...TASK_SETTINGS,
          status: Status.Done()
        })
      ) : taskOp.formatTask(
        new Task({
          ...TASK_SETTINGS,
          status: Status.Done(),
          start: void 0
        })
      )
    });
  }
};

// src/LivePreview.ts
var import_obsidian6 = require("obsidian");
var LivePreviewExtension = class {
  constructor(view, settings) {
    this.view = view;
    this.settings = settings;
    this.handleClickEvent = this.handleClickEvent.bind(this);
    this.view.dom.addEventListener("click", this.handleClickEvent);
  }
  destroy() {
    this.view.dom.removeEventListener("click", this.handleClickEvent);
  }
  handleClickEvent(event) {
    const { target } = event;
    const eventTarget = target;
    let parent = eventTarget?.parentElement;
    const classNames = this.settings.targetCssClasses;
    while (parent) {
      if (classNames.some((className) => parent?.classList.contains(className))) {
        break;
      }
      parent = parent.parentElement;
    }
    if (!parent) {
      return false;
    }
    if (!target || !(target instanceof HTMLInputElement) || target.type !== "checkbox") {
      return false;
    }
    event.preventDefault();
    try {
      const { state } = this.view;
      const position = this.view.posAtDOM(target);
      const line = state.doc.lineAt(position);
      const taskOp = new taskOperations(this.settings);
      const task = taskOp.parseLine(line.text);
      if (!task) {
        return false;
      }
      const toggled = taskOp.toggleTask(task);
      const transaction = state.update({
        changes: {
          from: line.from,
          to: line.to,
          insert: taskOp.formatTask(toggled)
        }
      });
      this.view.dispatch(transaction);
      const desiredCheckedStatus = target.checked;
      setTimeout(() => {
        target.checked = desiredCheckedStatus;
      }, 1);
    } catch (e) {
      new import_obsidian6.Notice(e.message);
    }
    return true;
  }
};

// src/main.ts
var Main = class extends import_obsidian7.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SettingTab(this.app, this));
    this.registerEditorExtension(
      import_view.ViewPlugin.define((view) => new LivePreviewExtension(view, this.settings))
    );
    createCommands(this.settings).forEach((command) => {
      this.addCommand(command);
    });
    const styleElement = document.createElement("style");
    styleElement.id = "checkbox-time-tracker-styles";
    styleElement.textContent = `${this.settings.targetCssClasses.map((cn) => `.${cn}`).join(", ")} {
        .HyperMD-task-line[data-task="x"] {
          /* Specify only label and input so that links in the text are clickable. */
          label,input {
            /* Disable the click event to prevent the visual check from being removed when clicking multiple times. */
            /* ref. https://github.com/obsidian-tasks-group/obsidian-tasks/issues/2389#issuecomment-1794328100 */
            pointer-events: none;
          }
        }
    `;
    document.head.appendChild(styleElement);
  }
  onunload() {
    const styleElement = document.getElementById(
      "checkbox-time-tracker-styles"
    );
    if (styleElement) {
      styleElement.remove();
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
